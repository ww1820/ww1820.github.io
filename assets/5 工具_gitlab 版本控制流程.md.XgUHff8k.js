import{_ as e,o as t,c as o,ag as i}from"./chunks/framework.DEqXEGcv.js";const g=JSON.parse('{"title":"gitlab 版本控制流程","description":"","frontmatter":{"tags":["tool","git"]},"headers":[],"relativePath":"5 工具/gitlab 版本控制流程.md","filePath":"5 工具/gitlab 版本控制流程.md","lastUpdated":1770953870000}'),s={name:"5 工具/gitlab 版本控制流程.md"};function l(d,a,c,r,h,n){return t(),o("div",null,[...a[0]||(a[0]=[i(`<h1 id="gitlab-版本控制流程" tabindex="-1">gitlab 版本控制流程 <a class="header-anchor" href="#gitlab-版本控制流程" aria-label="Permalink to &quot;gitlab 版本控制流程&quot;">​</a></h1> <h2 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h2> <ol><li><p>基于 develop 创建新分支，命名格式：<code>feature/[姓名]/[迭代编号]_[功能描述]</code>；
举例：<code>feature/zhangsan/sp08_config_load</code></p></li> <li><p>单个功能开发完成，先更新 develop 分支到最新版本，
再切换回到 feature 分支，用 feature 分支合并 develop 分支，解决冲突进行自测，
再在网页端创建合并分支的请求（提交 feature 分支合并到 develop 分支的请求）；</p></li></ol> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/1312962011%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="git 工作流程" loading="lazy"></p> <h2 id="git-stash" tabindex="-1">git stash <a class="header-anchor" href="#git-stash" aria-label="Permalink to &quot;git stash&quot;">​</a></h2> <h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3> <p>当我们开发一个新功能时会先从 master 拉出一个分支 develop ，然后在这个 develop 分支下写代码开发新功能。
就在此时，线上版本 master 出现了 bug ，我们应该放下手头上新功能的开发工作先将 master 上的 bug 修复，这个时候 develop 分支下的改动怎么处理？</p> <p>新功能的代码还没开发完成，就这样把有问题的代码提交到dev分支中，虽然可以解决目前我们的处境但不是很妥。</p> <h3 id="暂存更改" tabindex="-1">暂存更改 <a class="header-anchor" href="#暂存更改" aria-label="Permalink to &quot;暂存更改&quot;">​</a></h3> <p><code>git stash</code> 可以保存当前工作区和暂存区的修改，并忽略未跟踪和忽略的文件。
命令可以将在当前分支修改的内容放到缓存区中，并会自动建立一个缓存的list集合，方便管理。
通过 <code>git stash list</code> 可以看到list下的所有暂存。</p> <p>stash 是本地的，不会通过 <code>git push</code> 命令上传到 git server 上。
实际应用中推荐给每个 stash 加一个 message ，用于记录版本，使用 <code>git stash save &quot;message&quot;</code> 取代 <code>git stash</code> 命令。</p> <p>可以使用附加选项让 <code>git stash</code> 来处理未跟踪和忽略的文件：</p> <ol><li><code>git stash -u</code> 或 <code>git stash --includ-untracked</code> 储存未追踪的文件。</li> <li><code>git stash -a</code> 或 <code>git stash --all</code> 储存未跟踪的文件和忽略的文件。</li></ol> <h3 id="释放暂存" tabindex="-1">释放暂存 <a class="header-anchor" href="#释放暂存" aria-label="Permalink to &quot;释放暂存&quot;">​</a></h3> <p>如果想将修改的内容重新释放出来，<code>git stash apply</code> 和 <code>git stash pop</code> 都可以达到这个目的。</p> <p>两者的区别：</p> <ol><li><code>git stash apply @{x}</code> ：将编号x的缓存释放出来，但是该缓存还存在于list中；</li> <li><code>git stash apply</code>：将当前分支的最后一次缓存的内容释放出来，但是刚才的记录还存在list中；</li> <li><code>git stash pop</code>：将当前分支的最后一次缓存的内容释放出来，但是刚才的记录不存在list中。</li></ol> <h3 id="删除暂存" tabindex="-1">删除暂存 <a class="header-anchor" href="#删除暂存" aria-label="Permalink to &quot;删除暂存&quot;">​</a></h3> <ol><li><code>git stash drop stash@{index}</code>：丢弃stash@{index}存储，从列表中删除某个存储</li> <li><code>git stash clear</code>：清除存储列表中的所有stash</li></ol>`,37)])])}const u=e(s,[["render",l]]);export{g as __pageData,u as default};
