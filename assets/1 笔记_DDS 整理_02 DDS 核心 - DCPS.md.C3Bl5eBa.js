import{_ as i,o as a,c as l,ag as r}from"./chunks/framework.DEqXEGcv.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"1 笔记/DDS 整理/02 DDS 核心 - DCPS.md","filePath":"1 笔记/DDS 整理/02 DDS 核心 - DCPS.md","lastUpdated":1770889489000}'),o={name:"1 笔记/DDS 整理/02 DDS 核心 - DCPS.md"};function e(n,t,s,d,c,g){return a(),l("div",null,[...t[0]||(t[0]=[r('<p>DCPS（<strong>D</strong>ata-<strong>C</strong>entric <strong>P</strong>ublish-<strong>S</strong>ubscribe，以数据为中心的发布/订阅）规范是DDS系列规范最初也是最核心的规范，在某些场合DDS规范指的就是DCPS规范。</p> <p>DCPS的内容分为三大块：</p> <ul><li>模型描述，介绍模型中涉及的概念；</li> <li>接口描述，分模块定义类并定义接口形式及接口功能描述；</li> <li>QoS定义，定义22种QoS的功能及其配置方式。</li></ul> <h2 id="模型描述" tabindex="-1">模型描述 <a class="header-anchor" href="#模型描述" aria-label="Permalink to &quot;模型描述&quot;">​</a></h2> <h3 id="实体概念" tabindex="-1">实体概念 <a class="header-anchor" href="#实体概念" aria-label="Permalink to &quot;实体概念&quot;">​</a></h3> <p>DCPS实体模型定义了三层实体，如下图所示：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20260202135507994.png" alt="image.png" loading="lazy"></p> <ul><li><strong>Domain</strong>: 代表一个通信平面，由 Domain ID 唯一标识，只有在同一个域内的通信实体才可以通信；如果考虑车内通信，可以只划分 1 个 Domain，也可以按照交互规则或其他规则，定义多个 Domain；</li> <li><strong>Domain Participant</strong>: 代表域内通信的应用程序的本地成员身份；可以理解为“某个进程（或应用实例）加入到一个 DDS 通信域（Domain）后的代表对象”，它是 DDS 实体体系的<strong>根节点/入口</strong>，负责把应用纳入 DDS 的发现与通信机制中。</li> <li><strong>Topic</strong>: 是数据的抽象概念，由 TopicName 标识，关联相应数据的数据类型 (DataType)，如果把车内所涉及的所有 Topic 集合在一起，这样就形成一个虚拟的全局数据空间“Global Data Space”，进一步弱化了节点的概念，所以域参与者已经不是节点的概念了；</li> <li><strong>Publisher</strong>: 发布者，发布主题数据，至少与 1 个 DataWriter 关联，通过调用 DataWriter 的相关函数将数据发出去；</li> <li><strong>Subscriber</strong>: 订阅者，订阅主题数据，至少与 1 个 DataReader 关联。当数据到达时，应用程序可能忙于执行其他操作或应用程序只是等待该消息时，这样就会存在两种情况，同步访问和异步通知。</li> <li><strong>DataWriter</strong>: 数据写入者，类似缓存，把需要发布的主题数据从应用层写入到 DataWriter 中；</li> <li><strong>DataReader</strong>: 数据读取者，同样可以理解为一种缓存，从订阅者得到主题数据，随之传给应用层；</li></ul> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20260203100415242.png" alt="image.png" loading="lazy"></p> <h3 id="数据描述" tabindex="-1">数据描述 <a class="header-anchor" href="#数据描述" aria-label="Permalink to &quot;数据描述&quot;">​</a></h3> <table tabindex="0"><thead><tr><th>概念</th> <th>说明</th> <th>标识</th></tr></thead> <tbody><tr><td>主题</td> <td>最大类，域内唯一的主题名称，并关联1个数据类型。</td> <td>主题名+类型</td></tr> <tr><td>实例</td> <td>主题数据中key成员相同的数据的集合，即使用key成员进一步区分主题数据，可以理解成“子主题”。</td> <td>InstanceHandle_t</td></tr> <tr><td>样本</td> <td>每次向DDS发送一次数据产生一个数据样本。</td> <td>序列号</td></tr></tbody></table> <h2 id="接口描述" tabindex="-1">接口描述 <a class="header-anchor" href="#接口描述" aria-label="Permalink to &quot;接口描述&quot;">​</a></h2> <p>定义类并定义接口形式及接口功能描述，详见协议规范文档。</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20260203100403600.png" alt="image.png" loading="lazy"></p> <h2 id="qos-定义" tabindex="-1">QOS 定义 <a class="header-anchor" href="#qos-定义" aria-label="Permalink to &quot;QOS 定义&quot;">​</a></h2> <p>QoS（Quality of Service）即服务质量。在有限的带宽资源下，QoS为各种业务分配带宽，为业务提供端到端的服务质量保证。例如，语音、视频和重要的数据应用在网络设备中可以通过配置QoS优先得到服务。</p> <p>DDS（Data Distribution Service）规范中定义了 <strong>22种标准QoS（Quality of Service，服务质量）策略</strong>，用于精细控制数据通信的行为，涵盖可靠性、持久性、资源管理、发现机制、数据呈现等多个维度。这些策略可应用于不同的DDS实体（如DomainParticipant、Publisher/Subscriber、DataWriter/DataReader、Topic等），并支持匹配协商机制以确保通信双方兼容。</p> <h3 id="_1、与数据传输行为相关的策略" tabindex="-1">1、与<strong>数据传输行为</strong>相关的策略 <a class="header-anchor" href="#_1、与数据传输行为相关的策略" aria-label="Permalink to &quot;1、与**数据传输行为**相关的策略&quot;">​</a></h3> <ol><li><strong>Reliability（可靠性）</strong> <ul><li>控制是否保证数据送达：<code>BEST_EFFORT</code>（尽力而为）或 <code>RELIABLE</code>（可靠传输）。</li></ul></li> <li><strong>Durability（持久性）</strong> <ul><li>控制历史数据对晚加入订阅者的可用性：<code>VOLATILE</code>、<code>TRANSIENT_LOCAL</code>、<code>TRANSIENT</code>、<code>PERSISTENT</code>。</li></ul></li> <li><strong>History（历史记录）</strong> <ul><li>定义每个实例保留多少样本：<code>KEEP_LAST</code>（保留最近N个）或 <code>KEEP_ALL</code>（保留全部）。</li></ul></li> <li><strong>Deadline（截止时间）</strong> <ul><li>要求数据必须在指定周期内更新，否则触发事件。</li></ul></li> <li><strong>LatencyBudget（延迟预算）</strong> <ul><li>允许应用指定可接受的最大端到端传输延迟。</li></ul></li> <li><strong>Ownership（所有权）</strong> <ul><li>支持独占或共享数据写入权，避免多个发布者冲突。</li></ul></li> <li><strong>OwnershipStrength（所有权强度）</strong> <ul><li>配合Ownership使用，数值高的DataWriter获得写入优先权。</li></ul></li> <li><strong>Liveliness（活跃性）</strong> <ul><li>检测DataWriter是否“存活”：<code>AUTOMATIC</code>、<code>MANUAL_BY_PARTICIPANT</code>、<code>MANUAL_BY_TOPIC</code>。</li></ul></li> <li><strong>TimeBasedFilter（基于时间的过滤）</strong> <ul><li>限制DataReader接收数据的最大频率（如每100ms最多一次）。</li></ul></li></ol> <h5 id="设置为-best-effort-就一定不可靠吗" tabindex="-1">设置为 BEST-EFFORT 就一定不可靠吗？ <a class="header-anchor" href="#设置为-best-effort-就一定不可靠吗" aria-label="Permalink to &quot;设置为 BEST-EFFORT 就一定不可靠吗？&quot;">​</a></h5> <p>不一定。因为 DDS 里定义的可靠性 QoS 指的是“是否需要 DDS 做额外的可靠保证。”，比如传输层使用的是 TCP 传输或者其他 RTPS 底层的协议已经保证了可靠的传输，这时候配置 DDS 为 BEST-EFFORT 同样可以实现可靠的传输。</p> <h5 id="设置为-reliable-就一定可靠吗" tabindex="-1">设置为 RELIABLE 就一定可靠吗？ <a class="header-anchor" href="#设置为-reliable-就一定可靠吗" aria-label="Permalink to &quot;设置为 RELIABLE 就一定可靠吗？&quot;">​</a></h5> <p>答案同样是不一定。可靠的实现方式是确认重传，简单来说就是在接收到告知发送端数据已经收到之前，数据是需要缓存在队列中以备可能需要的重传，既然有队列，就会有长度限制（无论是存储在内存还是文件中，受限于存储空间的大小），当队列到达上限并需要发送新的样本数据时，会有如下的几个处理方式：</p> <ul><li>替换老的样本数据，这种处理模式下，当被替换的数据丢包需要重传时，无法重传，从而造成“丢包”，就是无法实现可靠；</li> <li>阻塞等待队列有额外的空间，这种处理模式下可以实现“觉得”的可靠；</li></ul> <h3 id="_2、与资源管理与限制相关的策略" tabindex="-1">2、与<strong>资源管理与限制</strong>相关的策略 <a class="header-anchor" href="#_2、与资源管理与限制相关的策略" aria-label="Permalink to &quot;2、与**资源管理与限制**相关的策略&quot;">​</a></h3> <ol start="10"><li><strong>ResourceLimits（资源限制）</strong> <ul><li>限制缓存中最大样本数、实例数、每个实例的样本数等。</li></ul></li> <li><strong>Presentation（表示）</strong> <ul><li>控制同一Publisher/Subscriber下多个DataWriter/DataReader的数据呈现顺序和范围（如<code>INSTANCE</code>、<code>TOPIC</code>、<code>GROUP</code>级别）。</li></ul></li> <li><strong>Partition（分区）</strong> <ul><li>在Domain内创建逻辑子通道，只有相同Partition的发布/订阅才能通信。</li></ul></li> <li><strong>DestinationOrder（目标排序）</strong> <ul><li>控制DataReader接收样本的顺序：按源时间戳（<code>BY_SOURCE_TIMESTAMP</code>）或接收顺序（<code>BY_RECEPTION_TIMESTAMP</code>）。</li></ul></li></ol> <h3 id="_3、与元数据与用户自定义信息相关的策略" tabindex="-1">3、与<strong>元数据与用户自定义信息</strong>相关的策略 <a class="header-anchor" href="#_3、与元数据与用户自定义信息相关的策略" aria-label="Permalink to &quot;3、与**元数据与用户自定义信息**相关的策略&quot;">​</a></h3> <ol start="14"><li><strong>UserData（用户数据）</strong> <ul><li>允许在DomainParticipant、Publisher等实体上附加任意二进制元数据。</li></ul></li> <li><strong>TopicData（主题数据）</strong> <ul><li>附加到Topic的元数据，传播给所有基于该Topic的读写器。</li></ul></li> <li><strong>GroupData（组数据）</strong> <ul><li>附加到Publisher/Subscriber的元数据，传播给其下属所有DataWriter/DataReader。</li></ul></li></ol> <hr> <h3 id="_4、与生命周期与发现机制相关的策略" tabindex="-1">4、与<strong>生命周期与发现机制</strong>相关的策略 <a class="header-anchor" href="#_4、与生命周期与发现机制相关的策略" aria-label="Permalink to &quot;4、与**生命周期与发现机制**相关的策略&quot;">​</a></h3> <ol start="17"><li><strong>EntityFactory（实体工厂）</strong> <ul><li>控制父实体删除时是否自动销毁其创建的子实体（如DataReader是否随Subscriber自动删除）。</li></ul></li> <li><strong>WriterDataLifecycle / ReaderDataLifecycle（读写器数据生命周期）</strong> <ul><li>控制DataWriter是否在删除时自动注销其实例；DataReader是否自动清除未更新的实例。</li></ul></li> <li><strong>DurabilityService（持久化服务）</strong> <ul><li>配置当Durability为<code>TRANSIENT</code>或<code>PERSISTENT</code>时，外部持久化服务的行为（如清理延迟、历史深度等）。</li></ul></li></ol> <hr> <h3 id="_5、与安全与扩展相关的策略-部分来自dds-security或xtypes" tabindex="-1">5、与<strong>安全与扩展</strong>相关的策略（部分来自DDS Security或XTypes） <a class="header-anchor" href="#_5、与安全与扩展相关的策略-部分来自dds-security或xtypes" aria-label="Permalink to &quot;5、与**安全与扩展**相关的策略（部分来自DDS Security或XTypes）&quot;">​</a></h3> <blockquote><p>注：严格来说，以下策略可能属于扩展规范，但在完整DDS实现（如OpenDDS、Fast DDS）中常被计入22种之内。</p></blockquote> <ol start="20"><li><strong>TransportPriority（传输优先级）</strong> <ul><li>为数据流设置网络传输优先级（依赖底层传输支持）。</li></ul></li> <li><strong>Lifespan（生命周期）</strong> <ul><li>指定数据样本的有效生存时间，超时后自动丢弃。</li></ul></li> <li><strong>IgnoreLocal（忽略本地）</strong> <ul><li>控制是否忽略来自同一DomainParticipant的本地发布（用于避免自收）。</li></ul></li></ol>',69)])])}const h=i(o,[["render",e]]);export{D as __pageData,h as default};
