import{_ as i,o as a,c as n,ag as l}from"./chunks/framework.DEqXEGcv.js";const o=JSON.parse('{"title":"1 让自己习惯 C++","description":"","frontmatter":{"tags":["cpp"]},"headers":[],"relativePath":"2 计算机/编程语言/Effective C++（第三版） 笔记.md","filePath":"2 计算机/编程语言/Effective C++（第三版） 笔记.md","lastUpdated":1770949611000}'),p={name:"2 计算机/编程语言/Effective C++（第三版） 笔记.md"};function e(t,s,h,k,r,d){return a(),n("div",null,[...s[0]||(s[0]=[l(`<blockquote><p><em><strong>改善程序与设计的55个具体做法。</strong></em></p></blockquote> <h1 id="_1-让自己习惯-c" tabindex="-1">1 让自己习惯 C++ <a class="header-anchor" href="#_1-让自己习惯-c" aria-label="Permalink to &quot;1 让自己习惯 C++&quot;">​</a></h1> <h2 id="条款-01-视-c-为一个语言联邦" tabindex="-1">条款 01：视 C++ 为一个语言联邦 <a class="header-anchor" href="#条款-01-视-c-为一个语言联邦" aria-label="Permalink to &quot;条款 01：视 C++ 为一个语言联邦&quot;">​</a></h2> <p>C++ 的四个次语言：</p> <ol><li>C。区块、语句、与处理、内置数据类型、数组、指针等。</li> <li>面向对象的 C++。类、封装、继承、多态、虚函数等。</li> <li>模板 C++。泛型编程、模板元编程等。</li> <li>STL。C++标准模板库，容器、迭代器、算法、分配器、适配器、仿函数。</li></ol> <p>C++ 是四个次语言组成的语言联邦，每个语言都有自己的规约。</p> <blockquote><p>C++ 高效编程守则视状况而变化，取决于你用 C++ 的哪部分。</p></blockquote> <h2 id="条款-02-尽量以-const-enum-inline-替换-define" tabindex="-1">条款 02：尽量以 <code>const</code>，<code>enum</code>，<code>inline</code> 替换 <code>#define</code> <a class="header-anchor" href="#条款-02-尽量以-const-enum-inline-替换-define" aria-label="Permalink to &quot;条款 02：尽量以 \`const\`，\`enum\`，\`inline\` 替换 \`#define\`&quot;">​</a></h2> <p>即：宁可以编译器替换预处理器。</p> <p>原因：</p> <ol><li>错误信息难以追踪；</li> <li>预处理直接替换可能导致目标码出现多份相同代码。</li></ol> <p>常量替换 <code>#define</code> 的两种特殊情况：</p> <ol><li><p>常量指针</p> <p>char*-base字符串，必须写 <code>const</code> 两次：</p> <p><code>const char* const authorName = &quot;Scott Meyers&quot;;</code></p> <p><code>string</code> 通常比char*-base更合适：</p> <p><code>const std::string authorName = &quot;Scott Meyers&quot;;</code></p></li> <li><p>class 专属常量</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GamePlayer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NumTurns </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 常量声明式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scores[NumTurns];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 使用该常量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>通常 C++ 要求你对你所使用的任何一种东西提供一个定义式，但如果它是个 class 专属常量且为整数类型（例如 ints,chars,bools），只要不取它们的地址，可以声明并使用它们而无需提供定义式。</p> <p>但如果要取某个 class 专属常量的地址，或者你的编译器（不正确地）坚持要看到一个定义式，你就必须另外提供定义式如下（在非头文件中）：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GamePlayer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::NumTurns;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 常量定义式（声明时获得初值，不可再设初值）</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ol> <p>旧的编译器也许不支持上述语法，它们不允许 static 成员在其声明式上获得初值。此外所谓的“in-class 初值设定”也只允许对整数常量进行。如果编译器不支持上述语法，可以将初值放在定义式：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CostEstimate</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FudgeFactor;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // static class 常量声明</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// static class 常量定义，位于实现文件内</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CostEstimate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::FudgeFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>例外是当你在 class 编译期间需要一个class常量值，例如上述的 GamePlayer::scores 的数组声明式中（编译器必须在编译期间知道数组的大小）。如果编译器不允许在“static 整数型 class 常量”完成“in-class 初值设定”，可改用 &quot;the enum hack&quot; 补偿做法：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GamePlayer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NumTurns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // the enum hack</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scores[NumTurns];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 使用该常量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol><li>enum hack 的行为某方面说比较像 <code>#define</code> 而不像 <code>const</code>。例如取一个<code>const</code>的地址是合法的，但取一个<code>enum</code>的地址就不合法，而取一个<code>#define</code>的地址通常也不合法。如果你不想让别人获得一个 pointer 或 reference 指向你的某个整数常量，enum可以帮助你实现这个约束。优秀的编译器不会为“整数型 const 对象”设定另外的存储空间（除非你创建一个 pointer 或 reference 指向该对象），不够优秀的编译器却可能如此。<code>enum</code>和<code>#define</code>s一样绝不会导致非必要的内存分配。</li> <li>“enum hack”是 templatemetaprogramming（模板元编程）的基础技术。</li></ol> <p><code>#define</code> 带参宏可以使用 tempalte inline 函数替代，避免额外的函数调用开销。</p> <blockquote><ol><li>对于单纯的常量，最好以<code>const</code>对象或<code>enum</code>s替换 <code>#define</code>s;</li> <li>对于形似函数的宏（macros），最好改用inline函数替换<code>#define</code>s。</li></ol></blockquote> <h2 id="条款-03-尽可能使用-const" tabindex="-1">条款 03：尽可能使用 const <a class="header-anchor" href="#条款-03-尽可能使用-const" aria-label="Permalink to &quot;条款 03：尽可能使用 const&quot;">​</a></h2> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // non-const pointer, non-const data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // non-const pointer, const data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // const pointer, non-const data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // const pointer, const data</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>函数返回一个常量值，往往可以降低客户错误而造成的意外，而又不至于放弃安全性和高效性，如 <code>if (a * b = c)</code>。</p> <h3 id="const-成员函数" tabindex="-1">const 成员函数 <a class="header-anchor" href="#const-成员函数" aria-label="Permalink to &quot;const 成员函数&quot;">​</a></h3> <p>目的：为了确认该成员函数可作用于 const 对象身上。 const 函数之所以重要，基于两个理由：</p> <ol><li>使得 class 接口比较容易理解；</li> <li>操作 const 对象成为可能（大多数用于 passed-by-pointer-to-const 或 passed-by-reference-to-const）。</li></ol> <p>两个成员函数如果只是常量性（constness）不同，可以被重载。</p> <p>两种 const 概念：</p> <ol><li>bitwise constness（physical constness），不更改对象内的任何一个 bit， C++ 对常量性的定义</li> <li>logical constness</li></ol> <p>许多成员函数虽然不具备十足的const性质，却能通过 bitwise 测试。更具体地说，一个更改了“指针所指物”的成员函数虽然不能算是const，但如果只有指针（而非所指物）隶属于对象，那么称此函数为 bitwise const 不会引发编译器异议。</p> <p>当 const 函数返回一个 reference 指向其（const）对象的内部值，其实现代码并不改变内部对象，但能获取到内部对象的指针，通过该指针可以改变该const对象的内部成员。</p> <p>这种情况导出所谓的 logical constness。这一派拥护者主张，一个 const 成员函数可以修改它所处理的对象内的某些 bits，但只有在客户端侦测不出的情况下才得如此，例如<strong>多线程访问const对象的内部变量，需要对资源进行加锁，需要将 std::mutex 成员声明为 mutable。</strong> mutable 释放掉 non-static 成员变量的 bitwise constness 约束。</p> <h3 id="在-const-和-non-const-成员函数中避免重复" tabindex="-1">在 const 和 non-const 成员函数中避免重复 <a class="header-anchor" href="#在-const-和-non-const-成员函数中避免重复" aria-label="Permalink to &quot;在 const 和 non-const 成员函数中避免重复&quot;">​</a></h3> <p>可以用non-const版本调用const版本，只是要<strong>两次转型</strong>。不能用const版本调用non-const版本。</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TextBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text[position];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const_cast&lt;char&amp;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将op[]返回值的const转除</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">              static_cast&lt;const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TextBlock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 为*this加上const</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                [</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] // 调用const op[]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><ol><li>将某些东西声明为 const 可以帮助编译器侦测出错误的用法。const 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体；</li> <li>编译器强制实施 bitwise constness，但你编写程序时应该使用“概念性上的常量”；</li> <li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ol></blockquote> <h2 id="条款-04-确定对象被使用前已先被初始化" tabindex="-1">条款 04：确定对象被使用前已先被初始化 <a class="header-anchor" href="#条款-04-确定对象被使用前已先被初始化" aria-label="Permalink to &quot;条款 04：确定对象被使用前已先被初始化&quot;">​</a></h2> <p>通常如果你使用 C part of C++而且初始化可能招致运行期成本那么久不保证发生初始化。一旦进入 non-C parts of C++，规则有些变化，这就很好地解释了为什么数组不保证其内容被初始化，而 vector 却有此保证。</p> <p>最佳的解决办法是：永远在使用对象之前先将它初始化。</p> <ol><li>对于无任何成员的内置类型，必须手工初始化；</li> <li>对于内置类型以外的其它东西，初始化的责任落在构造函数上，确保每个构造函数都将对象的每一个成员初始化。</li></ol> <p>注意区别赋值（assignment）和初始化（initialize）。<strong>C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。</strong> 在构造函数里的 “=” 操作，其实是赋值。<strong>但对于内置类型来说，不保证一定在你所看到的那个赋值动作的时间点之前获得初值。</strong></p> <p>构造函数较佳的写法是使用 member initialization list（成员初始化列表）替换赋值动作。赋值版本的构造函数首先调用 default 构造函数为成员变量设置初值，然后立即对他们赋予新值；而成员初始化列表中对各个成员变量的实参被作为各成员变量的构造函数的实参进行<strong>拷贝构造</strong>。</p> <p>规定：总是在初值列表中列出所有成员变量，以免还需记住哪些成员变量可以无需初值。</p> <p>如果成员变量时const或者reference他们就一定需要初值，不能被赋值。</p> <p>C++ 有非常固定的“成员初始化次序”：base classes 早于 derived classes 被初始化，而 class 的成员变量总是以其声明次序被初始化。</p> <p>C++ 对“定义于不同编译单元内的 non-local static 对象”的初始化次序并无明确定义，所以可能会在一个类的内部访问未初始化的 non-local static 对象。解决方案是将每个 non-local static 对象搬到自己的专属函数内部，该对象在此函数内部被声明为 static，函数返回一个引用指向它所含的对象。换句话说 non-local static 被 local static 对象替代了。这是 Singleton 模式的一种常见的实现手法。</p> <blockquote><ol><li>为内置对象进行手工初始化，因为 C++ 不保证初始化他们；</li> <li>构造函数最好使用成员初始化列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和他们在 class 中的声明次序相同；</li> <li>为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。</li></ol></blockquote> <h1 id="_2-构造-析构-赋值运算" tabindex="-1">2 构造/析构/赋值运算 <a class="header-anchor" href="#_2-构造-析构-赋值运算" aria-label="Permalink to &quot;2 构造/析构/赋值运算&quot;">​</a></h1> <h2 id="条款-05-了解-c-默认编写并调用了哪些函数" tabindex="-1">条款 05：了解 C++ 默认编写并调用了哪些函数 <a class="header-anchor" href="#条款-05-了解-c-默认编写并调用了哪些函数" aria-label="Permalink to &quot;条款 05：了解 C++ 默认编写并调用了哪些函数&quot;">​</a></h2> <p>如果你自己没有声明，编译器会为一个类声明（编译器版本的）一个 copy 构造函数、一个 copy assignment 操作符和一个析构函数。此外，如果你没有声明任何构造函数，编译器也会为你声明一个 default 构造函数。所有这些函数都是 public 且 inline 的（<em>本书于 06 年出版，还没有 C++11</em>）。</p> <blockquote><p>侯捷 C++11/14 课程中讲到</p> <p>C++中，当我们设计与编写一个类时，若不显著申明，则类会默认为我们提供如下几个函数：
1. 构造函数 (<code>A()</code>)
2. 析构函数（<code>~A()</code>）
3. 拷贝构造函数 (<code>A(A&amp;)</code>)
4. 拷贝赋值函数（<code>A&amp; operator=(A&amp;)</code>）
5. 移动构造函数（<code>A(A&amp;&amp;)</code>）
6. 移动赋值函数（<code>A&amp; operator=(A&amp;&amp;)</code>）</p> <p>注意：拷贝函数如果涉及指针就要区分浅拷贝（指针只占 4 字节，浅拷贝只把指针所占的那 4 个字节拷贝过去）和深拷贝（不仅要拷贝指针所占的字节，还要把指针所指的东西也要拷贝过去）；</p> <p>默认提供全局的默认操作符函数：
1. <code>operator</code>
2. <code>operator &amp;</code>
3. <code>operator &amp;&amp;</code>
4. <code>operator *</code>
5. <code>operator-&gt;</code>
6. <code>operator-&gt;*</code>
7. <code>operator new</code>
8. <code>operator delete</code></p></blockquote> <p>惟有当这些函数被需要（被调用），它们才会被编译器创建出来。</p> <p>default 构造函数和析构函数用来进行调用 base classes 和 non-static 成员变量的构造函数和析构函数之类的工作。注意，编译器产出的析构函数时 non-virtual 的，除非这个 class 的 base class 自身声明有 virtual 析构函数。</p> <p>至于 copy 构造函数和 copy assignment 操作符，编译器常见的版本只是单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象。</p> <p>编译器默认生成的 copy assignment 操作符其行为基本上与 copy 构造函数一致，但一般而言只有当生成的代码合法且有适当的机会证明它有意义，其表现才会如前。如果上述条件有其一不符合，编译器将拒绝为 class 生成 operator= 。</p> <ol><li>reference 和 const 成员变量，只能在声明时赋予初值且不能更改，编译器将拒绝生成 operator=；</li> <li>某个 base classes 将 copy assignment 操作符声明为 private，编译器将拒绝为其 derived classes 生成一个 copy assignment 操作符。</li></ol> <blockquote><p>编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符，以及析构函数。</p></blockquote> <h2 id="条款-06-若不想使用编译器自动生成的函数-就该明确拒绝" tabindex="-1">条款 06：若不想使用编译器自动生成的函数，就该明确拒绝 <a class="header-anchor" href="#条款-06-若不想使用编译器自动生成的函数-就该明确拒绝" aria-label="Permalink to &quot;条款 06：若不想使用编译器自动生成的函数，就该明确拒绝&quot;">​</a></h2> <blockquote><p>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为 private 并且不予实现。使用像 Uncopyable 这样的 base class 也是一种做法。</p></blockquote> <p>C++11 之后提供 =delete  关键字显式删除，告知编译器不生成函数默认的缺省版本。</p> <h2 id="条款-07-为多态基类声明-virtual-析构函数" tabindex="-1">条款 07：为多态基类声明 virtual 析构函数 <a class="header-anchor" href="#条款-07-为多态基类声明-virtual-析构函数" aria-label="Permalink to &quot;条款 07：为多态基类声明 virtual 析构函数&quot;">​</a></h2> <p>C++ 明确指出，当 derived class 对象经由一个由 base class 指针被删除，而该 base class 带着一个 non-virtual 析构函数，其结果未有定义——实际执行的时候通常发生的是对象的 derived 成分没被销毁。</p> <p>一个 class 如果不包含 virtual 函数，通常表示它并不意图被用作一个 base class，令其析构函数为 virtual 会增加其对象大小（虚表）。</p> <blockquote><ol><li>Polymorphic（带多态性质的）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，他就应该拥有一个 virtual 析构函数；</li> <li>Classes 的设计目的如果不是作为 base classes 使用，或者不是为了具备多态性（polymorphically），就不该声明 virtual 析构函数。</li></ol></blockquote> <p>补充：</p> <p>抽象类不能被实例化，但纯虚函数可以有实现，且必须在类的定义之外实现。另外，包含纯虚函数的类为抽象类，被继承后，<strong>在派生类析构函数被调用时抽象类析构函数也将被调用，因此必须有实现。</strong></p> <p>声明一个 pure virtual 函数的目的是为了让 derived classes <strong>只继承函数接口</strong>，派生类<strong>必须提供实现</strong>。</p> <p>可以为 pure virtual 函数提供定义，但使用时需要指明所属类。</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    virtual</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ~A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 纯虚析构函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">func1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">func1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;A::func1()&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*******************************************************************************</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 纯虚析构函数必须实现，不然链接器报错</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * [build] /usr/bin/ld: CMakeFiles/02_07.dir/02_07.cpp.o: in function \`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">B:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">:~B()&#39;:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * [build] /mnt/e/WorkSpace/Exercise/effective-cpp/02_07.cpp:20: undefined reference to \`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">A:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">:~A()&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *****************************************************************************/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {} </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pa </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pa-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">func1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pa-&gt;A::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">func1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h2 id="条款-08-别让异常逃离析构函数" tabindex="-1">条款 08：别让异常逃离析构函数 <a class="header-anchor" href="#条款-08-别让异常逃离析构函数" aria-label="Permalink to &quot;条款 08：别让异常逃离析构函数&quot;">​</a></h2> <p>如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，“强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数中传播出去（会导致不明确的行为）。</p> <blockquote><ol><li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常。析构函数应该捕捉该任何异常，然后吞下它们（不传播）或结束程序；</li> <li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ol></blockquote> <h2 id="条款-09-绝不在构造和析构过程中调用-virtual-函数" tabindex="-1">条款 09：绝不在构造和析构过程中调用 virtual 函数 <a class="header-anchor" href="#条款-09-绝不在构造和析构过程中调用-virtual-函数" aria-label="Permalink to &quot;条款 09：绝不在构造和析构过程中调用 virtual 函数&quot;">​</a></h2> <p>在 base class 构造期间，virtual 函数不是 virtual 函数，因为 base class 的构造函数执行更早于 derived class 构造函数，在 base class 构造期间，对象的类型是 base class 而不是 derived class。</p> <p>同理也适用于析构函数。</p> <blockquote><p>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class（比起当前执行构造函数和析构函数的那层）。</p></blockquote> <h2 id="条款-10-令-operator-返回一个-reference-to-this" tabindex="-1">条款 10：令 operator= 返回一个 reference to *this <a class="header-anchor" href="#条款-10-令-operator-返回一个-reference-to-this" aria-label="Permalink to &quot;条款 10：令 operator= 返回一个 reference to \\*this&quot;">​</a></h2> <p>为了实现“连锁赋值”，赋值操作符必须返回一个 reference 指向操作符左侧的实参，这是你为 classes 实现赋值操作时应该遵循的协议。这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，如：+=、-=、*=等。</p> <blockquote><p>令 operator= 返回一个 reference to *this。</p></blockquote> <h2 id="条款-11-在-operator-中处理-自我赋值" tabindex="-1">条款 11：在 operator= 中处理“自我赋值” <a class="header-anchor" href="#条款-11-在-operator-中处理-自我赋值" aria-label="Permalink to &quot;条款 11：在 operator= 中处理“自我赋值”&quot;">​</a></h2> <p>自我赋值可能会导致指针指向一个已经被删除的对象。</p> <ol><li><p>证同自测</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (_pm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rhs._pm)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // identity test</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _pm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    _pm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Men</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rhs._pm);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 创建副本</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>证同测试仍然存在异常方面的麻烦。当 <code>new Men</code> 抛出异常时会导致 Test 持有一个被删除过的指针。</p></li> <li><p>异常安全版本</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Men</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pm_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _pm;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 记住原先的 pm</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _pm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Men</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rhs._pm);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 创建副本</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        delete</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pm_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 删除原先的pm</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这样，即使 <code>new Men</code> 抛出异常，Test 所持有的的指针仍指向原处。如果关心效率，可以把证同自测放回函数起点处。但证同自测同样会增加成本：使代码变大（源码和目标码）并导入一个新的控制流分支。</p></li> <li><p>Copy and swap 技术</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /*...*/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Test </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rhs);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tmp);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>或者：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 本身是一份副本</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rhs);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这种方法牺牲了清晰性，但将“copy 动作”从函数本体内移至“函数参数构造阶段”却可令编译器有时生成更高效的代码。</p></li></ol> <blockquote><ol><li>确保当对象自我赋值时 operator= 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap；</li> <li>确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，其行为仍然正确。</li></ol></blockquote> <h2 id="条款-12-复制对象时勿忘其每一个成分" tabindex="-1">条款 12：复制对象时勿忘其每一个成分 <a class="header-anchor" href="#条款-12-复制对象时勿忘其每一个成分" aria-label="Permalink to &quot;条款 12：复制对象时勿忘其每一个成分&quot;">​</a></h2> <blockquote><ol><li>Copying 函数应该确保复制“对象内的所有成员变量”及“所有 base 成分”；</li> <li>不要尝试以某个 copying 函数实现另一个 copying 函数。应该将共同的机能放进第三个函数中，并由两个 copying 函数共同调用。</li></ol></blockquote> <h1 id="_3-资源管理" tabindex="-1">3 资源管理 <a class="header-anchor" href="#_3-资源管理" aria-label="Permalink to &quot;3 资源管理&quot;">​</a></h1> <h2 id="条款-13-以对象管理资源" tabindex="-1">条款 13：以对象管理资源 <a class="header-anchor" href="#条款-13-以对象管理资源" aria-label="Permalink to &quot;条款 13：以对象管理资源&quot;">​</a></h2> <p>“以对象管理资源”的两个关键想法：</p> <ol><li><strong>获得资源后立即放进管理对象</strong>内。实际上“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”（<em>Resource Acquisition Is Initialization,</em> RAII）；</li> <li>管理对象运用析构函数确保资源被释放。</li></ol> <blockquote><ol><li>为防止资源泄露，请使用 RAII 对象，他们在构造函数中获得资源并在析构函数中释放；</li> <li>两个常被使用的 RAII class 分别是 shared_ptr 和 auto_ptr。前者通常是较佳的选择，因为其 copy 行为比较直观，若选择 auto_ptr，复制动作会使它（被复制物）指向 null。</li></ol></blockquote> <h2 id="条款-14-在资源管理类中小心-copying-行为" tabindex="-1">条款 14：在资源管理类中小心 copying 行为 <a class="header-anchor" href="#条款-14-在资源管理类中小心-copying-行为" aria-label="Permalink to &quot;条款 14：在资源管理类中小心 copying 行为&quot;">​</a></h2> <ol><li>禁止复制；</li> <li>对低层资源祭出“引用计数法”（reference-count）；</li> <li>复制底部资源（深拷贝）；</li> <li>转移底部资源的拥有权。</li></ol> <blockquote><ol><li>复制 RAII 对象必须一并复制它所管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为；</li> <li>普遍而常见的 RAII class copying 行为是：抑制 copying、施行引用计数法（reference counting）。不过其他行为也可能被实现。</li></ol></blockquote> <h2 id="条款-15-在资源管理类中提供对原始资源的访问" tabindex="-1">条款 15：在资源管理类中提供对原始资源的访问 <a class="header-anchor" href="#条款-15-在资源管理类中提供对原始资源的访问" aria-label="Permalink to &quot;条款 15：在资源管理类中提供对原始资源的访问&quot;">​</a></h2> <blockquote><ol><li>APIs 往往要求访问原始资源（raw resources），所以每一个 RAII class 应该提供一个“取得”其所管理资源的方法；</li> <li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。</li></ol></blockquote> <h2 id="条款-16-成对使用-new-和-delete-时要采取相同的形式" tabindex="-1">条款 16：成对使用 new 和 delete 时要采取相同的形式 <a class="header-anchor" href="#条款-16-成对使用-new-和-delete-时要采取相同的形式" aria-label="Permalink to &quot;条款 16：成对使用 new 和 delete 时要采取相同的形式&quot;">​</a></h2> <p>new/delete 只调用<strong>一次构造/析构函数</strong>，new[]/delete[] 根据数组大小，<strong>多次调用构造/析构函数</strong>，分配/释放的空间大小是整个数组的大小。</p> <p>如果析构的对象里面没有指针类型的成员，直接使用 delete 释放 new[]的对象并不会导致内存泄漏。</p> <p>对 new 出的对象使用 delete[]，可能会导致读取到错误的“数组大小”，然后多次调用析构函数，但实际对象不是一个数组。</p> <p>当以 new 创建 typedef 类型对象时，也需要注意使用对应的形式删除之。</p> <blockquote><p>如果你在 new 表达式中使用[]，必须在相应的 delete 表达式中也使用[]；如果你在 new 表达式中不使用[]，一定不要在在相应的 delete 表达式中使用[]。</p></blockquote> <h2 id="条款-17-以独立的语句将-newed-对象置入智能指针" tabindex="-1">条款 17：以独立的语句将 newed 对象置入智能指针 <a class="header-anchor" href="#条款-17-以独立的语句将-newed-对象置入智能指针" aria-label="Permalink to &quot;条款 17：以独立的语句将 newed 对象置入智能指针&quot;">​</a></h2> <p>对于以下语句：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">processWidget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shared_ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Widget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Widget), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">priority</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在编译器调用 processWidget 之前要做的三件事：</p> <ol><li>调用 priority ()</li> <li>执行 new Widget</li> <li>调用 shared_ptr 的构造函数</li></ol> <p>C++ 编译器完成这些事情次序的弹性很大。可以确定的是 new Widget 一定执行于 shared_ptr 构造函数之前，但对 priority () 的调用可以在任何一步，考虑如下执行顺序：</p> <ol><li>执行 new Widget</li> <li>调用 priority ()</li> <li>调用 shared_ptr 的构造函数</li></ol> <p>若执行 priority () 时抛出异常，new Widget 返回的指针将会遗失，造成资源泄露。避免这类问题的办法：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shared_ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Widget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> Widget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在单独语句内以智能指针存储 newed 所得对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">processWidget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pw, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">priority</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>以独立语句将 newed 对象存储于（置于）只能指针中，如果不之这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</p></blockquote> <h1 id="_4-设计与声明" tabindex="-1">4 设计与声明 <a class="header-anchor" href="#_4-设计与声明" aria-label="Permalink to &quot;4 设计与声明&quot;">​</a></h1> <h2 id="条款-18-让接口容易被正确使用-不易被误用" tabindex="-1">条款 18：让接口容易被正确使用，不易被误用 <a class="header-anchor" href="#条款-18-让接口容易被正确使用-不易被误用" aria-label="Permalink to &quot;条款 18：让接口容易被正确使用，不易被误用&quot;">​</a></h2> <blockquote><ol><li>好的接口很容易被正确使用，不容易被误用。你应该在你所有的接口中努力达成这些性质；</li> <li>“促进正确使用”的办法包括接口一致性，以及与内置类型的行为兼容；</li> <li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户资源管理责任；</li> <li>share_ptr 支持定制删除器（custom deleter），这可防范 DLL 问题，可被用来自动解除互斥锁等等。</li></ol></blockquote> <h2 id="条款-19-设计-class-犹如设计-type" tabindex="-1">条款 19：设计 class 犹如设计 type <a class="header-anchor" href="#条款-19-设计-class-犹如设计-type" aria-label="Permalink to &quot;条款 19：设计 class 犹如设计 type&quot;">​</a></h2> <p>在设计 class 时你需要了解的问题：</p> <ol><li>新 type 的对象应该如何被创建和销毁？</li> <li>对象的初始化和对象的赋值该有什么样的差别？</li> <li>新的 type 的对象如果是 passed by value（以值传递），意味着什么？</li> <li>什么是新 type 的“合法值”？</li> <li>你的新 type 需要配合某个继承图系（inheritance graph）吗？virtual or non-virtual</li> <li>你的新 type 需要什么样的转换？隐式或者显示</li> <li>什么样的操作符和函数对此新 type 而言是合理的？</li> <li>什么样的标准函数应该被驳回？ = delete</li> <li>谁该取用新的 type 成员？ public/protected/private</li> <li>什么是新 type 的“未声明接口”（undeclared interface）？</li> <li>你的新 type 有多一般化？ class or class template</li> <li>你真需要一个新的 type 吗？non-member 函数或 templates</li></ol> <blockquote><p>class 的设计就是 type 的设计，在定义一个新的 type 之前，请确定你已经考虑过本条款覆盖的所有讨论主题。</p></blockquote> <h2 id="条款-20-宁以-pass-by-reference-to-const-替换-pass-by-value" tabindex="-1">条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value <a class="header-anchor" href="#条款-20-宁以-pass-by-reference-to-const-替换-pass-by-value" aria-label="Permalink to &quot;条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value&quot;">​</a></h2> <blockquote><ol><li>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem）；</li> <li>以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象，对它们而言 pass-by-value 往往比较适当。</li></ol></blockquote> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Less</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Less</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a,b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Less</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a,b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>编译器不进行优化得到的汇编代码：</p> <div class="language-x86asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">x86asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun1(int):</span></span>
<span class="line"><span>        push    rbp</span></span>
<span class="line"><span>        mov     rbp, rsp</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-4], edi  ; 传值</span></span>
<span class="line"><span>        mov     eax, DWORD PTR [rbp-4]  ; 取值</span></span>
<span class="line"><span>        pop     rbp</span></span>
<span class="line"><span>        ret</span></span>
<span class="line"><span>fun1(int const&amp;):</span></span>
<span class="line"><span>        push    rbp</span></span>
<span class="line"><span>        mov     rbp, rsp</span></span>
<span class="line"><span>        mov     QWORD PTR [rbp-8], rdi ; 传地址</span></span>
<span class="line"><span>        mov     rax, QWORD PTR [rbp-8] ; 取地址，&amp; 底层以指针实现</span></span>
<span class="line"><span>        mov     eax, DWORD PTR [rax]   ; 取值</span></span>
<span class="line"><span>        pop     rbp</span></span>
<span class="line"><span>        ret</span></span>
<span class="line"><span>Less::operator()(int, int) const:</span></span>
<span class="line"><span>        push    rbp</span></span>
<span class="line"><span>        mov     rbp, rsp</span></span>
<span class="line"><span>        mov     QWORD PTR [rbp-8], rdi</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-12], esi</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-16], edx</span></span>
<span class="line"><span>        mov     eax, DWORD PTR [rbp-12]</span></span>
<span class="line"><span>        cmp     eax, DWORD PTR [rbp-16]</span></span>
<span class="line"><span>        setl    al</span></span>
<span class="line"><span>        pop     rbp</span></span>
<span class="line"><span>        ret</span></span>
<span class="line"><span>fun3(int, int, Less):</span></span>
<span class="line"><span>        push    rbp</span></span>
<span class="line"><span>        mov     rbp, rsp</span></span>
<span class="line"><span>        sub     rsp, 16</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-4], edi</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-8], esi</span></span>
<span class="line"><span>        mov     edx, DWORD PTR [rbp-8]</span></span>
<span class="line"><span>        mov     ecx, DWORD PTR [rbp-4]</span></span>
<span class="line"><span>        lea     rax, [rbp-9]           ; Less() 地址</span></span>
<span class="line"><span>        mov     esi, ecx</span></span>
<span class="line"><span>        mov     rdi, rax</span></span>
<span class="line"><span>        call    Less::operator()(int, int) const</span></span>
<span class="line"><span>        leave</span></span>
<span class="line"><span>        ret</span></span>
<span class="line"><span>fun4(int, int, Less const&amp;):</span></span>
<span class="line"><span>        push    rbp</span></span>
<span class="line"><span>        mov     rbp, rsp</span></span>
<span class="line"><span>        sub     rsp, 16</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-4], edi</span></span>
<span class="line"><span>        mov     DWORD PTR [rbp-8], esi</span></span>
<span class="line"><span>        mov     QWORD PTR [rbp-16], rdx ; 传入的参数为指向 Less() 地址的指针</span></span>
<span class="line"><span>        mov     edx, DWORD PTR [rbp-8]</span></span>
<span class="line"><span>        mov     ecx, DWORD PTR [rbp-4]</span></span>
<span class="line"><span>        mov     rax, QWORD PTR [rbp-16]  ; Less() 地址</span></span>
<span class="line"><span>        mov     esi, ecx</span></span>
<span class="line"><span>        mov     rdi, rax</span></span>
<span class="line"><span>        call    Less::operator()(int, int) const</span></span>
<span class="line"><span>        leave</span></span>
<span class="line"><span>        ret</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><p>可以看出，对于内置类型和函数对象，引用传递比以值传递多了一次解引用，Iterator 同理。</p> <h2 id="条款-21-必须返回对象时-别妄想返回其-reference" tabindex="-1">条款 21：必须返回对象时，别妄想返回其 reference <a class="header-anchor" href="#条款-21-必须返回对象时-别妄想返回其-reference" aria-label="Permalink to &quot;条款 21：必须返回对象时，别妄想返回其 reference&quot;">​</a></h2> <blockquote><ol><li>绝不要返回 pointer 或 reference 指向一个 local stack 对象（会导致未定义的行为）</li> <li>绝不要返回 reference 指向一个 heap-allocated 对象（可能会导致资源泄露）</li> <li>绝不要返回 pointer 或 reference 指向一个 local static 对象，而有可能同时需要多个这样的对象。</li></ol></blockquote> <h2 id="条款-22-将成员变量声明为-private" tabindex="-1">条款 22：将成员变量声明为 private <a class="header-anchor" href="#条款-22-将成员变量声明为-private" aria-label="Permalink to &quot;条款 22：将成员变量声明为 private&quot;">​</a></h2> <blockquote><ol><li>切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性；</li> <li>protected 并不比 public 更具封装性。</li></ol></blockquote> <h2 id="条款-23-宁以-non-member、non-friend-替换-member-函数" tabindex="-1">条款 23：宁以 non-member、non-friend 替换 member 函数 <a class="header-anchor" href="#条款-23-宁以-non-member、non-friend-替换-member-函数" aria-label="Permalink to &quot;条款 23：宁以 non-member、non-friend 替换 member 函数&quot;">​</a></h2> <p>条款 22 层说过，成员变量应该是 private，因为如果它不是，就有无限数量的函数可以访问它们，它们也就毫无封装性。能够访问 private 成员变量的函数只有 class 的 member 函数加上 friend 函数而已。如果要在一个 member 函数（它不止可以访问 class 内的 private 数据，也可以取用 private 函数、enums、typedefs 等等）和一个 non-member ，non-friend 函数（它无法访问上述任何东西）之间做抉择，而且两者的机能相同，那么导致较大封装性的是 non-member、non-friend 函数，因为它们并不增加“能够访问 class 内之 private 成分”的数量。</p> <p>这个论述只适用于 non-member、non-friend 函数。friends 函数对 class private 成员的访问权力和 member 函数相同，因此两者对封装的冲击力道也相同。</p> <blockquote><p>宁可拿 non-member、non-friend 函数替换 member 函数。这样做可以增加封装性、包裹弹性和机能扩充性。</p></blockquote> <h2 id="条款-24-若所有参数皆需类型转换-请为此采用-non-member-函数" tabindex="-1">条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数 <a class="header-anchor" href="#条款-24-若所有参数皆需类型转换-请为此采用-non-member-函数" aria-label="Permalink to &quot;条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数&quot;">​</a></h2> <p>将 <code>operator*</code> 写成 Rational 成员函数的写法：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Rational</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> numerator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> denominator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> numerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> denominator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>存在的问题：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Rational</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> oneEight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Rational</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> oneHalf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Rational result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneEight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneHalf;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 正确</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resulr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> onHalf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 正确，隐式转换</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">resulr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> onHalf;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 错误</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不存一个在能够接收 int 和 Rational 作为参数的 non-member operator*，因此查找失败。</p> <p>non-member 函数：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                       const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rational</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">numerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rhs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">numerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                   lhs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">denominator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rhs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">denominator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>如果你需要为某个函数的所有参数（包括 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个 non-member，</p></blockquote> <h2 id="条款-25-考虑写出一个不抛异常的-swap-函数" tabindex="-1">条款 25：考虑写出一个不抛异常的 swap 函数 <a class="header-anchor" href="#条款-25-考虑写出一个不抛异常的-swap-函数" aria-label="Permalink to &quot;条款 25：考虑写出一个不抛异常的 swap 函数&quot;">​</a></h2> <blockquote><ol><li>当 <code>std::swap</code> 对你的类型效率不高时，提供一个 <code>swap</code> 成员函数，并确定这个函数不抛出异常；</li> <li>如果你提供一个 member <code>swap</code> ，一应该提供一个 non-member <code>swap</code> 用来调用前者。对于 classes（而非 templates ），也请特化 <code>std::swap</code>;</li> <li>调用 <code>swap</code> 时应针对 <code>std::swap</code> 使用 using 声明，然后调用 <code>swap</code> 并且不带任何“命名空间紫隔修饰”；</li> <li>为“用户定义类型”进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的</li></ol></blockquote> <p>自 C++11 起，引入了两个特殊的成员函数：<strong>移动构造函数和移动赋值运算符</strong>。编译器默认生成移动构造函数和移动赋值运算符需要满足的条件：</p> <ol><li>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数（这三者之一，表示程序员要自己处理对象的赋值或释放问题），编译器就不会为它生成默认的移动构造函数和移动构造操作符；</li> <li>如果类中没有提供移动构造函数和移动赋值操作符，且编译器不会生成默认的，那么我们在代码中通过 <code>std::move()</code> 调用的移动构造行为或者移动赋值行为将被转换为调用拷贝构造函数或者拷贝赋值操作符；</li> <li>如果一个类没有显示定义自己的拷贝构造函数、拷贝赋值运算符和析构函数，且类的每个非静态成员都可移动时，编译器才会生成默认的移动构造函数和移动构造操作符；</li> <li>如果显示地定义了移动构造函数和移动构造操作符，则拷贝构造函数和拷贝赋值操作符会被隐式删除（因此开发人员必须在需要时实现拷贝构造函数和拷贝构造操作符）</li></ol> <p>在使用移动构造之前，标准库的 <code>swap()</code> 函数：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    T temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 拷贝构造</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用 <code>move()</code> 函数以后：</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    T temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 移动构造</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(temp);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="_5-实现" tabindex="-1">5 实现 <a class="header-anchor" href="#_5-实现" aria-label="Permalink to &quot;5 实现&quot;">​</a></h1> <h2 id="条款-26-尽可能延后变量定义式的出现时间" tabindex="-1">条款 26：尽可能延后变量定义式的出现时间 <a class="header-anchor" href="#条款-26-尽可能延后变量定义式的出现时间" aria-label="Permalink to &quot;条款 26：尽可能延后变量定义式的出现时间&quot;">​</a></h2> <p>不只应该延后变量的定义，直到非得使用变量为止，甚至应该尝试延后这份定义直到能够给他初始是参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的 default 构造行为。</p> <p>如果在循环内使用变量，将变量定义于循环外（A）和定义于循环内（B）的两种做法的成本如下：</p> <ol><li>做法 A：1 个构造函数 + 1 个析构函数 + n 个赋值操作</li> <li>做法 B：n 个构造函数 + n 个析构函数</li></ol> <p>如果类的一个赋值成本低于一组析构+构造成本，做法 A 大体而言比较高效。尤其当 n 值很大的时候。否则做法 B 或许较好。此外做法 A 造成变量名称的作用域比做法 B 更大，有时那对程序的可理解性和易维护性造成冲突。</p> <p>因此，除非（1）你知道赋值成本比“构造+析构”成本低，（2）你在处理代码中效率高度敏感（performance-sensitive）的部分，否则你应该使用做法 B。</p> <blockquote><p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p></blockquote> <h2 id="条款-27-尽量减少转型动作" tabindex="-1">条款 27：尽量减少转型动作 <a class="header-anchor" href="#条款-27-尽量减少转型动作" aria-label="Permalink to &quot;条款 27：尽量减少转型动作&quot;">​</a></h2> <p>转型语法：</p> <ol><li>C 风格： <code>(T)expression</code></li> <li>函数风格：<code>T(expression)</code></li> <li>C++ 风格：
<ol><li><code>const_cast&lt;T&gt;(expression)</code> ：通常被用来将对象的常量性移除（cast away the constness）。它也是唯一有此能力的 C++-style 转型操作符。</li> <li><code>dynamic_cast&lt;T&gt;(expression)</code>：主要用来执行“安全向下转型”（safe downcasting），也就是用来决定对象对否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</li> <li><code>reinterpret_cast&lt;T&gt;(expression)</code>：意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。</li> <li><code>static_cast&lt;T&gt;(expression)</code> 用来强迫隐式转换（impact conversions），例如将 non-const 对象转为 const 对象，或将 int 转为 double 等等。它也可以用来执行上述多种转换的反向转换，但它无法将 const 转为 non-const——这个只有 const_cast 才能办到。</li></ol></li></ol> <p>新式转型的好处：</p> <ol><li>简化“找出类型系统在哪个地点被破坏”的过程；</li> <li>各转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。</li></ol> <blockquote><ol><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计；</li> <li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。</li> <li>宁可使用 C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li></ol></blockquote> <h2 id="条款-28-避免返回-handles-指向对象内部成分" tabindex="-1">条款 28：避免返回 handles 指向对象内部成分 <a class="header-anchor" href="#条款-28-避免返回-handles-指向对象内部成分" aria-label="Permalink to &quot;条款 28：避免返回 handles 指向对象内部成分&quot;">​</a></h2> <blockquote><p>避免返回 handles （包括 references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像一个 const，并将发生“虚吊号码牌”（dangling handles）的可能性降至最低。</p></blockquote> <h2 id="条款-29-为-异常安全-而努力是值得的" tabindex="-1">条款 29：为“异常安全”而努力是值得的 <a class="header-anchor" href="#条款-29-为-异常安全-而努力是值得的" aria-label="Permalink to &quot;条款 29：为“异常安全”而努力是值得的&quot;">​</a></h2> <div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PrettyMenu</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changeBlackground</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">istream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> imgSrc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 改变背景图像</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Mutex mutex;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 互斥器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bgImage;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 目前的背景图像</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> imageChanges;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 背景图像被改变的次数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PrettyMenu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">changeBackgound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">istream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> imgSrc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bgImage;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> imageChanges;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    bgImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(imgSrc);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>上述函数从“异常安全性”的观点来看很糟糕，“异常安全”有两个条件，当异常被抛出时，带有异常安全的函数会：</p> <ol><li><strong>不泄露任何资源</strong>。上述代码一旦 <code>new Image(imgSrc)</code> 导致异常，对 <code>unlock</code> 的调用就绝对不会执行，于是互斥器就永远被把持住了；</li> <li><strong>不允许数据败坏</strong>。如果 <code>new Image(imgScr)</code> 抛出异常，<code>bgImage</code> 就指向一个已被删除的对象。</li></ol> <p>解决资源泄露的问题很容易（以对象管理资源），现在专注与解决资源败坏问题。</p> <p>异常安全函数提供一下三个保证之一：</p> <ol><li><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。然而程序的现实状态恐怕不可预料。</li> <li><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。调用这样的函数需要有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。</li> <li><strong>不抛掷保证</strong>：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。</li></ol> <p>“copy and swap”策略是对对象做出“全有或全无”改变的一个很好办法，但一般而言它并不保证整个函数有强烈的异常安全性。问题出在“连带影响”。如果函数只操作局部性状态（local state），便相对容易地提供强烈保证。但是当函数对“非局部性数据”有连带影响时，提供强烈保证就困难得多。</p> <blockquote><ol><li>异常安全函数（Exception-safe functions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li> <li>“强烈保证”往往能够以“copy and swap”实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li> <li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li></ol></blockquote> <h2 id="条款-30-透彻了解-inlining-的里里外外" tabindex="-1">条款 30：透彻了解 inlining 的里里外外 <a class="header-anchor" href="#条款-30-透彻了解-inlining-的里里外外" aria-label="Permalink to &quot;条款 30：透彻了解 inlining 的里里外外&quot;">​</a></h2> <p>inline 只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出也可以明确提出</p>`,336)])])}const E=i(p,[["render",e]]);export{o as __pageData,E as default};
