import{_ as r,o as a,c as o,ag as t}from"./chunks/framework.DEqXEGcv.js";const d=JSON.parse('{"title":"Prometheus Server 内部架构","description":"","frontmatter":{},"headers":[],"relativePath":"2 计算机/项目/Prometheus/Promethues Server 内部架构.md","filePath":"2 计算机/项目/Prometheus/Promethues Server 内部架构.md","lastUpdated":1770889489000}'),n={name:"2 计算机/项目/Prometheus/Promethues Server 内部架构.md"};function i(s,e,p,h,c,l){return a(),o("div",null,[...e[0]||(e[0]=[t(`<h1 id="prometheus-server-内部架构" tabindex="-1">Prometheus Server 内部架构 <a class="header-anchor" href="#prometheus-server-内部架构" aria-label="Permalink to &quot;Prometheus Server 内部架构&quot;">​</a></h1> <p>#Prometheus</p> <p>整体的 Prometheus Server 内部架构如下图所示：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20230803143024.png" alt="Promethues Server内部架构" loading="lazy"></p> <p><strong>Note</strong>：箭头代表请求或者连接初始化的方向，而不一定是数据流向。</p> <h2 id="main-函数" tabindex="-1">main 函数 <a class="header-anchor" href="#main-函数" aria-label="Permalink to &quot;main 函数&quot;">​</a></h2> <p><a href="https://github.com/prometheus/prometheus/blob/v2.3.1/cmd/prometheus/main.go#L77-L600" target="_blank" rel="noreferrer"><code>main()</code></a> 函数初始化并运行所有其他 Prometheus Server 组件，同时将相互依赖的组件连接起来。</p> <ol><li><p>读取命令行配置并解析</p> <p><code>main()</code> 定义服务器命令行标志（flag）并解析配置，保存到局部配置结构体变量cfg，同时对某些值进行额外的校验和初始化。</p> <p>这些基于 flag 的配置独立于后续从配置文件中读取到的配置，配置文件根据 --config.file 选项设置。Promethues 区分了基于flag的配置和基于文件的配置：flag用于不支持在不重启服务器的情况下更新的简单设置，而配置文件中提供的任何设置都必须支持在不重启整个服务器的情况下重新加载。</p></li> <li><p>实例化组件</p> <p>实例化所有运行组件，并使用信道、引用或传递上下文将他们连接在一起，以便后续协调。这些组件包括：服务发现、目标抓取、存储等。</p></li> <li><p>运行组件</p> <p>server 以 <a href="https://www.brianstorti.com/the-actor-model/" target="_blank" rel="noreferrer">actor-like</a> 模型运行所有组件，使用 <a href="https://pkg.go.dev/github.com/oklog/run#section-readme" target="_blank" rel="noreferrer">run.Group</a> 来协调所有互相连接的 actor 的启动和关闭。多个信道用于强制执行顺序约束，例如在存储准备就绪和初始配置文件加载完成之前不启用网络接口。</p></li></ol> <h2 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h2> <p>配置子系统负责读取、验证和应用由 --config.file 提供的 yaml 配置文件。Promethues Server 支持读取和应用配置文件，同时有一个 [Goroutine](<a href="https://zhuanlan.zhihu.com/p/60613088" target="_blank" rel="noreferrer">Go goroutine理解 - 知乎 (zhihu.com)</a>) 来监视从同一个文件中重新加载配置的请求。</p> <h3 id="读取解析配置" tabindex="-1">读取解析配置 <a class="header-anchor" href="#读取解析配置" aria-label="Permalink to &quot;读取解析配置&quot;">​</a></h3> <p>加载初始配置或者后续重新加载时，Promethues 调用 <code>config.LoadFile()</code> 从文件读取配置信息并解析到 <code>config.Config</code> 结构体中，该结构体是 Promethues配置文件的顶层配置。它表示了Promethues服务器及其所有组件的整体配置，其结构体成员反映了配置文件的层次结构，每个结构体成员都有一个默认的配置和<code>UnmarshalYAML()</code>方法，该方法可以将配置文件解析到结构体中，并进行进一步的有效性验证和初始化，最后返回解析成功的配置结构体。</p> <h3 id="reload-handler" tabindex="-1">Reload handler <a class="header-anchor" href="#reload-handler" aria-label="Permalink to &quot;Reload handler&quot;">​</a></h3> <p>Reload handler 是一个 main 函数中实现的 Goroutine，它监听来自网络接口或者HUP信号的配置重载请求。</p> <p>收到重载请求后，Reload handler 会使用 <code>config.LoadFile()</code>从磁盘重新读取配置文件，生成<code>config.Config</code>结构体，并调用所有支持热配置的组件的<code>ApplyConfig()</code>方法或者自定义重载函数将配置结构体应用于这些组件。</p> <h2 id="termination-handler" tabindex="-1">Termination handler <a class="header-anchor" href="#termination-handler" aria-label="Permalink to &quot;Termination handler&quot;">​</a></h2> <p>Termination handler 是一个 main 函数中实现的 Goroutine，它监听来自网络接口或者TERM信号的终止请求。</p> <p>收到终止请求后，Termination handler 返回，并通过 run.Group 提供的 actor 协调功能触发其他 Promethues 组件有序关闭。</p> <h2 id="scrape-discovery-manager" tabindex="-1">Scrape discovery manager <a class="header-anchor" href="#scrape-discovery-manager" aria-label="Permalink to &quot;Scrape discovery manager&quot;">​</a></h2> <p>Scrape discovery manager 是一个 <a href="https://github.com/prometheus/prometheus/blob/v2.3.1/discovery/manager.go#L73-L89" target="_blank" rel="noreferrer">discovery.Manager</a> ，它通过 Promethues 的服务发现功能来查找并持续更新需要抓取指标的监控目标列表，它独立于 scrape manager （实际执行目标抓取的模块）运行，并通过同步信道向其提供目标组更新流。</p> <p>Scrape discovery manager 在自己的 Goroutine 中运行每个配置定义的服务发现机制实例。比如，如果配置文件中 scrape_config 定义了两个 kubernetes_sd_config，管理器将运行两个独立的 kubernetes.Discovery 实例。每个 discovery 实例都会实现discovery.Discoverer 接口，并通过同步信道向 discovery manager 发送目标更新， discovery manager 会用特定 discovery 实例的信息更新目标组，并将其转发给  scrape manager。</p> <p>在配置更改时，discovery manager 会停止当前运行的所有发现机制实例，并重新启动新配置文件中定义的新机制。</p> <h2 id="scrape-manager" tabindex="-1">Scrape manager <a class="header-anchor" href="#scrape-manager" aria-label="Permalink to &quot;Scrape manager&quot;">​</a></h2> <p>scrape manager是一个 <a href="https://github.com/prometheus/prometheus/blob/v2.3.1/scrape/manager.go#L47-L62" target="_blank" rel="noreferrer">scrape.Manager</a>，负责从已发现的监控目标中获取指标，并将抓取的样本转发到存储子系统。</p> <h3 id="目标更新和整体架构" tabindex="-1">目标更新和整体架构 <a class="header-anchor" href="#目标更新和整体架构" aria-label="Permalink to &quot;目标更新和整体架构&quot;">​</a></h3> <p>scrape manager 管理所有的抓取对象，所有的抓取对象按group分组，每个group是一个job_name，每个group下含多个 scrapeTarget ，即具体的抓取目标 endpoint。</p> <p>scrape manager 为每个 group 运行一个 scrape 池，每个 scrape 池对每个目标 endpoint 启动一个 ScrapLoop，按照配置的循环间隔的抓取对象的指标。</p> <p>discovery manager 通过同步通道向 scrape manager 发送每个 group 的目标更新，然后 scrape manager 会将这些更新应用到相应的 scrape 池中。</p> <h3 id="目标标签和目标重标签" tabindex="-1">目标标签和目标重标签 <a class="header-anchor" href="#目标标签和目标重标签" aria-label="Permalink to &quot;目标标签和目标重标签&quot;">​</a></h3> <p>每当 scrape manager 从 discovery manager 收到给定 scrape 池的目标更新列表， Scrape 池会为每个目标添加默认的label，然后利用
target relabeling configuration 配置生成最后要抓取的目标列表。</p> <h3 id="目标哈希和抓取时间" tabindex="-1">目标哈希和抓取时间 ？ <a class="header-anchor" href="#目标哈希和抓取时间" aria-label="Permalink to &quot;目标哈希和抓取时间 ？&quot;">​</a></h3> <p>为了在 scrape_config 的抓取间隔内以一致的插槽方式分散 scrape 池中的 scrape，每个目标都会根据其标签集和最终 scrape URL 进行计算哈希值，然后利用哈希值在该区间内选择一个确定的偏移量。</p> <h3 id="目标抓取" tabindex="-1">目标抓取 <a class="header-anchor" href="#目标抓取" aria-label="Permalink to &quot;目标抓取&quot;">​</a></h3> <p>ScrapLoop 会周期性的通过 HTTP 请求抓取目标，并通过<a href="https://prometheus.io/docs/instrumenting/exposition_formats/" target="_blank" rel="noreferrer">特定的格式</a></p> <p>报警：<a href="https://chanjarster.github.io/post/p8s-alerting-rule-logic/" target="_blank" rel="noreferrer">Prometheus告警逻辑分析 - 颇忒脱的技术博客 (chanjarster.github.io)</a></p>`,69)])])}const u=r(n,[["render",i]]);export{d as __pageData,u as default};
