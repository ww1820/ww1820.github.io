import{_ as r,o,c as a,ag as t}from"./chunks/framework.DEqXEGcv.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2 计算机/程序设计/SCSP 无锁队列.md","filePath":"2 计算机/程序设计/SCSP 无锁队列.md","lastUpdated":1770949611000}'),i={name:"2 计算机/程序设计/SCSP 无锁队列.md"};function l(n,e,d,c,u,s){return o(),a("div",null,[...e[0]||(e[0]=[t(`<p>参考资料： <a href="https://github.com/cameron314/readerwriterqueue" target="_blank" rel="noreferrer">https://github.com/cameron314/readerwriterqueue</a></p> <h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2> <p><strong>项目名称</strong>: <code>readerwriterqueue</code> <strong>作者</strong>: cameron314
<strong>类型</strong>: C++ 无锁队列库
<strong>核心库文件</strong>: <code>readerwriterqueue.h</code>， <code>atomicops.h</code> <strong>命名空间</strong>: <code>moodycamel</code></p> <p>这是一个高性能、专注于 <strong>SPSC 场景</strong>、设计精良的 C++11 无锁队列实现。它通过模板化、预先内存分配、无等待算法以及针对现代处理器的优化，旨在提供极致性能。同时提供了阻塞版本以满足不同同步需求。集成简单，文档清晰，适合需要低延迟、高吞吐量数据传输的并发编程场景。使用时需注意其线程角色固定以及阻塞 API 的生命周期约束。</p> <h3 id="核心特性与设计" tabindex="-1">核心特性与设计 <a class="header-anchor" href="#核心特性与设计" aria-label="Permalink to &quot;核心特性与设计&quot;">​</a></h3> <ol><li><strong>单生产者单消费者 (SPSC)</strong>： 专为两个固定角色的线程（一个生产，一个消费）设计的高性能场景。</li> <li><strong>无锁 (Lock-Free)</strong>： 避免使用互斥锁，通过原子操作实现线程安全，减少上下文切换和竞争开销。</li> <li><strong>完全通用模板</strong>： 像 <code>std::queue</code> 一样，可容纳任意类型，内部管理内存。</li> <li><strong>预先分配连续内存</strong>： 提升缓存效率。支持初始容量设置 (<code>ReaderWriterQueue&lt;int&gt; q(100)</code>)。</li> <li><strong>动态扩容</strong>： <code>enqueue</code> 方法在队列满时可自动扩容。</li> <li><strong>非分配入队</strong>： <code>try_enqueue</code> 保证在初始容量内不进行内存分配，适合实时性要求高的场景。</li> <li><strong>原地构造</strong>： 支持 <code>try_emplace</code>/<code>emplace</code>，避免不必要的拷贝或移动。</li> <li><strong>完全无等待 (Wait-Free)</strong>： 每个入队/出队操作都有确定性的、有限的步骤完成（O(1)），无忙等循环。</li> <li><strong>高效内存屏障</strong>： 在 x86 等强内存模型架构上，编译为高效指令（或空操作）。</li> <li><strong>窥视功能</strong>: <code>peek()</code> 允许消费者查看队首元素而不出队。</li></ol> <h3 id="提供的队列类型" tabindex="-1">提供的队列类型 <a class="header-anchor" href="#提供的队列类型" aria-label="Permalink to &quot;提供的队列类型&quot;">​</a></h3> <ol><li><strong><code>ReaderWriterQueue&lt;T&gt;</code></strong>： 基础的 SPSC 无锁队列。</li> <li><strong><code>BlockingReaderWriterQueue&lt;T&gt;</code></strong>： 阻塞版本，增加了 <code>wait_dequeue</code> 和 <code>wait_dequeue_timed</code> 方法，消费者在队列为空时可阻塞等待。</li> <li><strong><code>BlockingReaderWriterCircularBuffer&lt;T&gt;</code></strong>： 固定容量的阻塞环形缓冲区，同时提供 <code>wait_enqueue</code> 和 <code>wait_dequeue</code>，使得生产者和消费者在队列满/空时都可阻塞。</li></ol> <h3 id="使用要点" tabindex="-1">使用要点 <a class="header-anchor" href="#使用要点" aria-label="Permalink to &quot;使用要点&quot;">​</a></h3> <ul><li><strong>编译器要求</strong>: C++11 及以上。GCC &gt;= 4.7， MSVC &gt;= 2010。</li> <li><strong>基本API</strong>:
<ul><li>非阻塞: <code>enqueue</code>, <code>try_enqueue</code>, <code>try_dequeue</code>, <code>peek</code></li> <li>阻塞: <code>wait_dequeue</code>, <code>wait_dequeue_timed</code> (仅阻塞版本)</li></ul></li> <li><strong>内存与生命周期警告</strong>:
<ul><li>使用 <code>wait_dequeue</code> 时必须确保队列最终会有新元素，或者队列对象本身不会被提前销毁，否则会导致未定义行为。</li></ul></li> <li><strong>平台要求</strong>： 依赖对齐整数/指针访问的原子性。适用于所有现代主流架构（x86, ARM, PowerPC）。未在弱内存模型（如 DEC Alpha）上测试。</li></ul> <h3 id="集成方式" tabindex="-1">集成方式 <a class="header-anchor" href="#集成方式" aria-label="Permalink to &quot;集成方式&quot;">​</a></h3> <ol><li><strong>直接包含头文件</strong>： 最简单，将 <code>.h</code> 文件放入项目。</li> <li><strong>CMake FetchContent</strong>： 现代 CMake 项目推荐方式，可自动下载和管理依赖。</li> <li><strong>系统安装</strong>： 通过 CMake 安装到系统目录，然后像标准库一样 <code>#include &lt;readerwriterqueue/readerwriterqueue.h&gt;</code>。</li></ol> <h2 id="项目结构" tabindex="-1">项目结构 <a class="header-anchor" href="#项目结构" aria-label="Permalink to &quot;项目结构&quot;">​</a></h2> <p>根据文档内容，该项目包含以下主要功能模块：</p> <h3 id="核心队列模块" tabindex="-1">核心队列模块 <a class="header-anchor" href="#核心队列模块" aria-label="Permalink to &quot;核心队列模块&quot;">​</a></h3> <h4 id="_1-readerwriterqueue-基础-spsc-队列" tabindex="-1">1. <strong>ReaderWriterQueue</strong>（基础 SPSC 队列） <a class="header-anchor" href="#_1-readerwriterqueue-基础-spsc-队列" aria-label="Permalink to &quot;1. **ReaderWriterQueue**（基础 SPSC 队列）&quot;">​</a></h4> <ul><li><strong>核心功能</strong>：单生产者、单消费者的无锁队列</li> <li><strong>特性</strong>：
<ul><li>完全无锁且等待无关</li> <li>内存预分配，支持固定容量</li> <li>提供 <code>try_enqueue</code>/<code>try_dequeue</code> 非阻塞方法</li> <li>提供 <code>enqueue</code>/<code>dequeue</code> 可能动态扩容的方法</li> <li>支持 C++11 移动语义</li> <li>提供 <code>peek()</code> 方法查看队首元素</li></ul></li></ul> <h4 id="_2-blockingreaderwriterqueue-阻塞队列" tabindex="-1">2. <strong>BlockingReaderWriterQueue</strong>（阻塞队列） <a class="header-anchor" href="#_2-blockingreaderwriterqueue-阻塞队列" aria-label="Permalink to &quot;2. **BlockingReaderWriterQueue**（阻塞队列）&quot;">​</a></h4> <ul><li><strong>核心功能</strong>：在基础队列上增加阻塞功能</li> <li><strong>特性</strong>：
<ul><li>继承基础队列的所有特性</li> <li>新增 <code>wait_dequeue()</code> 方法：完全阻塞等待，直到有元素可出队</li> <li>新增 <code>wait_dequeue_timed()</code> 方法：支持超时的阻塞等待</li> <li><strong>注意</strong>：队列销毁时不能有线程在等待</li></ul></li></ul> <h4 id="_3-blockingreaderwritercircularbuffer-阻塞环形缓冲区" tabindex="-1">3. <strong>BlockingReaderWriterCircularBuffer</strong>（阻塞环形缓冲区） <a class="header-anchor" href="#_3-blockingreaderwritercircularbuffer-阻塞环形缓冲区" aria-label="Permalink to &quot;3. **BlockingReaderWriterCircularBuffer**（阻塞环形缓冲区）&quot;">​</a></h4> <ul><li><strong>核心功能</strong>：固定容量的阻塞环形缓冲区</li> <li><strong>特性</strong>：
<ul><li>固定容量，不会动态扩容</li> <li>支持阻塞入队和出队</li> <li>新增 <code>wait_enqueue()</code>：阻塞等待直到有空槽位</li> <li>新增 <code>wait_enqueue_timed()</code>：带超时的阻塞入队</li> <li>同样支持 peek() 和 try_pop() 操作</li></ul></li></ul> <h3 id="支持模块" tabindex="-1">支持模块 <a class="header-anchor" href="#支持模块" aria-label="Permalink to &quot;支持模块&quot;">​</a></h3> <h4 id="_4-原子操作抽象层-atomicops-h" tabindex="-1">4. <strong>原子操作抽象层</strong>（atomicops.h） <a class="header-anchor" href="#_4-原子操作抽象层-atomicops-h" aria-label="Permalink to &quot;4. **原子操作抽象层**（atomicops.h）&quot;">​</a></h4> <ul><li><strong>功能</strong>：平台特定的原子操作和内存屏障抽象</li> <li><strong>支持平台</strong>：
<ul><li>GCC/Clang 的 <code>__atomic_thread_fence</code></li> <li>MSVC 的 <code>_ReadWriteBarrier</code></li> <li>ICC 的内置函数</li></ul></li> <li><strong>目的</strong>：确保跨编译器的内存顺序一致性</li></ul> <h4 id="_5-构建与集成模块" tabindex="-1">5. <strong>构建与集成模块</strong> <a class="header-anchor" href="#_5-构建与集成模块" aria-label="Permalink to &quot;5. **构建与集成模块**&quot;">​</a></h4> <ul><li><strong>CMake 支持</strong>：提供现代 CMake 集成方式</li> <li><strong>两种使用模式</strong>：
<ul><li>直接包含头文件（最简单）</li> <li>通过 CMake 的 FetchContent 或系统安装</li></ul></li></ul> <h3 id="辅助模块" tabindex="-1">辅助模块 <a class="header-anchor" href="#辅助模块" aria-label="Permalink to &quot;辅助模块&quot;">​</a></h3> <h4 id="_6-测试套件-tests-目录" tabindex="-1">6. <strong>测试套件</strong>（tests 目录） <a class="header-anchor" href="#_6-测试套件-tests-目录" aria-label="Permalink to &quot;6. **测试套件**（tests 目录）&quot;">​</a></h4> <ul><li>包含各种使用场景的测试</li> <li>确保队列在不同条件下的正确性</li></ul> <h4 id="_7-性能基准测试-benchmarks-目录" tabindex="-1">7. <strong>性能基准测试</strong>（benchmarks 目录） <a class="header-anchor" href="#_7-性能基准测试-benchmarks-目录" aria-label="Permalink to &quot;7. **性能基准测试**（benchmarks 目录）&quot;">​</a></h4> <ul><li>提供性能对比测试</li> <li>帮助用户评估队列在不同场景下的性能表现</li></ul> <h2 id="源码阅读" tabindex="-1">源码阅读 <a class="header-anchor" href="#源码阅读" aria-label="Permalink to &quot;源码阅读&quot;">​</a></h2> <h3 id="atomicops-h" tabindex="-1">atomicops.h <a class="header-anchor" href="#atomicops-h" aria-label="Permalink to &quot;atomicops.h&quot;">​</a></h3> <p><code>atomicops.h</code> 是一个跨平台的原子操作和同步原语实现库。</p> <h3 id="readerwriterqueue" tabindex="-1">ReaderWriterQueue <a class="header-anchor" href="#readerwriterqueue" aria-label="Permalink to &quot;ReaderWriterQueue&quot;">​</a></h3> <h3 id="blockingreaderwriterqueue" tabindex="-1">BlockingReaderWriterQueue <a class="header-anchor" href="#blockingreaderwriterqueue" aria-label="Permalink to &quot;BlockingReaderWriterQueue&quot;">​</a></h3> <h3 id="blockingreaderwritercircularbuffer" tabindex="-1">BlockingReaderWriterCircularBuffer <a class="header-anchor" href="#blockingreaderwritercircularbuffer" aria-label="Permalink to &quot;BlockingReaderWriterCircularBuffer&quot;">​</a></h3>`,73)])])}const q=r(i,[["render",l]]);export{g as __pageData,q as default};
