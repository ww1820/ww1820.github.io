import{_ as i,o as e,c as l,ag as a}from"./chunks/framework.DEqXEGcv.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2 计算机/开发框架/ROS2/02-rclpp.md","filePath":"2 计算机/开发框架/ROS2/02-rclpp.md","lastUpdated":1770889489000}'),s={name:"2 计算机/开发框架/ROS2/02-rclpp.md"};function p(r,t,n,d,o,h){return e(),l("div",null,[...t[0]||(t[0]=[a(`<p><a href="https://deepwiki.com/ros2/rclcpp" target="_blank" rel="noreferrer">ros2/rclcpp | DeepWiki</a></p> <h2 id="通讯机制对比" tabindex="-1">通讯机制对比 <a class="header-anchor" href="#通讯机制对比" aria-label="Permalink to &quot;通讯机制对比&quot;">​</a></h2> <table tabindex="0"><thead><tr><th>特性</th> <th>ROS 2</th> <th>dc-zmq</th> <th>dc-iox</th></tr></thead> <tbody><tr><td>服务发现</td> <td>DDS 实现</td> <td>datacenter NameServer</td> <td>iox2://discovery/services/</td></tr> <tr><td>Qos</td> <td>丰富的QoS策略</td> <td>基本可靠性保证</td> <td>需要手动实现</td></tr> <tr><td>接口定义</td> <td>.msg 自动序列化</td> <td>.proto 手动序列化</td> <td>固定结构体</td></tr> <tr><td>中间件</td> <td>可插拔的中间件实现</td> <td>zmq</td> <td>iceorxy</td></tr></tbody></table> <h5 id="服务发现" tabindex="-1">服务发现 <a class="header-anchor" href="#服务发现" aria-label="Permalink to &quot;服务发现&quot;">​</a></h5> <p>通信中间件负责维护⼀个关于⽹络上所有活动节点、话题、服务和动作的动态⽬录。
当节点注册了发布者或订阅者后，通信中间件会⼴播这些信息，以便其他节点能够发现它们。
⼀旦⼀个订阅者注册，通信中间件会查找与之匹配的发布者。
匹配基于<strong>话题名称和消息类型</strong>，以及任何附加的QoS策略。
如果找到匹配项，中间件将<strong>建⽴⼀个直接的连接</strong>，允许发布者和订阅者之间直接通信，⽽⽆需通过中⼼节点。</p> <h5 id="qos" tabindex="-1">Qos <a class="header-anchor" href="#qos" aria-label="Permalink to &quot;Qos&quot;">​</a></h5> <p>ROS 2 当前的基本QoS配置文件包括以下策略设置：</p> <ul><li>History (历史):
<ul><li>Keep last (仅保留最新): 仅存储最多N个样本，可通过队列深度选项进行配置。</li> <li>Keep all (全部保留): 存储所有样本，受底层中间件的资源限制配置的影响。</li></ul></li> <li>Depth (深度):
<ul><li>Queue size (队列大小): 仅在&quot;history&quot;策略设置为&quot;keep last&quot;时生效。</li></ul></li> <li>Reliability (可靠性):
<ul><li>Best effort (尽力而为): 尝试传递样本，但如果网络不稳定可能会丢失。</li> <li>Reliable (可靠传递): 保证样本被传递，可能会多次重试。</li></ul></li> <li>Durability (持久性):
<ul><li>Transient local (瞬态本地): 发布者负责为&quot;后续加入&quot;的订阅保留样本。</li> <li>Volatile (易失性): 不尝试保留样本。</li></ul></li> <li>Deadline (截止时间):
<ul><li>Duration (持续时间): 期望的两个连续消息发布到主题之间的最长时间。</li></ul></li> <li>Lifespan (寿命):
<ul><li>Duration (持续时间): 发布和接收消息之间的最长时间，而不会被视为陈旧或过期（过期消息会被悄悄丢弃，实际上永远不会被接收）。</li></ul></li> <li>Liveliness (活跃度):
<ul><li>Automatic (自动): 当节点的任何一个发布者发布消息时，系统将考虑所有发布者仍然存活另一个&quot;租约持续时间&quot;。</li> <li>Manual by topic (按主题手动): 如果发布者通过调用发布者API手动声明自己仍然存活，系统将考虑发布者仍然存活另一个&quot;租约持续时间&quot;。</li></ul></li> <li>Lease Duration (租约持续时间):
<ul><li>Duration (持续时间): 发布者在系统认为其失去活跃性之前必须指示自己仍然存活的最长时间段（失去活跃性可能是故障的指示）。</li></ul></li></ul> <h2 id="rclcpp-node-interface" tabindex="-1">rclcpp node_interface <a class="header-anchor" href="#rclcpp-node-interface" aria-label="Permalink to &quot;rclcpp node_interface&quot;">​</a></h2> <h3 id="node-节点架构" tabindex="-1">node 节点架构 <a class="header-anchor" href="#node-节点架构" aria-label="Permalink to &quot;node 节点架构&quot;">​</a></h3> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20251111134044.png" alt="image.png" loading="lazy"></p> <p>rclcpp 中的 Node 类采用模块化架构，将功能委托给专门的接口。这种设计提高了代码组织性，并实现了更好的关注点分离。每个接口处理 Node 功能的特定方面：</p> <table tabindex="0"><thead><tr><th>接口</th> <th>功能</th></tr></thead> <tbody><tr><td>NodeBaseInterface</td> <td>核心功能（名称、命名空间等）</td></tr> <tr><td>NodeGraphInterface</td> <td>与 ROS 图交互（发现）</td></tr> <tr><td>NodeParametersInterface</td> <td>参数管理</td></tr> <tr><td>NodeTopicsInterface</td> <td>发布/订阅创建</td></tr> <tr><td>NodeServicesInterface</td> <td>服务/客户端创建</td></tr> <tr><td>NodeTimersInterface</td> <td>定时器创建和管理</td></tr></tbody></table> <h3 id="常用节点方法" tabindex="-1">常用节点方法 <a class="header-anchor" href="#常用节点方法" aria-label="Permalink to &quot;常用节点方法&quot;">​</a></h3> <table tabindex="0"><thead><tr><th>Method</th> <th>目的</th></tr></thead> <tbody><tr><td><code>get_name()</code></td> <td>获取节点名称</td></tr> <tr><td><code>get_namespace()</code></td> <td>获取节点命名空间</td></tr> <tr><td><code>get_fully_qualified_name()</code></td> <td>获取带命名空间的名称</td></tr> <tr><td><code>get_logger()</code></td> <td>获取日志实例</td></tr> <tr><td><code>create_callback_group()</code></td> <td>创建回调组</td></tr> <tr><td><code>create_publisher()</code></td> <td>创建主题发布者</td></tr> <tr><td><code>create_subscription()</code></td> <td>创建主题订阅者</td></tr> <tr><td><code>create_service()</code></td> <td>创建服务</td></tr> <tr><td><code>create_client()</code></td> <td>创建服务客户端</td></tr> <tr><td><code>create_wall_timer()</code></td> <td>创建系统时间定时器</td></tr> <tr><td><code>create_timer()</code></td> <td>创建 ROS 时间计时器</td></tr> <tr><td><code>declare_parameter()</code></td> <td>声明节点参数</td></tr> <tr><td><code>get_parameter()</code></td> <td>获取参数值</td></tr> <tr><td><code>set_parameter()</code></td> <td>设置参数值</td></tr></tbody></table> <h3 id="ros-图交互" tabindex="-1">ROS 图交互 <a class="header-anchor" href="#ros-图交互" aria-label="Permalink to &quot;ROS 图交互&quot;">​</a></h3> <p>节点参与 ROS 图，这是一个 ROS 要素的分布式网络。NodeGraphInterface 提供了发现和交互此图的方法。</p> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取全部主题</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> topics_and_types </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_topic_names_and_types</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 统计指定 topic 上的发布者数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> publishers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">count_publishers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;topic_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 统计指定 topic 上的订阅者数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subscribers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">count_subscribers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;topic_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>与上下文相关联的 GraphListener 监视图的变化，并在变化发生时通知节点，从而实现动态发现。</p> <h2 id="rclcpp-接口分类" tabindex="-1">rclcpp 接口分类 <a class="header-anchor" href="#rclcpp-接口分类" aria-label="Permalink to &quot;rclcpp 接口分类&quot;">​</a></h2> <ul><li>入口与聚合
<ul><li>rclcpp.hpp — 便捷包含，汇总常用 API（Node、executors、time、参数、waitable 等）。</li></ul></li> <li>节点与上下文
<ul><li>node.hpp — rclcpp::Node（节点的主要接口：创建 publisher/subscription/service/client/timer、参数、logger 等）。</li> <li>context.hpp、default_context.hpp — rclcpp::Context（跨节点共享的上下文）。</li></ul></li> <li>发布 / 订阅
<ul><li>publisher.hpp、publisher_base.hpp、publisher_options.hpp</li> <li>subscription.hpp、subscription_base.hpp、subscription_options.hpp</li> <li>通用/动态类型：
<ul><li>generic_publisher.hpp</li> <li>generic_subscription.hpp</li> <li>serialized_message.hpp</li> <li>loaned_message.hpp</li></ul></li></ul></li> <li>服务 / 客户端
<ul><li>service.hpp</li> <li>client.hpp</li> <li>创建辅助：create_service.hpp、create_client.hpp</li></ul></li> <li>Timer / Rate / Executor / 回调执行
<ul><li>timer.hpp、create_timer.hpp</li> <li>rate.hpp</li> <li>Executors:</li> <li>executor.hpp</li> <li>executors.hpp</li> <li>single_threaded_executor.hpp</li> <li>multi_threaded_executor.hpp</li> <li>static_single_threaded_executor.hpp</li> <li>CallbackGroups: callback_group.hpp</li></ul></li> <li>参数（Parameters）
<ul><li>parameter.hpp、parameter_value.hpp</li> <li>参数客户端/服务：parameter_client.hpp、parameter_service.hpp</li> <li>工具：parameter_event_handler.hpp、parameter_events_filter.hpp</li></ul></li> <li>Graph 与事件
<ul><li>graph_listener.hpp</li> <li>Graph 接口：node_graph.hpp / node_graph_interface.hpp</li> <li>事件机制：event.hpp、guard_condition.hpp</li></ul></li> <li>Time / Duration / Clock
<ul><li>time.hpp、clock.hpp、duration.hpp</li></ul></li> <li>等待 / WaitSets / Waitables
<ul><li>wait_set.hpp、waitable.hpp、wait_result.hpp</li> <li>Wait set 策略实现位于 wait_set_policies/*</li></ul></li> <li>QOS / 统计 / 回调相关
<ul><li>qos.hpp、qos_event.hpp</li> <li>topic statistics：subscription_topic_statistics.hpp</li></ul></li> <li>内部/工具/内存策略/allocator
<ul><li>内存与策略：memory_strategies.hpp、memory_strategy.hpp、message_memory_strategy.hpp、rclcpp/strategies/*</li> <li>Allocator 支持：allocator_common.hpp、allocator_deleter.hpp</li></ul></li> <li>Exceptions / Visibility / Macros / Utilities
<ul><li>exceptions.hpp、exceptions.hpp</li> <li>visibility_control.hpp、macros.hpp</li> <li>utilities.hpp、function_traits.hpp、typesupport_helpers.hpp</li></ul></li> <li>实验性 / intra-process
<ul><li>rclcpp/experimental/*：intra_process_manager, buffers, subscription_intra_process 等（用于进程内优化）。</li></ul></li> <li>Node interfaces（模块化 node 功能）
<ul><li>node_interfaces 下的多个头（node_topics.hpp、node_services.hpp、node_parameters.hpp、node_timers.hpp 等）把 Node 拆成小接口，便于测试/扩展。</li></ul></li></ul>`,40)])])}const _=i(s,[["render",p]]);export{u as __pageData,_ as default};
