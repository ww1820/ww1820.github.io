import{_ as i,o as t,c as r,ag as n}from"./chunks/framework.DEqXEGcv.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"1 笔记/DDS 整理/如何理解DDS中的 Domain Participant 概念.md","filePath":"1 笔记/DDS 整理/如何理解DDS中的 Domain Participant 概念.md","lastUpdated":1770889489000}'),o={name:"1 笔记/DDS 整理/如何理解DDS中的 Domain Participant 概念.md"};function e(l,a,p,c,s,d){return t(),r("div",null,[...a[0]||(a[0]=[n(`<p>在 DDS（Data Distribution Service）里，<strong>Domain Participant</strong> 可以理解为“某个进程（或应用实例）加入到一个 DDS 通信域（Domain）后的代表对象”，它是 DDS 实体体系的<strong>根节点/入口</strong>，负责把应用纳入 DDS 的发现与通信机制中。</p> <p>下面从“它是什么、解决什么问题、包含什么能力、与其他实体关系、工程上怎么用”几个角度理解。</p> <h2 id="_1-domain-与-domainparticipant-先分清-域-和-参与者" tabindex="-1">1) Domain 与 DomainParticipant：先分清“域”和“参与者” <a class="header-anchor" href="#_1-domain-与-domainparticipant-先分清-域-和-参与者" aria-label="Permalink to &quot;1) Domain 与 DomainParticipant：先分清“域”和“参与者”&quot;">​</a></h2> <ul><li><strong>Domain（域）</strong>：一个逻辑隔离的通信空间，用 <code>domain_id</code> 标识。不同 domain 之间默认<strong>互不发现、互不通信</strong>（类似“不同的广播域/不同的虚拟网络”）。</li> <li><strong>DomainParticipant（域参与者）</strong>：应用在某个 <code>domain_id</code> 中的“身份/节点”。只要创建了 participant，就相当于这个进程（或进程内某个模块）<strong>加入了该域</strong>，开始参与：
<ul><li>发现（Discovery）</li> <li>匹配（根据 Topic + QoS）</li> <li>数据收发（通过其下属的 Publisher/Subscriber/DataWriter/DataReader）</li></ul></li></ul> <p>一句话：<strong>Domain 是房间号，DomainParticipant 是进入房间的“人”。</strong></p> <h2 id="_2-domainparticipant-解决的核心问题" tabindex="-1">2) DomainParticipant 解决的核心问题 <a class="header-anchor" href="#_2-domainparticipant-解决的核心问题" aria-label="Permalink to &quot;2) DomainParticipant 解决的核心问题&quot;">​</a></h2> <h3 id="a-我是谁、我在哪个域里" tabindex="-1">(a) “我是谁、我在哪个域里” <a class="header-anchor" href="#a-我是谁、我在哪个域里" aria-label="Permalink to &quot;(a) “我是谁、我在哪个域里”&quot;">​</a></h3> <p>Participant 绑定到一个 <code>domain_id</code>，并携带一些本地信息（实现相关），让其他参与者能发现你、与你匹配。</p> <h3 id="b-发现与资源管理的边界" tabindex="-1">(b) 发现与资源管理的边界 <a class="header-anchor" href="#b-发现与资源管理的边界" aria-label="Permalink to &quot;(b) 发现与资源管理的边界&quot;">​</a></h3> <p>DDS 的自动发现通常是以 participant 为粒度进行的：</p> <ul><li>Participant 负责对外“宣告”自己、监听其他 participant</li> <li>并管理其内部创建的所有 DDS 实体（Topic、Publisher、Subscriber、DataWriter、DataReader）</li></ul> <p>你可以把它看成 <strong>DDS 的运行时上下文（runtime context）</strong>。</p> <h2 id="_3-domainparticipant-之下有哪些实体-层级关系" tabindex="-1">3) DomainParticipant 之下有哪些实体（层级关系） <a class="header-anchor" href="#_3-domainparticipant-之下有哪些实体-层级关系" aria-label="Permalink to &quot;3) DomainParticipant 之下有哪些实体（层级关系）&quot;">​</a></h2> <p>典型层级是：</p> <ul><li><strong>DomainParticipant</strong> <ul><li><strong>Topic</strong>（主题：类型 + 名称）</li> <li><strong>Publisher</strong> <ul><li><strong>DataWriter</strong>（写某个 Topic）</li></ul></li> <li><strong>Subscriber</strong> <ul><li><strong>DataReader</strong>（读某个 Topic）</li></ul></li></ul></li></ul> <p>也就是说：<strong>Writer/Reader 不能脱离 Participant 独立存在</strong>。Participant 像“工厂 + 容器”，创建并托管这些对象。</p> <h2 id="_4-participant-与-能不能通信-的关系" tabindex="-1">4) Participant 与“能不能通信”的关系 <a class="header-anchor" href="#_4-participant-与-能不能通信-的关系" aria-label="Permalink to &quot;4) Participant 与“能不能通信”的关系&quot;">​</a></h2> <p>两个应用想通过 DDS 通信，通常需要满足（简化说）：</p> <ol><li><strong>同一个 <code>domain_id</code></strong></li> <li>Topic 名称与类型兼容</li> <li>QoS 可兼容（例如可靠性、历史深度、deadline 等匹配规则）</li> <li>网络可达 + 安全策略允许（若启用 DDS Security）</li></ol> <p>其中第 1 条就是 Participant 层面的：<strong>participant 不在同一 domain，连发现都发生不了</strong>，更别提收发数据。</p> <h2 id="_5-一个进程要几个-participant" tabindex="-1">5) 一个进程要几个 Participant？ <a class="header-anchor" href="#_5-一个进程要几个-participant" aria-label="Permalink to &quot;5) 一个进程要几个 Participant？&quot;">​</a></h2> <p>工程上常见两种策略：</p> <h3 id="一个进程一个-participant-最常见" tabindex="-1">一个进程一个 Participant（最常见） <a class="header-anchor" href="#一个进程一个-participant-最常见" aria-label="Permalink to &quot;一个进程一个 Participant（最常见）&quot;">​</a></h3> <p>优点：</p> <ul><li>资源开销小（发现、内置端点、线程、socket 等通常按 participant 计）</li> <li>管理简单</li></ul> <h3 id="一个进程多个-participant-用于隔离-多域-多配置" tabindex="-1">一个进程多个 Participant（用于隔离/多域/多配置） <a class="header-anchor" href="#一个进程多个-participant-用于隔离-多域-多配置" aria-label="Permalink to &quot;一个进程多个 Participant（用于隔离/多域/多配置）&quot;">​</a></h3> <p>适用场景：</p> <ul><li>同一进程要同时加入多个 domain（不同 <code>domain_id</code>）</li> <li>需要在同一进程内做强隔离（不同的 QoS、不同安全身份、不同发现配置等，取决于实现）
代价：</li> <li>开销更高、配置更复杂（发现流量、端口/线程、内存等可能翻倍）</li></ul> <p>经验法则：<strong>除非有明确隔离需求，否则一个 participant 足够</strong>。</p> <h2 id="_6-它和-节点-进程-容器-的关系-避免误解" tabindex="-1">6) 它和“节点/进程/容器”的关系（避免误解） <a class="header-anchor" href="#_6-它和-节点-进程-容器-的关系-避免误解" aria-label="Permalink to &quot;6) 它和“节点/进程/容器”的关系（避免误解）&quot;">​</a></h2> <ul><li>Participant <strong>不是</strong> Topic、也不是 Publisher/Subscriber 的同义词</li> <li>Participant 通常对应“进程里的一个 DDS 栈实例”</li> <li>一个“应用进程”可以有多个 participant；一个 participant 下也可以有多个 publisher/subscriber、多个 writer/reader</li></ul> <p>因此它更像“DDS 通信栈的实例入口”，而不是业务概念本身。</p>`,63)])])}const h=i(o,[["render",e]]);export{u as __pageData,h as default};
