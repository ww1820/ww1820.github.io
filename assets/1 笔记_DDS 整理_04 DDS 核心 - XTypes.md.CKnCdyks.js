import{_ as i,o as D,c as e,ag as t}from"./chunks/framework.DEqXEGcv.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"1 笔记/DDS 整理/04 DDS 核心 - XTypes.md","filePath":"1 笔记/DDS 整理/04 DDS 核心 - XTypes.md","lastUpdated":1770889489000}'),a={name:"1 笔记/DDS 整理/04 DDS 核心 - XTypes.md"};function s(n,l,p,S,o,_){return D(),e("div",null,[...l[0]||(l[0]=[t(`<h4 id="为什么-dds-规范要定义这么复杂的一个类型规范" tabindex="-1">为什么 DDS 规范要定义这么复杂的一个类型规范？ <a class="header-anchor" href="#为什么-dds-规范要定义这么复杂的一个类型规范" aria-label="Permalink to &quot;为什么 DDS 规范要定义这么复杂的一个类型规范？&quot;">​</a></h4> <p>DDS 之所以在规范里要定义“类型规范（Type System / Type Representation）”，根本原因是：DDS 不只是“把字节流从 A 发到 B”，它要在<strong>分布式系统里长期、可靠、可演进地分发“数据对象”</strong>。要做到这一点，通信双方必须对“数据长什么样、如何演进、是否兼容”有一套可机器判断的共同语言，而这就需要类型规范。</p> <p>DDS 主题需要关联某个特定的数据类型，并具备以下这些能力使得 DDS 表现的像能够理解业务数据一样。</p> <ul><li>自定义类型相关的发送/接收接口，即提交给 DDS 和从 DDS 中获取的是主题关联的自定义数据结构对象。
<ul><li>优势
<ul><li>序列化/反序列化的工作从应用下沉到中间件，由中间件考虑端序/对齐/不同语言类型的转换；</li> <li>类型检查，在编译期即可检查出部分问题；</li></ul></li> <li>劣势
<ul><li>使用复杂，即便是简单的收发也需要 IDL 编译器编译支持代码；</li></ul></li></ul></li> <li>数据筛选，DDS 提供类似于数据库的实时数据存储与查询的功能，包括：
<ul><li>将主题数据按照 key 值组织，比如订阅端可以仅读取特定 key 值的数据；</li> <li>内容过滤，即订阅端可以配置只关心某个成员范围之间的值，DDS 将自动过滤不属于这个范围的主题数据；</li> <li>类型规范是不同 DDS 产品互联互通的基础</li></ul></li> <li>产品遵循相同的规范使得能够支持的数据类型互认；
<ul><li>数据样本序列化方式规范使得 A 厂家的 DDS 产品序列化的数据可以由 B 厂家的 DDS 产品反序列化还原成相同类型的样本数据；</li></ul></li></ul> <p>以数据为中心是 DDS 与其他消息中间件的一个重要的区别。DDS-XTypes 是实现以数据为中心的核心协议。DDS-XTypes 规范的主要内容参见下图，主要内容包括：</p> <ul><li>类型系统，支持的数据类型及其语法规则，更进一步的描述了类型如何演进；</li> <li>类型描述，采用何种格式来描述数据类型；</li> <li>数据序列化，采用什么方式序列化数据类型实例；</li> <li>语言绑定，如何映射为特定的开发语言；</li> <li>DDS 相关扩展，描述该规范与 DCPS 规范如何关联并扩展 DCPS 规范。</li></ul> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20260210142353630.png" alt="" loading="lazy"></p>`,13)])])}const u=i(a,[["render",s]]);export{d as __pageData,u as default};
