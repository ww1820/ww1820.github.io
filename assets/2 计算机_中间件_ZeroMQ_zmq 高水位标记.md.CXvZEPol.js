import{_ as r,o as t,c as a,ag as o}from"./chunks/framework.DEqXEGcv.js";const m=JSON.parse('{"title":"High-Water Marks","description":"","frontmatter":{},"headers":[],"relativePath":"2 计算机/中间件/ZeroMQ/zmq 高水位标记.md","filePath":"2 计算机/中间件/ZeroMQ/zmq 高水位标记.md","lastUpdated":1770949611000}'),s={name:"2 计算机/中间件/ZeroMQ/zmq 高水位标记.md"};function i(_,e,n,p,c,h){return t(),a("div",null,[...e[0]||(e[0]=[o(`<hr> <p>zmq 有关 High-Water Marks 官方文档：
<a href="https://zguide.zeromq.org/docs/chapter2/#High-Water-Marks" target="_blank" rel="noreferrer">2. Sockets and Patterns | ØMQ - The Guide (zeromq.org)</a></p> <hr> <h1 id="high-water-marks" tabindex="-1">High-Water Marks <a class="header-anchor" href="#high-water-marks" aria-label="Permalink to &quot;High-Water Marks&quot;">​</a></h1> <p>进程中高速发送消息时，流程中某处几秒钟的延迟可能会导致消息积压，从而导致服务器内存耗尽崩溃。</p> <p>ZeroMQ 使用 HWM （高水位线）来定义其内部管道的容量。每个个从套接字触发或进入套接字的连接都有自己的管道，以及用于发送和/或接收的 HWM，具体取决于套接字类型。某些套接字（PUB、PUSH）仅具有发送缓冲区。有些（SUB、PULL、REQ、REP）仅具有接收缓冲区。有些（DEALER、ROUTER、PAIR）同时具有发送和接收缓冲区。</p> <p>在 ZeroMQ v2.x 中，HWM 默认是无限的。当 publisher 数量激增时，会导致严重的问题。在 ZeroMQ v3.x 中，默认设置为1,000，也可以是考虑到消息大小和预期 subscriber 性能的其他数字。</p> <p>当套接字达到其 HWM 时，它将根据套接字类型阻塞或丢弃数据。 PUB、SUB 和 ROUTER 套接字如果达到其 HWM 将丢弃数据，而其他套接字类型将阻塞。在 <code>inproc://</code> 传输中，发送方和接收方共享相同的缓冲区，因此真正的 HWM 是双方设置的 HWM 之和。详见 <a href="https://libzmq.readthedocs.io/en/latest/zmq_socket.html" target="_blank" rel="noreferrer">zmq_socket(3) (libzmq.readthedocs.io)</a> 中不同 socket 在静默状态时的行为（Action in mute state）。</p> <p>最后，HWM 并不精确；虽然默认情况下最多可以获得 1,000 条消息，但由于 libzmq 实现其队列的方式，实际缓冲区大小可能要低得多（只有一半）。</p>`,17)])])}const l=r(s,[["render",i]]);export{m as __pageData,l as default};
