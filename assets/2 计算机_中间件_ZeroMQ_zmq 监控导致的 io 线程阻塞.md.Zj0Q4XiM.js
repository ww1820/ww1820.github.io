import{_ as o,o as a,c as i,ag as t}from"./chunks/framework.DEqXEGcv.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2 计算机/中间件/ZeroMQ/zmq 监控导致的 io 线程阻塞.md","filePath":"2 计算机/中间件/ZeroMQ/zmq 监控导致的 io 线程阻塞.md","lastUpdated":1770949611000}'),s={name:"2 计算机/中间件/ZeroMQ/zmq 监控导致的 io 线程阻塞.md"};function l(r,e,n,c,d,h){return a(),i("div",null,[...e[0]||(e[0]=[t('<h2 id="zmq-socket-monitor-监控模式未关闭导致的阻塞问题" tabindex="-1"><code>zmq_socket_monitor</code> 监控模式未关闭导致的阻塞问题 <a class="header-anchor" href="#zmq-socket-monitor-监控模式未关闭导致的阻塞问题" aria-label="Permalink to &quot;`zmq_socket_monitor` 监控模式未关闭导致的阻塞问题&quot;">​</a></h2> <h4 id="问题背景" tabindex="-1">问题背景 <a class="header-anchor" href="#问题背景" aria-label="Permalink to &quot;问题背景&quot;">​</a></h4> <p>在使用 ZeroMQ 的 <code>ZMQ_STREAM</code> 套接字并启用监控（monitor）功能时，若仅关闭用于接收监控事件的 <code>ZMQ_PAIR</code> 套接字，而不显式停止监控模式，会导致 ZeroMQ 内部后台线程永久阻塞。</p> <hr> <h4 id="错误操作流程" tabindex="-1">错误操作流程 <a class="header-anchor" href="#错误操作流程" aria-label="Permalink to &quot;错误操作流程&quot;">​</a></h4> <ol><li>创建一个 <code>ZMQ_STREAM</code> 套接字。</li> <li>调用 <code>zmq_socket_monitor()</code> 启用监控模式，并打开对应的 <code>ZMQ_PAIR</code> 套接字用于接收事件。</li> <li>将 <code>ZMQ_STREAM</code> 套接字连接到某个 TCP 服务器。</li> <li><strong>错误做法</strong>：直接关闭 <code>ZMQ_PAIR</code> 套接字，认为这足以停止监控。</li> <li>关闭 TCP 服务器。</li></ol> <hr> <h4 id="导致的问题" tabindex="-1">导致的问题 <a class="header-anchor" href="#导致的问题" aria-label="Permalink to &quot;导致的问题&quot;">​</a></h4> <ul><li>当 TCP 连接断开时，ZeroMQ 会尝试通过内部持有的 <code>ZMQ_PAIR</code> 套接字发送 <code>ZMQ_EVENT_DISCONNECTED</code> 事件。</li> <li>但由于用户已关闭该 <code>ZMQ_PAIR</code> 套接字，无人读取该事件，导致 ZeroMQ 后台线程在 <code>zmq::socket_base_t::monitor_event()</code> 中永久阻塞。</li> <li>程序无法正常退出，出现“挂死”现象。</li></ul> <hr> <h4 id="正确解决方案" tabindex="-1">正确解决方案 <a class="header-anchor" href="#正确解决方案" aria-label="Permalink to &quot;正确解决方案&quot;">​</a></h4> <p>在关闭 <code>ZMQ_PAIR</code> 套接字 <strong>之前</strong>，必须先调用：</p> <div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zmq_socket_monitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my_stream_socket, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>该调用会<strong>显式停用监控模式</strong>，释放内部资源，避免后续事件发送。</li> <li>虽然 <code>zmq_socket_monitor()</code> 支持传入 <code>NULL</code> 作为 endpoint 来停止监控，但<strong>此用法在官方文档中未被说明</strong>，属于隐藏行为。</li></ul> <hr> <h4 id="建议" tabindex="-1">建议 <a class="header-anchor" href="#建议" aria-label="Permalink to &quot;建议&quot;">​</a></h4> <ul><li>在使用 <code>zmq_socket_monitor()</code> 时，务必成对操作：启动监控 → 使用 → 显式停止监控（传 <code>NULL</code>）→ 关闭监控套接字。、</li></ul> <blockquote><p><strong>环境信息</strong>：libzmq 4.3.1，Linux<br> <strong>参考链接</strong>：<a href="https://github.com/zeromq/libzmq/issues/3575" target="_blank" rel="noreferrer">GitHub Issue #3575</a></p></blockquote> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17666305215700.png" alt="企业微信截图_17666305215700.png" loading="lazy"></p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20251225110100483.png" alt="image.png" loading="lazy"></p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20251225110505514.png" alt="image.png" loading="lazy"></p>',40)])])}const _=o(s,[["render",l]]);export{m as __pageData,_ as default};
