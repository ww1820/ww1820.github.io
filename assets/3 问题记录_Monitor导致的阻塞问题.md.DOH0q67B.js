import{_ as e,o as t,c as r,ag as c}from"./chunks/framework.DEqXEGcv.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"3 问题记录/Monitor导致的阻塞问题.md","filePath":"3 问题记录/Monitor导致的阻塞问题.md","lastUpdated":1770889489000}'),i={name:"3 问题记录/Monitor导致的阻塞问题.md"};function l(a,o,n,s,d,g){return t(),r("div",null,[...o[0]||(o[0]=[c('<h2 id="修复的-bug-及原因" tabindex="-1">修复的 Bug 及原因 <a class="header-anchor" href="#修复的-bug-及原因" aria-label="Permalink to &quot;修复的 Bug 及原因&quot;">​</a></h2> <h3 id="_1-代理线程停止时的死锁-阻塞问题" tabindex="-1">1. <strong>代理线程停止时的死锁/阻塞问题</strong> <a class="header-anchor" href="#_1-代理线程停止时的死锁-阻塞问题" aria-label="Permalink to &quot;1. **代理线程停止时的死锁/阻塞问题**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>旧代码在 <code>ServerManager::DestoryMachine()</code> 中使用<strong>共享的 <code>m_ctrl_socket</code></strong> 通过 <code>connect/disconnect</code> 方式向代理线程发送终止信号</li> <li>多线程环境下, 多个 <code>DestoryMachine</code> 调用可能同时 <code>connect</code> 到同一个 socket, 导致竞态条件</li> <li>ZMQ socket 的 <code>connect/disconnect</code> 不是线程安全的操作</li> <li>可能导致 socket 发送永久阻塞或连接错误</li></ul> <p><strong>修复方案:</strong></p> <ul><li>为<strong>每个 <code>ReqRepMachine</code> 创建独立的 <code>m_socket_ctrl_client</code></strong>, 在构造函数中初始化并连接到自己的控制通道</li> <li>设置 <code>ZMQ_SNDTIMEO = 1000ms</code>, 防止发送永久阻塞</li> <li>新增 <code>StopProxy()</code> 方法, 直接通过自己的 client socket 发送终止信号, 避免共享资源竞争</li></ul> <h3 id="_2-监控停止顺序导致的事件发送阻塞" tabindex="-1">2. <strong>监控停止顺序导致的事件发送阻塞</strong> <a class="header-anchor" href="#_2-监控停止顺序导致的事件发送阻塞" aria-label="Permalink to &quot;2. **监控停止顺序导致的事件发送阻塞**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>旧代码先调用 <code>SocketCancelMonitor()</code> 取消监控</li> <li>取消监控时 ZMQ 会向监控 socket 发送 <code>ZMQ_EVENT_MONITOR_STOPPED</code> 事件</li> <li>但如果立即关闭接收监控套接字, 可能导致事件发送阻塞，从而导致 ZMQ 内部 IO 线程阻塞</li></ul> <p><strong>修复方案:</strong></p> <ul><li>在 <code>DestoryMachine</code> 中调整顺序:<strong>先停止监控 → 再停止代理 → 最后删除对象</strong></li> <li>新增 <code>StopMonitor()</code> 方法独立处理监控停止</li> <li>注释掉 <code>Stop()</code> 中的 <code>SocketCancelMonitor()</code> 调用, 改为在 <code>DestoryMachine</code> 中统一处理</li></ul> <h3 id="_3-监控事件处理中的-uaf-use-after-free-风险" tabindex="-1">3. <strong>监控事件处理中的 UAF (Use-After-Free) 风险</strong> <a class="header-anchor" href="#_3-监控事件处理中的-uaf-use-after-free-风险" aria-label="Permalink to &quot;3. **监控事件处理中的 UAF (Use-After-Free) 风险**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>在处理 <code>ZMQ_EVENT_HANDSHAKE_SUCCEEDED</code> 等事件时, 旧代码在 switch 前就获取 <code>ser_name = dict[item.socket]</code></li> <li>如果 socket 不在 dict 中 (已被删除), 会访问到悬空引用</li></ul> <p><strong>修复方案:</strong></p> <ul><li>改为在需要时才从 dict 获取 <code>ser_name</code></li> <li><code>HANDSHAKE_SUCCEEDED</code> 事件使用 <code>dict[item.socket]</code> 直接记录日志, 不提前复制</li> <li><code>DISCONNECTED</code> 事件在使用前才赋值 <code>ser_name</code></li></ul> <h3 id="_4-监控事件未及时到达导致的资源泄漏" tabindex="-1">4. <strong>监控事件未及时到达导致的资源泄漏</strong> <a class="header-anchor" href="#_4-监控事件未及时到达导致的资源泄漏" aria-label="Permalink to &quot;4. **监控事件未及时到达导致的资源泄漏**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>旧代码在 <code>ZMQ_EVENT_MONITOR_STOPPED</code> 事件中清理监控 socket</li> <li>但注释指出: &quot;可能会收不到监控停止事件&quot;</li> <li>导致 <code>m_servers_monitor_map</code> 中的 socket 无法释放</li></ul> <p><strong>修复方案:</strong></p> <ul><li>在 <code>DestoryMachine</code> 中<strong>主动关闭并删除监控 socket</strong>, 不依赖事件</li> <li>将 <code>ZMQ_EVENT_MONITOR_STOPPED</code> 的清理逻辑注释掉, 改为在销毁时统一处理</li></ul> <h3 id="_5-createmachine-中的锁作用域问题" tabindex="-1">5. <strong>CreateMachine 中的锁作用域问题</strong> <a class="header-anchor" href="#_5-createmachine-中的锁作用域问题" aria-label="Permalink to &quot;5. **CreateMachine 中的锁作用域问题**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>旧代码在 <code>machine-&gt;Start(pg)</code> 成功后才加锁, 然后插入到 map 中</li> <li>在加锁前的间隙, 其他线程可能已经创建了同名的 machine, 导致覆盖或状态不一致</li></ul> <p><strong>修复方案:</strong></p> <ul><li>将 <code>lock_guard</code> 的作用域提前到创建 <code>machine</code> 之前</li> <li>确保整个创建和插入过程都在锁保护中, 保证原子性</li></ul> <h3 id="_6-监控-socket-配置不足" tabindex="-1">6. <strong>监控 socket 配置不足</strong> <a class="header-anchor" href="#_6-监控-socket-配置不足" aria-label="Permalink to &quot;6. **监控 socket 配置不足**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>监控 socket 没有设置超时和高水位标记</li> <li>大量事件可能导致缓冲区溢出或阻塞</li></ul> <p><strong>修复方案:</strong></p> <ul><li>添加 <code>ZMQ_LINGER = 0</code> (立即关闭, 不等待消息发送)</li> <li>添加 <code>ZMQ_RCVHWM = 100000</code> (接收高水位标记, 防止内存溢出)</li></ul> <h3 id="_7-事件计数逻辑不严谨" tabindex="-1">7. <strong>事件计数逻辑不严谨</strong> <a class="header-anchor" href="#_7-事件计数逻辑不严谨" aria-label="Permalink to &quot;7. **事件计数逻辑不严谨**&quot;">​</a></h3> <p><strong>Bug 原因:</strong></p> <ul><li>旧代码只在 <code>ser_cnt[item.socket] == 0</code> 时销毁,但实际可能出现负数 (多次 disconnect)</li></ul> <p><strong>修复方案:</strong></p> <ul><li>改为 <code>ser_cnt[item.socket] &lt;= 0</code> 判断, 更加健壮</li> <li>添加 <code>ZMQ_EVENT_HANDSHAKE_FAILED_NO_DETAIL</code> 事件处理, 增加计数正确性</li></ul> <h3 id="_8-拼写错误" tabindex="-1">8. <strong>拼写错误</strong> <a class="header-anchor" href="#_8-拼写错误" aria-label="Permalink to &quot;8. **拼写错误**&quot;">​</a></h3> <p><strong>Bug:</strong> <code>m_servers_moitor_map</code> 拼写错误<br> <strong>修复:</strong> 改为正确的 <code>m_servers_monitor_map</code></p> <hr> <h2 id="核心问题总结" tabindex="-1">核心问题总结 <a class="header-anchor" href="#核心问题总结" aria-label="Permalink to &quot;核心问题总结&quot;">​</a></h2> <p>这些 bug 的根本原因是在<strong>高并发的连接创建/销毁场景</strong>下:</p> <ol><li><strong>共享资源竞争</strong>导致死锁</li> <li><strong>生命周期管理不当</strong>导致 UAF 和资源泄漏</li> <li><strong>事件时序依赖</strong>导致阻塞</li> <li><strong>线程安全性不足</strong>导致状态不一致</li></ol> <p>修复方案通过<strong>资源独立化、操作原子化、主动清理</strong>等手段彻底解决了这些并发问题。</p>',85)])])}const h=e(i,[["render",l]]);export{u as __pageData,h as default};
