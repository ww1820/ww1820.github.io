import{_ as a,o as i,c as o,ag as t}from"./chunks/framework.DEqXEGcv.js";const m=JSON.parse('{"title":"红黑树","description":"","frontmatter":{"title":"红黑树","tags":["数据结构","红黑树"],"categories":[["算法与数据结构"]],"math":true,"abbrlink":"f89cb603","date":"2022-08-04T00:10:51.000Z"},"headers":[],"relativePath":"2 计算机/数据结构与算法/红黑树.md","filePath":"2 计算机/数据结构与算法/红黑树.md","lastUpdated":1770949611000}'),e={name:"2 计算机/数据结构与算法/红黑树.md"};function n(p,l,r,s,c,g){return i(),o("div",null,[...l[0]||(l[0]=[t(`<h1 id="红黑树的引入" tabindex="-1">红黑树的引入 <a class="header-anchor" href="#红黑树的引入" aria-label="Permalink to &quot;红黑树的引入&quot;">​</a></h1> <h2 id="二叉搜索树-bst" tabindex="-1">二叉搜索树（BST） <a class="header-anchor" href="#二叉搜索树-bst" aria-label="Permalink to &quot;二叉搜索树（BST）&quot;">​</a></h2> <p>二叉搜索树（BST）具备以下特性（规则）：</p> <ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li> <li>右子树上所有结点的值均大于或等于它的根结点的值。</li> <li>左、右子树也分别为二叉搜索树。</li></ol> <p>在BST中最大比较次数为树的高度，树的高度范围为 $[log(n), n]$。</p> <p>当树中每个结点左、右子树高度大致相同时，树高为 $\\text{log}(n)$ ，则平均查找长度与 $\\text{log}(n)$ 成正比，查找的平均时间复杂度在 $O(\\text{log}n)$ 数量级上。</p> <p>当树形结构为一个单子树时，此时树高 $n$ ，则平均查找长度为 $(n+1)/2$ ，查找的平均时间复杂度在 $O(n)$ 数量级上。</p> <p>相同序列构成的不同二叉搜索树：<a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/" target="_blank" rel="noreferrer">不同的二叉搜索树 - 力扣（LeetCode）</a></p> <h2 id="平衡二叉搜索树-avl" tabindex="-1">平衡二叉搜索树（AVL） <a class="header-anchor" href="#平衡二叉搜索树-avl" aria-label="Permalink to &quot;平衡二叉搜索树（AVL）&quot;">​</a></h2> <p>平衡二叉查找树的出现，主要是为了解决<strong>当二叉树查找树形态结构变成一个链条结构的时候，查找效率变低的问题</strong>，算法由<code>Adel&#39;son-Vel&#39;skii</code>和<code>Landis</code>发明，同时也称<code>AVL</code>树，特性（规则）如下：</p> <ol><li><p>它的左子树和右子树都是平衡二叉树；</p></li> <li><p>且它的左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。</p></li></ol> <p>AVL是严格平衡的BST（平衡因子不超过1）。查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是 $O(\\text{log}n)$ 。</p> <p>$$
balance\\  factor = height\\ of\\ left\\ subtree - height\\ of\\ right\\ subtree \\
bf = {-1, 0, 1} \\
|bf| = |hl - hr| \\le 1 \\
$$</p> <p>AVL 的旋转：</p> <ol><li>LL-imbalance：由于在左子树的左子树插入或删除而导致的不平衡，进行LL-Rotation；</li> <li>LR-imbalance：由于在左子树的右子树插入或删除而导致的不平衡，进行LR-Rotation；</li> <li>RR-imbalance：由于在右子树的右子树插入或删除而导致的不平衡，进行RR-Rotation；</li> <li>RL-imbalance：由于在右子树的左子树插入或删除而导致的不平衡，进行RL-Rotation。</li></ol> <p>在插入、删除树节点的时候，<strong>AVL树会自动进行调整</strong>。也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。AVL在每次插入节点时对树进行检查和调整，AVL的旋转每次只涉及以imbalance节点为根节点的3个节点（如下图）：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031408586.png" alt="AVL树的旋转-插入42" loading="lazy"></p> <p>以 LL-Rotation 和 LR-Rotation 为例（假设图中节点A为第一个 $|bf| \\neq 1$ 的节点）：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031412866.png" alt="LL-Rotation" loading="lazy"></p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031413467.png" alt="LR-Rotation" loading="lazy"></p> <p>给定节点数为 $n$ 的AVL树，最大高度为 $\\text{log}(2n)$ ，而不是 $n$。</p> <p>平衡二叉搜索树解决二叉搜索树的问题，保证了不会成为线性的链表。
左结点小于根节点，右结点大于根节点，并且还规定了左子树和右子树的高度差不得超过1。</p> <p>但其仍然存在问题：</p> <ol><li>由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。</li> <li>每一个节点只能存放一个元素，每个节点只有两个子节点，所以查找时，需要多次磁盘IO（如果数据存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页。）</li></ol> <h2 id="b-树" tabindex="-1">B 树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B 树&quot;">​</a></h2> <p>视频：<a href="https://www.youtube.com/watch?v=aZjYr87r1b8" target="_blank" rel="noreferrer">10.2 B Trees and B+ Trees. How they are useful in Databases - YouTube</a></p> <p>B 树的基本思想：多级索引</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031643643.png" alt="多级索引" loading="lazy"></p> <p>一个m阶的B树的规则：</p> <ol><li>根结点至少有两个子树（1个索引）；</li> <li>每个中间节点都包含 $k-1$ 个元素和 $k$ 个孩子，其中 $m/2 \\le k \\le m$  ；</li> <li>每一个叶子节点都包含 $k-1$ 个元素，其中 $m/2 \\le k \\le m$  ；</li> <li>所有的叶子结点都位于同一层；</li> <li>每个节点中的元素从小到大排列，节点当中 $k-1$ 个元素正好是 $k$ 个孩子包含的元素的值域分划。</li></ol> <p>4阶B树，例子：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031545671.png" alt="B树的构建" loading="lazy"></p> <h2 id="_2-3-4-树" tabindex="-1">2-3-4 树 <a class="header-anchor" href="#_2-3-4-树" aria-label="Permalink to &quot;2-3-4 树&quot;">​</a></h2> <p>2-3-4 树 是 四阶 B树，它是一种多路查找树，其结构有以下限制：</p> <ol><li>所有叶子节点具有相同的深度；</li> <li>节点只能是2-节点、3-节点和4-节点之一：
<ul><li>2-节点：包含1个元素的节点，有2个子树；</li> <li>3-节点：包含2个元素的节点，有3个子树；</li> <li>4-节点：包含3个元素的节点，有4个子树。</li></ul></li> <li>所有节点必须至少包含一个元素；</li> <li>元素始终保持排序顺序 ，整体上保持二叉搜索树的性质，即父节点的值大于左子树所有节点，小于右子树所有节点；</li> <li>节点有多个元素时，每个元素必须大于它左边的和左子树中的元素。</li></ol> <p>例：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031651195.png" alt="2-3-4树" loading="lazy"></p> <p>2-3-4树的实现在一些编程语言中较为困难，一般使用其等同的红黑树。</p> <h1 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-label="Permalink to &quot;红黑树&quot;">​</a></h1> <p>视频：<a href="https://www.bilibili.com/video/BV1j44y1q7k8?p=1&amp;vd_source=88ba307806f3a95297a7d08a098d6a4b" target="_blank" rel="noreferrer">【完整版】最全最新红黑树讲解，数组、链表、二叉树、AVL树、红黑树哔哩哔哩_bilibili</a></p> <h2 id="_2-3-4-树和红黑树的等价关系" tabindex="-1">2-3-4 树和红黑树的等价关系 <a class="header-anchor" href="#_2-3-4-树和红黑树的等价关系" aria-label="Permalink to &quot;2-3-4 树和红黑树的等价关系&quot;">​</a></h2> <p>2-3-4 树和红黑树的等价关系：</p> <ol><li>2-节点对应RB-Tree黑节点；</li></ol> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712340.png" alt="2-节点" loading="lazy"></p> <ol start="2"><li>3-节点对应RB-Tree上黑下红（分为左倾和右倾两种）；</li></ol> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712317.png" alt="3-节点" loading="lazy"></p> <ol start="3"><li>4-节点对应RB-Tree上黑下红。</li></ol> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031713313.png" alt="4-节点" loading="lazy"></p> <p>2-3-4 树到红黑树的转换：</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031756841.png" alt="2-3-4 树到红黑树（左倾）" loading="lazy"></p> <p>平衡二叉查找树通过严格平衡策略，以牺牲建立查找结构的代价换来了稳定的查找时间复杂度。但是相对来说，在删除方面，时间复杂度稍大。而红黑树不严格控制左、右子树高度或节点数之差小于等于1。</p> <h2 id="红黑树的特点" tabindex="-1">红黑树的特点 <a class="header-anchor" href="#红黑树的特点" aria-label="Permalink to &quot;红黑树的特点&quot;">​</a></h2> <p>红黑树是自平衡（不严格限制）的二叉搜索树， <strong>红黑树的5条规则：</strong></p> <ol><li>节点要么是黑色要么是红色；</li> <li>根节点是黑色；</li> <li>每个叶子节点都是黑色的空节点（NIL节点）；</li> <li>每个红色节点的两个子节点都是黑色（也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点）；</li> <li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍，因而，红黑树是相对的接近平衡的二叉树，但是相比平衡二叉树而言，尤其是删除的时间复杂度，有所降低）。</li></ol> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031616562.png" alt="红黑树" loading="lazy"></p> <p><strong>分析：</strong></p> <ol><li>第2条特性：从 2-3-4 树到红黑树的转换中，根节点要么是2-节点（黑色），要么是3-节点或4-节点分裂出的（上黑）；</li> <li>第5条特性：从 2-3-4 树到红黑树的转换中，可以看出2-3-4 树的每个节点中有且仅有一个黑色元素，由于B树中所有的叶子结点都位于同一层，所以从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（2-3-4树的高度+1）。</li></ol> <p>红黑树在查找方面和AVL树操作几乎相同。牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。任何不平衡都会在三次旋转之内解决。
确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证 $O(\\text{log}n)$ 。</p> <p>红黑树的通过旋转和染色来自平衡。</p> <h2 id="红黑树的查找" tabindex="-1">红黑树的查找 <a class="header-anchor" href="#红黑树的查找" aria-label="Permalink to &quot;红黑树的查找&quot;">​</a></h2> <p>红黑树的查找与二叉树搜索树的查找一样。</p> <h2 id="红黑树的插入" tabindex="-1">红黑树的插入 <a class="header-anchor" href="#红黑树的插入" aria-label="Permalink to &quot;红黑树的插入&quot;">​</a></h2> <p>参考资料：<a href="https://zhuanlan.zhihu.com/p/166319823" target="_blank" rel="noreferrer">红黑树的原理 (插入+ 删除) 案例分析 - 知乎 (zhihu.com)</a></p> <p>向红黑树中插入新的结点。具体做法是：</p> <ol><li>将新结点的 color 赋为红色，然后以二叉排序树的插入方法插入到红黑树中去。之所以将新插入的结点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。</li> <li>通过颜色调换和树旋转来调整可能会出现两个连续红色节点的冲突。</li></ol> <p>插入不同的情况：</p> <ol><li>插入根节点；</li> <li>插入节点的父节点为黑色；</li> <li>插入节点的父节点为红色，叔节点也为红色；</li> <li>插入节点的父节点是红色，叔节点是黑色：
<ol><li>左左插入</li> <li>左右插入</li> <li>右右插入</li> <li>右左插入</li></ol></li></ol> <p>具体操作：</p> <ol><li><p>插入根结点：直接染黑。</p></li> <li><p>插入节点的父节点为黑色，没有出现两个连续红色节点的冲突，不需要调整。</p></li> <li><p>插入节点的父节点为红色，叔节点也为红色，不需要旋转，直接染色，注意递归向上调整。</p> <p>分析：插入N之前，N所在的位置必为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点必为 NIL</strong>。插入新节点之后树仍是平衡的，所以不需要旋转。</p></li></ol> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032144818.png" alt="case 3" loading="lazy"></p> <ol start="4"><li><p>插入节点的父节点是红色，叔节点是黑色:</p> <ol><li><p>左左插入，左旋</p> <p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LL-imbalance，需要进行LL-Rotation。</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032202879.png" alt="case 4-1" loading="lazy"></p></li> <li><p>左右插入</p> <p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LR-imbalance，需要进行LR-Rotation。</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032207490.png" alt="case4-2" loading="lazy"></p></li> <li><p>右右插入</p> <p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RR-imbalance，需要进行RR-Rotation。</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032213353.png" alt="case4-3" loading="lazy"></p></li> <li><p>右左插入</p> <p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RL-imbalance，需要进行RL-Rotation。</p> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032318044.png" alt="case4-4" loading="lazy"></p></li></ol></li></ol> <p>总结：根据平衡二叉树正常插入节点之后根据平衡判断是否需要旋转，若不需要旋转，则将 <code>Parent</code> 和 <code>Uncle</code> 染黑，<code>GrandParent</code> 染红，再递归向上调整；若不平衡，则根据情况进行旋转，旋转之后上黑（新的 <code>GrandParent</code> ）下红染色。</p> <h2 id="红黑树的删除" tabindex="-1">红黑树的删除 <a class="header-anchor" href="#红黑树的删除" aria-label="Permalink to &quot;红黑树的删除&quot;">​</a></h2> <p>参考：<a href="https://www.bilibili.com/video/BV1KA41187v6?vd_source=88ba307806f3a95297a7d08a098d6a4b" target="_blank" rel="noreferrer">红黑树删除_bilibili</a></p> <p>删除不同的情况：</p> <ol><li>删除叶节点，且叶节点为红色，无需调整；</li> <li>删除叶节点，叶节点为黑色，需要调整；</li> <li>删除节点非叶节点，若该节点只有一个子节点，则用该子节点替代删除节点；若该节点有两个子节点，则将要删除的节点与其前驱或者后继节点进行替代。此时情况变为1或2（根据实际被删除的节点的颜色决定）。</li></ol> <p>情况2若删除后不平衡则需要根据AVL旋转规则旋转后染色，否则直接染色。</p> <p>如果不旋转，则将兄弟节点设置为红色，将父节点设置为当前节点递归，直到根节点，或遇到红色节点；如果旋转，则旋转之后 <code>Parent</code> 位置的颜色不变，其他位置根据黑色节点个数进行调整。</p>`,155)])])}const h=a(e,[["render",n]]);export{m as __pageData,h as default};
