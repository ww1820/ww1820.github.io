import{_ as a,o as i,c as n,ag as e}from"./chunks/framework.DEqXEGcv.js";const k=JSON.parse('{"title":"动态库卸载导致 shared_ptr 析构崩溃问题分析","description":"","frontmatter":{},"headers":[],"relativePath":"3 问题记录/动态库卸载导致shared_ptr析构崩溃问题.md","filePath":"3 问题记录/动态库卸载导致shared_ptr析构崩溃问题.md","lastUpdated":1770889489000}'),l={name:"3 问题记录/动态库卸载导致shared_ptr析构崩溃问题.md"};function t(p,s,r,d,h,o){return i(),n("div",null,[...s[0]||(s[0]=[e(`<h1 id="动态库卸载导致-shared-ptr-析构崩溃问题分析" tabindex="-1">动态库卸载导致 <code>shared_ptr</code> 析构崩溃问题分析 <a class="header-anchor" href="#动态库卸载导致-shared-ptr-析构崩溃问题分析" aria-label="Permalink to &quot;动态库卸载导致 \`shared_ptr\` 析构崩溃问题分析&quot;">​</a></h1> <h2 id="问题现象" tabindex="-1">问题现象 <a class="header-anchor" href="#问题现象" aria-label="Permalink to &quot;问题现象&quot;">​</a></h2> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20251225183637769.png" alt="image.png" loading="lazy"></p> <p>程序在退出时发生 <strong>SIGSEGV（段错误）</strong>，崩溃位置位于 <code>std::shared_ptr&lt;BusinessPlugin&gt;</code> 的析构过程中。</p> <h2 id="根本原因" tabindex="-1">根本原因 <a class="header-anchor" href="#根本原因" aria-label="Permalink to &quot;根本原因&quot;">​</a></h2> <ul><li><code>BusinessPlugin</code> 是从 <strong>动态库（. so）</strong> 中加载的类。</li> <li>在 <code>shared_ptr</code> 对象析构 <strong>之前</strong>，该动态库已被显式调用 <code>dlclose()</code> 卸载。</li> <li>导致 <code>BusinessPlugin</code> 的析构函数地址失效（所处内存已被释放或 unmapped）。</li> <li>当 <code>shared_ptr</code> 尝试调用该析构函数时，跳转到非法内存地址 → 触发 <strong>段错误</strong>。</li></ul> <h2 id="关键细节" tabindex="-1">关键细节 <a class="header-anchor" href="#关键细节" aria-label="Permalink to &quot;关键细节&quot;">​</a></h2> <p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/20251225183749030.png" alt="image.png" loading="lazy"></p> <ul><li>成员变量声明顺序影响析构顺序（C++ 标准规定：成员按声明顺序构造，<strong>逆序析构</strong>）。</li> <li>若动态库句柄（如 <code>void* handle = dlopen(...)</code>）作为类成员，且声明在 <code>shared_ptr&lt;BusinessPlugin&gt;</code> <strong>之后</strong>，则：
<ul><li><code>shared_ptr</code> 先析构 → 需要调用 <code>BusinessPlugin::~BusinessPlugin()</code>；</li> <li>此时动态库可能已被 <code>dlclose(handle)</code> 卸载（如果 <code>handle</code> 在之后才析构）→ 崩溃。</li></ul></li></ul> <h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2> <ol><li><p><strong>调整成员声明顺序</strong>：<br>
确保动态库句柄（<code>dlopen</code> 返回的 <code>handle</code>）在 <code>shared_ptr&lt;BusinessPlugin&gt;</code> <strong>之前声明</strong>。<br>
这样 <code>handle</code> 会在 <code>shared_ptr</code> <strong>之后析构</strong>，保证析构 <code>BusinessPlugin</code> 时动态库仍加载。</p></li> <li><p><strong>延迟卸载动态库</strong>：<br>
手动管理生命周期，确保所有依赖该库的对象（如 <code>shared_ptr</code>）完全析构后，再调用 <code>dlclose()</code>。</p></li> <li><p><strong>避免在动态库中定义需跨模块析构的类型</strong>：<br>
可考虑使用 <strong>纯虚接口 + 工厂函数</strong> 模式，将对象创建和销毁限制在动态库内部。</p></li></ol> <h2 id="示例-正确顺序" tabindex="-1">示例（正确顺序） <a class="header-anchor" href="#示例-正确顺序" aria-label="Permalink to &quot;示例（正确顺序）&quot;">​</a></h2> <div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PluginManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lib_handle;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 先声明：后析构</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BusinessPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> plugin;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 后声明：先析构</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    PluginManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lib_handle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dlopen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;libbusiness.so&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, RTLD_LAZY);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... 加载 plugin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ~PluginManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // plugin 先析构（此时 lib_handle 仍有效）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // lib_handle 后析构，随后 dlclose</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>⚠️ 注意：C++ 对象析构顺序与成员声明顺序<strong>相反</strong>！</p></blockquote>`,26)])])}const g=a(l,[["render",t]]);export{k as __pageData,g as default};
