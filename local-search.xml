<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/posts/f89cb603/"/>
    <url>/posts/f89cb603/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h1><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><p>二叉搜索树（BST）具备以下特性（规则）：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉搜索树。</li></ol><p>在BST中最大比较次数为树的高度，树的高度范围为 $[log(n), n]$。 </p><p>当树中每个结点左、右子树高度大致相同时，树高为 $\text{log}(n)$ ，则平均查找长度与 $\text{log}(n)$ 成正比，查找的平均时间复杂度在 $O(\text{log}n)$ 数量级上。</p><p>当树形结构为一个单子树时，此时树高 $n$ ，则平均查找长度为 $(n+1)&#x2F;2$ ，查找的平均时间复杂度在 $O(n)$ 数量级上。</p><p>相同序列构成的不同二叉搜索树：<a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树 - 力扣（LeetCode）</a></p><h2 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h2><p>平衡二叉查找树的出现，主要是为了解决<strong>当二叉树查找树形态结构变成一个链条结构的时候，查找效率变低的问题</strong>，算法由<code>Adel&#39;son-Vel&#39;skii</code>和<code>Landis</code>发明，同时也称<code>AVL</code>树，特性（规则）如下：</p><ol><li><p>它的左子树和右子树都是平衡二叉树；</p></li><li><p>且它的左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。</p></li></ol><p>AVL是严格平衡的BST（平衡因子不超过1）。查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是 $O(\text{log}n)$ 。</p><p>$$<br>balance\  factor &#x3D; height\ of\ left\ subtree - height\ of\ right\ subtree \<br>bf &#x3D; {-1, 0, 1} \<br>|bf| &#x3D; |hl - hr| \le 1<br>$$</p><p>AVL 的旋转：</p><ol><li>LL-imbalance：由于在左子树的左子树插入或删除而导致的不平衡，进行LL-Rotation；</li><li>LR-imbalance：由于在左子树的右子树插入或删除而导致的不平衡，进行LR-Rotation；</li><li>RR-imbalance：由于在右子树的右子树插入或删除而导致的不平衡，进行RR-Rotation；</li><li>RL-imbalance：由于在右子树的左子树插入或删除而导致的不平衡，进行RL-Rotation。</li></ol><p>在插入、删除树节点的时候，<strong>AVL树会自动进行调整</strong>。也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。AVL在每次插入节点时对树进行检查和调整，AVL的旋转每次只涉及以imbalance节点为根节点的3个节点（如下图）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031408586.png" alt="AVL树的旋转-插入42"></p><p>以 LL-Rotation 和 LR-Rotation 为例（假设图中节点A为第一个 $|bf| \neq 1$ 的节点）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031412866.png" alt="LL-Rotation"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031413467.png" alt="LR-Rotation"></p><p>给定节点数为 $n$ 的AVL树，最大高度为 $\text{log}(2n)$ ，而不是 $n$。</p><p>平衡二叉搜索树解决二叉搜索树的问题，保证了不会成为线性的链表。<br>左结点小于根节点，右结点大于根节点，并且还规定了左子树和右子树的高度差不得超过1。</p><p>但其仍然存在问题：</p><ol><li>由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。</li><li>每一个节点只能存放一个元素，每个节点只有两个子节点，所以查找时，需要多次磁盘IO（如果数据存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页。）</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>视频：<a href="https://www.youtube.com/watch?v=aZjYr87r1b8">10.2 B Trees and B+ Trees. How they are useful in Databases - YouTube</a></p><p>B 树的基本思想：多级索引</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031643643.png" alt="多级索引"></p><p>一个m阶的B树的规则：</p><ol><li>根结点至少有两个子树（1个索引）；</li><li>每个中间节点都包含 $k-1$ 个元素和 $k$ 个孩子，其中 $m&#x2F;2 \le k \le m$  ；</li><li>每一个叶子节点都包含 $k-1$ 个元素，其中 $m&#x2F;2 \le k \le m$  ；</li><li>所有的叶子结点都位于同一层；</li><li>每个节点中的元素从小到大排列，节点当中 $k-1$ 个元素正好是 $k$ 个孩子包含的元素的值域分划。</li></ol><p>4阶B树，例子：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031545671.png" alt="B树的构建"></p><h2 id="2-3-4-树"><a href="#2-3-4-树" class="headerlink" title="2-3-4 树"></a>2-3-4 树</h2><p>2-3-4 树 是 四阶 B树，它是一种多路查找树，其结构有以下限制：</p><ol><li>所有叶子节点具有相同的深度；</li><li>节点只能是2-节点、3-节点和4-节点之一：<ul><li>2-节点：包含1个元素的节点，有2个子树；</li><li>3-节点：包含2个元素的节点，有3个子树；</li><li>4-节点：包含3个元素的节点，有4个子树。</li></ul></li><li>所有节点必须至少包含一个元素；</li><li>元素始终保持排序顺序 ，整体上保持二叉搜索树的性质，即父节点的值大于左子树所有节点，小于右子树所有节点；</li><li>节点有多个元素时，每个元素必须大于它左边的和左子树中的元素。</li></ol><p>例：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031651195.png" alt="2-3-4树"></p><p>2-3-4树的实现在一些编程语言中较为困难，一般使用其等同的红黑树。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>视频：<a href="https://www.bilibili.com/video/BV1j44y1q7k8?p=1&vd_source=88ba307806f3a95297a7d08a098d6a4b">【完整版】最全最新红黑树讲解，数组、链表、二叉树、AVL树、红黑树哔哩哔哩_bilibili</a></p><h2 id="2-3-4-树和红黑树的等价关系"><a href="#2-3-4-树和红黑树的等价关系" class="headerlink" title="2-3-4 树和红黑树的等价关系"></a>2-3-4 树和红黑树的等价关系</h2><p>2-3-4 树和红黑树的等价关系：</p><ol><li>2-节点对应RB-Tree黑节点；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712340.png" alt="2-节点"></p><ol start="2"><li>3-节点对应RB-Tree上黑下红（分为左倾和右倾两种）；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712317.png" alt="3-节点"></p><ol start="3"><li>4-节点对应RB-Tree上黑下红。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031713313.png" alt="4-节点"></p><p>2-3-4 树到红黑树的转换：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031756841.png" alt="2-3-4 树到红黑树（左倾）"></p><p>平衡二叉查找树通过严格平衡策略，以牺牲建立查找结构的代价换来了稳定的查找时间复杂度。但是相对来说，在删除方面，时间复杂度稍大。而红黑树不严格控制左、右子树高度或节点数之差小于等于1。</p><h2 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h2><p>红黑树是自平衡（不严格限制）的二叉搜索树， <strong>红黑树的5条规则：</strong></p><ol><li>节点要么是黑色要么是红色；</li><li>根节点是黑色；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>每个红色节点的两个子节点都是黑色（也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点）；</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍，因而，红黑树是相对的接近平衡的二叉树，但是相比平衡二叉树而言，尤其是删除的时间复杂度，有所降低）。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031616562.png" alt="红黑树"></p><p><strong>分析：</strong></p><ol><li>第2条特性：从 2-3-4 树到红黑树的转换中，根节点要么是2-节点（黑色），要么是3-节点或4-节点分裂出的（上黑）；</li><li>第5条特性：从 2-3-4 树到红黑树的转换中，可以看出2-3-4 树的每个节点中有且仅有一个黑色元素，由于B树中所有的叶子结点都位于同一层，所以从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（2-3-4树的高度+1）。</li></ol><p>红黑树在查找方面和AVL树操作几乎相同。牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。任何不平衡都会在三次旋转之内解决。<br>确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证 $O(\text{log}n)$ 。</p><p>红黑树的通过旋转和染色来自平衡。</p><h2 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h2><p>红黑树的查找与二叉树搜索树的查找一样。</p><h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/166319823">红黑树的原理 (插入+ 删除) 案例分析 - 知乎 (zhihu.com)</a></p><p>向红黑树中插入新的结点。具体做法是：</p><ol><li>将新结点的 color 赋为红色，然后以二叉排序树的插入方法插入到红黑树中去。之所以将新插入的结点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。</li><li>通过颜色调换和树旋转来调整可能会出现两个连续红色节点的冲突。</li></ol><p>插入不同的情况：</p><ol><li>插入根节点；</li><li>插入节点的父节点为黑色；</li><li>插入节点的父节点为红色，叔节点也为红色；</li><li>插入节点的父节点是红色，叔节点是黑色：<ol><li>左左插入</li><li>左右插入</li><li>右右插入</li><li>右左插入</li></ol></li></ol><p>具体操作：</p><ol><li><p>插入根结点：直接染黑。</p></li><li><p>插入节点的父节点为黑色，没有出现两个连续红色节点的冲突，不需要调整。</p></li><li><p>插入节点的父节点为红色，叔节点也为红色，不需要旋转，直接染色，注意递归向上调整。</p><p>分析：插入N之前，N所在的位置必为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点必为 NIL</strong>。插入新节点之后树仍是平衡的，所以不需要旋转。</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032144818.png" alt="case 3"></p><ol start="4"><li><p>插入节点的父节点是红色，叔节点是黑色:</p><ol><li><p>左左插入，左旋</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LL-imbalance，需要进行LL-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032202879.png" alt="case 4-1"></p></li><li><p>左右插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LR-imbalance，需要进行LR-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032207490.png" alt="case4-2"></p></li><li><p>右右插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RR-imbalance，需要进行RR-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032213353.png" alt="case4-3"></p></li><li><p>右左插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RL-imbalance，需要进行RL-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032318044.png" alt="case4-4"></p></li></ol></li></ol><p>总结：根据平衡二叉树正常插入节点之后根据平衡判断是否需要旋转，若不需要旋转，则将 <code>Parent</code> 和 <code>Uncle</code> 染黑，<code>GrandParent</code> 染红，再递归向上调整；若不平衡，则根据情况进行旋转，旋转之后上黑（新的 <code>GrandParent</code> ）下红染色。</p><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p>删除不同的情况：</p><ol><li>删除叶节点，且叶节点为红色，无需调整；</li><li>删除叶节点，叶节点为黑色，需要调整；</li><li>删除节点非叶节点，则将要删除的节点与其前驱或者后继节点进行交换，此时情况变为1或2（根据前驱或者后继节点的颜色决定）。</li></ol><p>情况2若删除后不平衡则需要根据AVL旋转规则旋转后染色，否则直接染色。</p><p>如果不旋转，则将兄弟节点设置为红色，将父节点设置为当前节点递归，直到根节点，或遇到红色节点；如果旋转，则旋转之后 <code>Parent</code> 位置的颜色不变，其他位置根据黑色节点个数进行调整。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/posts/735e5788/"/>
    <url>/posts/735e5788/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022027979.png" alt="概览"></p><p>排序算法主要可根据 <strong>稳定性</strong> 、<strong>就地性</strong> 、<strong>自适应性</strong> 分类。理想的排序算法具有以下特性：</p><ul><li>具有稳定性，即相等元素的相对位置不变化；</li><li>具有就地性，即不使用额外的辅助空间；</li><li>具有自适应性，即时间复杂度受元素分布影响。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>算法步骤：</strong></p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022027854.gif" alt="冒泡排序"></p><p>冒泡排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort1</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort2</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-type">bool</span> swapped = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><br><span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果上一轮没有发生交换，则说明已经有序</span><br><br>swapped = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>swapped = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>算法步骤</strong><br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028501.gif" alt="选择排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-type">int</span> minIdx = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &gt; arr[j]) &#123;<br>minIdx = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>算法步骤：</strong><br>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028731.gif" alt="插入排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> key = arr[i];<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key)<br>&#123;<br>arr[j + <span class="hljs-number">1</span>] = arr[j--];<br>&#125;<br>arr[j + <span class="hljs-number">1</span>] = key;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p><strong>算法步骤：</strong><br>选择一个增量序列 <code>t1, t2, ..., tk</code>，其中 <code>ti &gt; tj, tk = 1</code>；<br>按增量序列个数 <code>k</code>，对序列进行 <code>k</code> 趟排序；<br>每趟排序，根据对应的增量 <code>ti</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028025.gif" alt="希尔排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 希尔排序，优化版的插入排序</span><br><span class="hljs-comment">// 每次组内排序必须用插入排序或者冒泡排序（优化过的），插入排序和冒泡排序对“基本有序”的序列排序接近O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> gap = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n = array.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (gap &lt; n / <span class="hljs-number">3</span>) <span class="hljs-comment">// 确定分组间隔</span><br>    &#123;<br>        gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (gap &gt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> key = array[i];<br>            <span class="hljs-type">int</span> j = i - gap;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; key &lt; array[j])<br>            &#123;<br>                array[j + gap] = array[j];<br>                j -= gap;<br>            &#125;<br>            array[j + gap] = key;<br>        &#125;<br>        gap = gap / <span class="hljs-number">3</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022029938.gif" alt="归并排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> left ,<span class="hljs-type">int</span> right)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(left &gt;= right)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 划分</span><br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(vec, left, mid);     <span class="hljs-comment">// [l,mid] 有序</span><br>    <span class="hljs-built_in">mergeSort</span>(vec, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// [mid+1,r] 有序</span><br><br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(vec.begin()+left, vec.begin()+right + <span class="hljs-number">1</span>)</span></span>; <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = left; k &lt;= right; ++k)&#123;<br>        <span class="hljs-keyword">if</span>(left + i &gt; mid) &#123;<br>            vec[k] = tmp[j++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left + j &gt; right || tmp[i] &lt;= tmp[j]) <span class="hljs-comment">// &lt;= 稳定</span><br>        &#123;<br>            vec[k] = tmp[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vec[k] = tmp[j++];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022029722.gif" alt="快速排序"></p><p>算法步骤：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partitionVec</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 以 vec[l] 作为基准</span><br>    <span class="hljs-type">int</span> i = l;<br>    <span class="hljs-type">int</span> j = r;<br><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; vec[j] &gt;= vec[l])<br>            --j;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; vec[i] &lt;= vec[l])<br>            ++i;<br>        <span class="hljs-built_in">swap</span>(vec[i], vec[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">swap</span>(vec[l], vec[i]);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 子数组的长度为 1 时终止递归</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 哨兵划分</span><br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partitionVec</span>(vec, <span class="hljs-number">0</span>, vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 左右数组递归</span><br>    <span class="hljs-built_in">quickSort</span>(vec, l, pos - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quickSort</span>(vec, pos + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用<strong>堆</strong>这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于<strong>升序排列</strong>（递增数组）；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于<strong>降序排列</strong>（递减数组）。</li></ol><p>堆排序的平均时间复杂度为 $O(n\text{log}n)$。</p><p>算法步骤：</p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022107615.gif" alt="堆排序演示"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022108887.gif" alt="堆排序"></p><p>一般用数组存储堆结构：</p><p>下标为 $i$ 的节点的父节点下标为 $(i-1)&#x2F;2$ ；</p><p>下标为 $i$ 的节点的左子节点下标为 $i \times 2 + 1$ ；</p><p>下标为 $i$ 的节点的右子节点下标为 $i \times 2 + 1$ 。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> parent = start;<br>    <span class="hljs-type">int</span> child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子节点下标</span><br><br>    <span class="hljs-keyword">while</span> (child &lt;= end)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(child + <span class="hljs-number">1</span> &lt;= end &amp;&amp; vec[child] &lt; vec[child + <span class="hljs-number">1</span>])<br>            ++child;<br><br>        <span class="hljs-keyword">if</span> (vec[parent] &gt; vec[child]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">swap</span>(vec[parent], vec[child]);<br>            parent = child;<br>            child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = vec.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">max_heapify</span>(vec, i, len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化堆，从最后一个根结点开始调整</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">swap</span>(vec[<span class="hljs-number">0</span>], vec[i]); <span class="hljs-comment">// 将跟节点（最大元素）与最后一个元素交换</span><br>        <span class="hljs-built_in">max_heapify</span>(vec, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 将堆的尺寸缩小 1，再进行调整</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="基数排序-1"><a href="#基数排序-1" class="headerlink" title="基数排序"></a>基数排序</h1>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题笔记</title>
    <link href="/posts/9813b472/"/>
    <url>/posts/9813b472/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>题目列表：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>          </div><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><p>常用算法</p><ul><li>二分</li><li>双指针</li><li>滑动窗口</li><li>模拟</li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><table><thead><tr><th>暴力</th><th>$O(n)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(\text{log}n)$</td></tr></tbody></table><p>二分的前提是数组是有序的，二分法每次能排除一半的元素，时间复杂度为 $O(\text{log}n)$。<br>使用二分法是要注意解是否包含在左右边界中，在循环中，区间的定义不能改变（区间的开闭）。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><table><thead><tr><th>暴力</th><th>$O(n^2)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(n)$</td></tr></tbody></table><ul><li>快慢指针（追击）</li><li>相向指针（相遇）</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><table><thead><tr><th>暴力</th><th>$O(n^2)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(n)$</td></tr></tbody></table><p>理解滑动窗口如何移动、窗口起始位置、如何更新窗口大小。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>注意状态更新和数组越界。</p><h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>常用技巧：虚拟头结点</p><p>常见题型：</p><ol><li>反转链表<ol><li>迭代</li><li>递归</li></ol></li><li>删除倒数第 $n$个节点、<ol><li>快慢指针</li></ol></li><li>链表相交<ol><li>双指针</li><li>哈希表</li></ol></li><li>环形链表<ol><li>快慢指针</li><li>哈希表</li></ol></li></ol><p>注意nullptr。</p><h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><ol><li>不同的数据通过哈希函数映射到统一索引的现象叫<strong>哈希碰撞</strong>，一般的解决方法有<ol><li>拉链法</li><li>线性探测法</li></ol></li><li>哈希法解决问题一般选择的数据结构：<ol><li>数组</li><li>set</li><li>map</li></ol></li></ol><table><thead><tr><th><strong>集合</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><table><thead><tr><th><strong>映射</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><ol><li>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</li></ol><h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>双指针</p><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>模拟</p><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>空间复杂度$O(1)$解法：<br>首先扩充数组到每个空格替换成”%20”之后的大小。然后从后向前替换空格，也就是双指针法。</p><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p>空间复杂度$O(1)$解法：</p><ol><li>移除多余空格（快慢指针）</li><li>将整个字符串反转</li><li>将每个单词反转</li></ol><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>空间复杂度$O(1)$解法：</p><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><p>重要<strong>Knuth-Morris-Pratt (KMP) 字符串查找算法</strong><br>暴力算法：$O(m\times n)$<br>KMP算法：$O(m+n)$</p><ol><li><strong>主要思想：</strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li><strong>前缀表：</strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。<br>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪个位置开始重新匹配。</li><li>**最长公共前后缀<br>**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。<br>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。<br><code>aabaa</code>的最长 ~~公共 ~~相同 前后缀为 <code>aa</code>，长度为2。</li><li>模式串与前缀表对应位置的数字表示的是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022020803.png" alt="字符串匹配"></p><p>当<code>s[i]</code>不匹配时，应该回退到前缀表 <code>next[i-1]</code>中记录的下标位继续匹配。</p><ol><li>构造next数组<br>构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：<ol><li>初始化</li><li>处理前后缀不相同的情况：回退</li><li>处理前后缀相同的情况：匹配长度+1</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// j 指向前缀末尾位置(前缀长度)</span><br>    next[<span class="hljs-number">0</span>] = j; <span class="hljs-comment">// next[i] 表示 i(包括i)之前最长相等的前后缀长度（其实就是j）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// i 指向后缀末尾位置，注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        &#125;<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何回退？</strong>举例子:</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022021543.png" alt="KMP回退"></p><p><code>B</code>和<code>C</code>不匹配，发生回退，要找到与后缀 <code>ABA</code>相同部分最长的前缀，其实等同于找到找到左边部分的最长相等前缀，即为<code>n[j-1]</code>。</p><ol><li>使用前缀表进行匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// // 因为next数组里记录的起始位置为-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i就从0开始</span><br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 不匹配</span><br>            j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>            j++; <span class="hljs-comment">// i的增加在for循环里</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == (needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) &#123; <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>            <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>思路：构建<code>next</code>数组，<strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>双指针</li></ol><ul><li>反转字符串</li><li>替换空格，先给数组扩容再从后向前操作</li><li>移除元素，快慢指针</li></ul><p>erase是$O(n)$的操作，放在<code>for</code>循环里会导致 $O(n^2)$的复杂度。</p><ol start="2"><li>反转</li><li>KMP：字符串匹配问题</li></ol><h1 id="五、双指针"><a href="#五、双指针" class="headerlink" title="五、双指针"></a>五、双指针</h1><ol><li>数组<br>移除元素，通过两个指针在一个for循环内完成两个for循环的工作</li><li>字符串<ol><li>反转</li><li>扩充</li><li>移除</li></ol></li><li>链表<ol><li>快慢指针</li></ol></li><li>N数之和<ol><li>排序 + 双指针 + <strong>剪枝（注意剪枝条件）</strong></li></ol></li></ol><h1 id="六、栈和队列"><a href="#六、栈和队列" class="headerlink" title="六、栈和队列"></a>六、栈和队列</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><ol><li><p>C++标准库是有多个版本的，以下为三个最为普遍的STL版本：</p><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol></li><li><p>栈是以底层容器完成其所有的工作，<strong>对外提供统一的接口</strong>，底层容器是可插拔的（也就是说我们可以控制<strong>使用哪种容器</strong>来实现栈的功能）。所以STL中栈往往<strong>不被归类为容器</strong>，而被归类为container adapter（容器适配器）。我们常用的SGI STL，如果没有指定底层实现的话，默认是<strong>以deque为缺省</strong>情况下栈的低层结构。也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></table></figure></li><li><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，SGI STL中队列一样是以deque为缺省情况下的底部结构。所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p></li></ol><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">力扣题目链接</a><br>stkIn：队尾元素<br>stkOut：队首元素</p><ol><li>push() ：直接压入stkIn。</li><li>pop() ：先peek()，再stkOut.pop()。</li><li>peek()：若stkB不为空，直接返回stkOut.top()；否则将stkIn的元素全部压入stkOut中，再返回stkOut.top()。</li><li>empty() ：若stkIn与stkOut均为空则为空。</li></ol><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>deque实现单调栈。</p><h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p>priority_queue 容器适配器定义了一个元素有序排列的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。但是如何定义“优先级”完全取决于我们自己。<br>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Container=std::vector&lt;T&gt;, <span class="hljs-keyword">typename</span> Compare=std::less&lt;T&gt;&gt; <span class="hljs-keyword">class</span> priority_queue;<br><span class="hljs-comment">// less&lt;T&gt; 大顶堆 </span><br><span class="hljs-comment">// greater&lt;T&gt; 小顶堆</span><br></code></pre></td></tr></table></figure><p>priority_queue 实例默认有一个 vector 容器。函数对象类型 less<T> 是一个默认的<strong>排序断言</strong>，定义在头文件 functional中，决定了容器中最大的元素会排在队列前面。functional中定义了  greater<T>，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，<strong>如果指定模板的最后一个参数，就必须提供另外的两个模板类型参数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m.second &gt; n.second; <span class="hljs-comment">// 小顶堆</span><br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; occurrences;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : nums) &#123;<br>            occurrences[v]++;<br>        &#125;<br><br>        <span class="hljs-comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(&amp;cmp)&gt; <span class="hljs-built_in">q</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [num, count] : occurrences) &#123;<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() == k) &#123;<br>                <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">top</span>().second &lt; count) &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">emplace</span>(num, count);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                q.<span class="hljs-built_in">emplace</span>(num, count);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ret.<span class="hljs-built_in">emplace_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>提问：</p><ol><li>C++中stack，queue 是容器么？</li><li>我们使用的stack，queue是属于那个版本的STL？</li><li>我们使用的STL中stack，queue是如何实现的？</li><li>stack，queue 提供迭代器来遍历空间么？</li></ol><p>栈里面的元素在内存中是连续分布的么？</p><ul><li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。</li><li>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，</li></ul><h1 id="七、二叉树"><a href="#七、二叉树" class="headerlink" title="七、二叉树"></a>七、二叉树</h1><h2 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h2><p><strong>一、二叉树的种类</strong></p><ol><li>满二叉树<ol><li>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</li><li>每层的节点数为$2^{k-1}$。</li><li>深度为$k$的满二叉树节点个数为$2^0+2^1+ \cdots + 2^{k-1} &#x3D; 2^k -1$。</li></ol></li><li>完全二叉树<ol><li>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</li><li>若最底层为第 h 层，则该层包含 $[1,2^{h-1}]$  个节点。</li></ol></li><li>二叉搜索树<br>二叉搜索树是一个有序树：<ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ol></li><li>平衡搜索二叉树<ol><li>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：<ol><li>它是一棵空树或它的<strong>左右两个子树的高度差的绝对值不超过1。</strong></li><li>左右两个子树都是一棵平衡二叉树。</li></ol></li><li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（具体来说是红黑树）</strong>，所以map、set的增删操作时间时间复杂度是$logn(0)$。unordered_map、unordered_set，unordered_map、unordered_map底层实现是<strong>哈希表</strong>。</li></ol></li></ol><p><strong>二、二叉树的存储方式</strong></p><ol><li>链式存储（指针）</li><li>顺序存储（数组）<ol><li>对于完全二叉树，如果父节点的数组下标是 $i$，那么它的左孩子就是 $2i+1$，右孩子就是 $2i+2$。</li></ol></li></ol><p><strong>三、二叉树的遍历方式</strong></p><ol><li>深度优先（前中后指<strong>中间节点的遍历顺序</strong>）<ol><li>前序遍历（迭代、递归）</li><li>中序遍历（迭代、递归）</li><li>后续遍历（迭代、递归）</li></ol></li><li>广度优先<ol><li>层次遍历（迭代）</li></ol></li></ol><p><strong>DFS两种实现</strong></p><ol><li>递归三要素：<ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol></li><li>迭代：<ol><li>前序：处理顺序与访问顺序一致<ol><li>先处理根结点</li><li>right入栈、left入栈<strong>（空节点不入栈，出栈顺序中左右）</strong></li></ol></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(root);<br><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>中序：处理顺序与访问顺序不一致</p><ol><li>根结点入栈、left（不为空）入栈</li><li>弹栈访问数据</li><li>right（不为空）入栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode* cur = root;<br><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>后序：处理顺序与访问顺序一致</p><ol><li>right入栈、left入栈<strong>（空节点不入栈，出栈顺序左右中）</strong></li><li>弹栈访问数据</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>    stk.<span class="hljs-built_in">emplace</span>(root);<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;right);<br>    &#125; <br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BFS实现：</strong><br>队列</p><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>比较<code>leftNode-&gt;left</code>与<code>rightNode-&gt;right</code>、<code>leftNode-&gt;right</code>与<code>rightNode-&gt;left</code>。</p><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><blockquote><p>类似题目：剑指 Offer 07. 重建二叉树</p></blockquote><p>后序遍历的顺序为：左右中<br>后序遍历<code>postorder</code>的最后一个元素为当前根节点<code>root</code>，在中序遍历搜索<code>root</code>的索引，可将中序遍历<code>inorder</code>划分为<code>[leftTree | root | rightTree]</code>，随即可求出<code>leftTree</code>和<code>rightTree</code>的长度，根据子树长度可将后序遍历划分为<code>leftTree | rightTree | root</code>。由于构建二叉树时确定的是<code>postorder</code>中的<code>root</code>位置和子树长度，所以右子树的根节点为<code>root-1</code>，左子树的根节点为<code>root - 1 - rightLen</code>。<br>递归构建二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-comment">// inorder 根结点左侧为左子树，右侧为右子树</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>            dict[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bulid</span>(inorder, postorder, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">bulid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[i]);<br>        <span class="hljs-type">int</span> rootIdx = dict[postorder[i]];  <br>        root-&gt;left = <span class="hljs-built_in">bulid</span>(inorder, postorder, i - <span class="hljs-number">1</span> - (r - rootIdx), l, rootIdx - <span class="hljs-number">1</span>); <span class="hljs-comment">// (r - rootIdx) 为右子树长度</span><br>        root-&gt;right = <span class="hljs-built_in">bulid</span>(inorder, postorder, i - <span class="hljs-number">1</span>, rootIdx + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同理，前序遍历是构建二叉树时确定的是<code>preorder</code>中的<code>root</code>位置和子树长度，所以左子树的根节点为<code>root+1</code>，左子树的根节点为<code>root + 1 + leftLen</code>。</p><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><ol><li>二叉树的理论基础<ol><li>二叉树的种类</li><li>存储方式：链式、顺序</li><li>遍历方式</li><li>定义方式</li></ol></li><li>二叉树的遍历方式<ol><li>深度（递归、迭代）</li><li>广度（队列）</li></ol></li><li>求二叉树的属性<ol><li>是否对称</li><li>深度</li><li>节点数</li><li>平衡（优先递归，迭代效率低）</li><li>路径（回溯）</li><li>左下角的值</li></ol></li><li>二叉树的修改与构造<ol><li>翻转</li><li>构造（优先递归）</li><li>合并</li></ol></li><li>求二叉搜索树的属性<ol><li>中序遍历，有序数组</li></ol></li><li>二叉树公共祖先问题<ol><li>优先递归</li><li>搜索树可以迭代</li></ol></li></ol><h1 id="八、回溯算法"><a href="#八、回溯算法" class="headerlink" title="八、回溯算法"></a>八、回溯算法</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ol><li>回溯的效率<br>回溯法并不是什么高效的算法。因为回溯的<strong>本质是穷举</strong>，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些<strong>剪枝</strong>的操作，但也改不了回溯法就是穷举的本质。</li><li>回溯解决的问题<ol><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ol></li><li>理解回溯<br>回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度构成的树的深度</strong>。</li><li>回溯模板<br>回溯三部曲：<ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022022275.png" alt="回溯"></p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>递归的返回值<ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 </li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</li></ul></li></ol><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p>方法一：回溯</p><ol><li>记录映射关系（字典序排序）</li><li>回溯<ol><li>终止条件</li><li>避免死循环</li><li>遇到符合条件的路径及时返回</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ticketNum = tickets.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(ticketNum == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> tickets[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(vector&lt;string&gt; t : tickets) &#123;<br>            targets[t[<span class="hljs-number">0</span>]][t[<span class="hljs-number">1</span>]] ++;<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-built_in">recur</span>(<span class="hljs-string">&quot;JFK&quot;</span>, ticketNum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    unordered_map&lt;string, map&lt;string,<span class="hljs-type">int</span>&gt;&gt; targets;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; from, <span class="hljs-type">int</span> ticketNum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; to : targets[from]) &#123; <span class="hljs-comment">// 必须是引用</span><br>            <span class="hljs-keyword">if</span>(to.second &gt; <span class="hljs-number">0</span>) &#123;<br>                -- to.second;<br>                res.<span class="hljs-built_in">emplace_back</span>(to.first);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">recur</span>(to.first, ticketNum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                ++ to.second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：<strong>Hierholzer 算法</strong><br>化简题意：给定一个 $n$个点 $m$ 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。<br>这种「一笔画」问题与<strong>欧拉图</strong>或者<strong>半欧拉图</strong>有着紧密的联系，下面给出定义：</p><ul><li>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路；</li><li>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路；</li><li>具有欧拉回路的无向图称为欧拉图；</li><li>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</li></ul><blockquote><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><ul><li>对于无向图 $G$，$G$ 是欧拉图当且仅当 $G$是连通的且没有奇度顶点。</li><li>对于无向图 $G$，$G$是半欧拉图当且仅当 $G$是连通的且 $G$中恰有 $0$个或 $2$ 个奇度顶点。</li><li>对于有向图 $G$，$G$ 是欧拉图当且仅当 $G$ 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</li><li>对于有向图 $G$，$G$ 是半欧拉图当且仅当<ul><li>如果将 $G$中的所有有向边退化为无向边时，那么 $G$ 的所有顶点属于同一个强连通分量；</li><li>最多只有一个顶点的出度与入度差为$1$；</li><li>最多只有一个顶点的入度与出度差为$1$；</li><li>所有其他顶点的入度和出度相同。</li></ul></li></ul></blockquote><p><strong>Hierholzer 算法</strong>用于在连通图中寻找欧拉路径，其流程如下：</p><ol><li>从起点出发，进行深度优先搜索。</li><li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li><li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li></ol><p>注意到只有那个入度与出度差为$1$ 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。<br>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。<br>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec; <span class="hljs-comment">// string-&gt;priority_queue 小顶堆</span><br><br>vector&lt;string&gt; stk;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; curr)</span> </span>&#123; <span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-keyword">while</span> (vec.<span class="hljs-built_in">count</span>(curr) &amp;&amp; vec[curr].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 映射表中存在当前出发点，且目的节点数不为0</span><br>string tmp = vec[curr].<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//字典序大的先入栈，逆序后字典序最小</span><br>vec[curr].<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 移除当前边</span><br><span class="hljs-built_in">dfs</span>(<span class="hljs-built_in">move</span>(tmp));<br>&#125;<br>stk.<span class="hljs-built_in">emplace_back</span>(curr); <span class="hljs-comment">// 遇到死胡同入栈</span><br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : tickets) &#123;<br>vec[it[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(it[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 构建映射表</span><br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br><br><span class="hljs-built_in">reverse</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> stk;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h1><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022023286.png" alt="摆动序列"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                result++;<br>                preDiff = curDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022024794.png" alt="跳跃游戏II"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightmost = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nextStepMost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(rightmost &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            nextStepMost = <span class="hljs-built_in">max</span>(nextStepMost, i + nums[i]);<br>            <span class="hljs-keyword">if</span>(nextStepMost &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ++ step;<br>            <span class="hljs-keyword">if</span>(rightmost &lt;= i) &#123;<br>                ++ step;<br>                rightmost = nextStepMost;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 记录最低价格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 情况二：相当于买入</span><br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br><br>            <span class="hljs-comment">// 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）</span><br>            <span class="hljs-keyword">if</span> (prices[i] &gt;= minPrice &amp;&amp; prices[i] &lt;= minPrice + fee) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出</span><br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice + fee) &#123;<br>                result += prices[i] - minPrice - fee;<br>                minPrice = prices[i] - fee; <span class="hljs-comment">// 情况一，这一步很关键</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-comment">// 0 无覆盖； 1：存在摄像头； 2: 不需要摄像头(被覆盖或空子树)</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 空子树</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 左右子树为空 或者 左右子树被覆盖但是没有相机</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// </span><br>            result++; <span class="hljs-comment">//左右子树中有一个未被覆盖</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//安装摄像头</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 左右子树均被覆盖，且至少存在一个摄像头</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="十、动态规划"><a href="#十、动态规划" class="headerlink" title="十、动态规划"></a>十、动态规划</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022025304.png" alt="动态规划"></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h1 id="十一、单调栈"><a href="#十一、单调栈" class="headerlink" title="十一、单调栈"></a>十一、单调栈</h1><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/posts/3687adfb/"/>
    <url>/posts/3687adfb/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是C-11"><a href="#什么是C-11" class="headerlink" title="什么是C++11"></a>什么是C++11</h2><p>C++11标准为C++编程语言的第三个官方标准，正式名叫ISO&#x2F;IEC 14882:2011 - Information technology – Programming languages – C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO&#x2F;IEC 14882:2003 - Programming languages – C++成为C++语言新标准。</p><p>C++11是对目前C++语言的扩展和修正， C++11不仅包含核心语言的新机能，而且扩展了C++的标准程序库（STL） ，并入了大部分的C++ Technical Report 1（TR1） 程序库(数学的特殊函数除外)。</p><p>C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、 decltype，和模板的大量改进。</p><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。从这个意义上讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型。</p><p>注意：</p><ol><li>定义变量时必须初始化；</li><li>不支持函数形参（C++11）；</li><li>不能作为自定义类型的成员变量；</li><li>不能作为模板实例化时的参数；</li><li>不能出现在顶级数组类型。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>)</span> </span>&#123;&#125;  <span class="hljs-comment">// 2: auto函数参数，有些编译器无法通过编译</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">str</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> var = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 3: auto非静态成员变量，无法通过编译</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> a;     <span class="hljs-comment">// 1: 无法推导，无法通过编译</span><br>    vector&lt;<span class="hljs-keyword">auto</span>&gt; b = &#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 4: auto模板参数（实例化时），无法通过编译</span><br>    <span class="hljs-keyword">auto</span> c[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 5: auto数组，无法通过编译</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code>可以从一个变量或表达式中得到其类型。</p><h3 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h3><p>返回类型后置：在函数名和参数列表后面指定返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> T1 &amp; t1, <span class="hljs-type">const</span> T2 &amp; t2)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t1 * t2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t1 * t2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="易用性的改进"><a href="#易用性的改进" class="headerlink" title="易用性的改进"></a>易用性的改进</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>类内成员初始化</li><li>初始化列表</li><li>使用列表初始化可以防止类型收窄</li></ol><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>使用基于范围的for循环，其for循环迭代的范围必须是可确定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span><span class="hljs-comment">//形参中数组是指针变量，无法确定元素个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e: a) <span class="hljs-comment">// err, 编译失败</span><br>    &#123;<br>        cout &lt;&lt; e;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">func</span>(a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><p>C&#x2F;C++提供了调试工具<code>assert</code>，这是一个宏，用于在<strong>运行阶段</strong>对断言进行检查，如果条件为真，执行程序，否则调用<code>abort()</code>。</p><p>C++ 11新增了关键字<code>static_assert</code>，可用于在<strong>编译阶段</strong>对断言进行测试。</p><p>静态断言的好处：</p><ul><li><p>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</p></li><li><p>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</p></li></ul><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>C++11 使用<code>noexcept</code>替代<code>throw()</code>代表此函数不能抛出异常，如果抛出，就会异常。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code>是为了解决原来C++中<code>NULL</code>的二义性问题而引进的一种新的类型，因为<code>NULL</code>实际上代表的是0。</p><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>C++ 11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明请类型枚举非常简单，只需要在enum后加上使用class或struct。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Old</span>&#123;Yes, No&#125;;          <span class="hljs-comment">// old style</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">New</span>&#123;Yes, No&#125;;    <span class="hljs-comment">// new style</span><br><span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">New2</span>&#123;Yes, No&#125;;  <span class="hljs-comment">// new style</span><br></code></pre></td></tr></table></figure><p>“传统”的C++枚举类型有一些缺点：它会在一个代码区间中抛出枚举类型成员（<strong>如果在相同的代码域中的两个枚举类型具有相同名字的枚举成员，这会导致命名冲突</strong>），它们会被隐式转换为<strong>整型</strong>，并且不可以指定枚举的底层数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;Ok, Error&#125;;<br>    <span class="hljs-comment">//enum Status2&#123;Ok, Error&#125;;//err, 导致命名冲突, Status已经有成员叫Ok, Error</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++11中，强类型枚举解决了这些问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Status</span> &#123;Ok, Error&#125;;<br>    <span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">Status2</span>&#123;Ok, Error&#125;;<br> <br>    <span class="hljs-comment">//Status flag2 = Ok; // err，必须使用强类型名称</span><br>    Status flag3 = Status::Ok;<br> <br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">char</span> &#123; C1 = <span class="hljs-number">1</span>, C2 = <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//指定枚举的底层数据类型</span><br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">D</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123; D1 = <span class="hljs-number">1</span>, D2 = <span class="hljs-number">2</span>, Dbig = <span class="hljs-number">0xFFFFFFF0</span>U &#125;;<br> <br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(C::C1) &lt;&lt; endl;   <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::D1) &lt;&lt; endl;     <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::Dbig) &lt;&lt; endl;   <span class="hljs-comment">// 4</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</p><p>这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算。</p><p><code>constexpr</code>函数的限制：</p><ul><li><p>函数中只能有一个return语句（有极少特例）</p></li><li><p>函数必须返回值（不能是void函数）</p></li><li><p>在使用前必须已有定义（不能先声明）</p></li><li><p>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式</p></li></ul><p>常量表达式的构造函数有以下限制：</p><ul><li>函数体必须为空</li><li>初始化列表只能由常量表达式来赋值</li></ul><h3 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h3><p>用户自定义字面值，或者叫“自定义后缀”更直观些，主要作用是简化代码的读写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _mm(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x / <span class="hljs-number">1000</span>; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _m(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)  &#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _km(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">1000</span>; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_mm &lt;&lt; endl; <span class="hljs-comment">//0.001</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_m  &lt;&lt; endl; <span class="hljs-comment">//1</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_km &lt;&lt; endl; <span class="hljs-comment">//1000</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 C++ 11 标准，只有下面参数列表才是合法的，最后四个对于字符串相当有用，第二个参数会自动推断为字符串的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> <span class="hljs-type">const</span> *<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span><br><span class="hljs-type">long</span> <span class="hljs-type">double</span><br><span class="hljs-type">char</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">wchar_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char16_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char32_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br></code></pre></td></tr></table></figure><h3 id="原生字符串字面值"><a href="#原生字符串字面值" class="headerlink" title="原生字符串字面值"></a>原生字符串字面值</h3><p>原生字符串字面值(raw string literal)使用户书写的字符串“所见即所得”。C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用括号左右标识，就可以声明该字符串字面量为原生字符串了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">R&quot;(hello,\n</span><br><span class="hljs-string">         world)&quot;</span> &lt;&lt; endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的改进"><a href="#类的改进" class="headerlink" title="类的改进"></a>类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">double</span> d, <span class="hljs-type">int</span> i) &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">float</span> f, <span class="hljs-type">int</span> i, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* c) &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::A; <span class="hljs-comment">// 继承构造函数</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ExtraInterface</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量</p></li><li><p>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</p></li><li><p>一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数</p></li></ul><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>和继承构造函数类似，委托构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。</p><p> 如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这<strong>必须通过初始化列表进行操作</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Info</span>() : <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>) &#123; &#125;    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">Info</span>(i, <span class="hljs-string">&#x27;a&#x27;</span>) &#123; &#125; <span class="hljs-comment">// 既是目标构造函数，也是委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">char</span> e): <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>, e) &#123; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">char</span> e): <span class="hljs-built_in">type</span>(i), <span class="hljs-built_in">name</span>(e) &#123; <span class="hljs-comment">/* 其它初始化 */</span> &#125; <span class="hljs-comment">// 目标构造函数</span><br>    <span class="hljs-type">int</span>  type;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="继承控制"><a href="#继承控制" class="headerlink" title="继承控制"></a>继承控制</h3><p>C++11之前，一直没有继承控制关键字，禁用一个类的进一步衍生比较麻烦。</p><p>C++ 11添加了两个继承控制关键字：<code>final</code>和<code>override</code>。</p><ul><li><p>final阻止类的进一步派生和虚函数的进一步重写</p></li><li><p>override确保在派生类中声明的函数跟基类的虚函数有相同的签名</p></li></ul><h3 id="类默认函数的控制"><a href="#类默认函数的控制" class="headerlink" title="类默认函数的控制"></a>类默认函数的控制</h3><ol><li><code>=default</code><ul><li>编译器将为显式声明的 <code>=default</code>函数自动生成函数体</li><li>仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数</li><li>函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义</li></ul></li><li><code>=delete</code><ul><li>在函数声明后加上<code>=delete</code>，就可将该函数禁用</li><li>可用于禁用类的某些转换构造函数，从而避免不期望的类型转换</li><li>禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象</li></ul></li></ol><h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><h3 id="右尖括号的改进"><a href="#右尖括号的改进" class="headerlink" title="右尖括号的改进"></a>右尖括号的改进</h3><p>在C++98&#x2F;03的泛型编程中，模板实例化有一个很繁琐的地方，就是连续两个右尖括号<code>&gt;&gt;</code>会被编译解释成右移操作符，而不是模板参数表的形式，需要一个空格进行分割，以避免发生编译时的错误。</p><p>在实例化模板时会出现连续两个右尖括号，同样<code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>表达式转换时也会遇到相同的情况。C++98标准是让程序员在<code>&gt;&gt;</code>之间填上一个空格，在C++11中，这种限制被取消了。在C++11标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出<code>&gt;&gt;</code>是一个右移操作符还是模板参数表的结束标记。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">//std::is_same</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">using</span> uint = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// CPP11</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> UINT;<br><span class="hljs-keyword">using</span> sint = <span class="hljs-type">int</span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//std::is_same 判断类型是否一致</span><br>    <span class="hljs-comment">//这个结构体作用很简单，就是两个一样的类型会返回true</span><br>    cout &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; endl; <span class="hljs-comment">// 1</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><p>C++11之前，类模板是支持默认的模板参数，却不支持函数模板的默认模板参数。类模板的默认模板参数必须从右往左定义，数模板的默认模板参数则没这个限定。</p><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>在C++11之前，类模板和函数模板只能含有固定数量的模板参数。C++11增强了模板功能，允许模板定义中包含0到任意个模板参数，这就是可变参数模板。</p><p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在<code>typename</code>或<code>class</code>后面带上省略号<code>...</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//可变参数的模板函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ... T&gt; <span class="hljs-comment">//T叫模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T... args)</span><span class="hljs-comment">//args叫函数参数包</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">250</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>省略号<code>...</code>的作用有两个：</p><ul><li>声明一个参数包，这个参数包中可以包含0到任意个模板参数 </li><li>在模板定义的右边，可以将参数包展开成一个一个独立的参数</li></ul><p>应用：</p><ol><li>函数的递归调用</li><li>类的递归继承</li></ol><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><p>左值引用是对一个左值进行引用的类型，右值引用则是对一个右值进行引用的类型。</p><p>左值引用和右值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须<strong>立即进行初始化</strong>。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个<strong>别名</strong>。</p><p>左值引用是具名变量值的别名，而右值引用则是<strong>不具名（匿名）变量</strong>的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;a = <span class="hljs-number">2</span>;       <span class="hljs-comment">// 左值引用绑定到右值，编译失败, err</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 非常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = b; <span class="hljs-comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;e = c; <span class="hljs-comment">// 常量左值引用绑定到常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 常量左值引用绑定到右值，编程通过, ok</span><br></code></pre></td></tr></table></figure><p><code>const 类型 &amp;</code>为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。</p><p>右值引用，使用<code>&amp;&amp;</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp; r1 = <span class="hljs-number">22</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> &amp;&amp; r2 = x + y;<br>T &amp;&amp; a = <span class="hljs-built_in">ReturnRvalue</span>();<br></code></pre></td></tr></table></figure><p>通常情况下，右值引用是不能够绑定到任何的左值的。</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</p><p>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。</p><p>通过转移语义，临时对象中的资源能够转移其它的对象里。</p><h4 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//移动构造函数</span><br>    <span class="hljs-comment">//参数是非const的右值引用</span><br>    <span class="hljs-built_in">MyString</span>(MyString &amp;&amp; t)<br>    &#123;<br>        str = t.str; <span class="hljs-comment">//拷贝地址，没有重新申请内存</span><br>        len = t.len;<br> <br>        <span class="hljs-comment">//原来指针置空，必须修改</span><br>        t.str = <span class="hljs-literal">NULL</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>和拷贝构造函数类似，有几点需要注意：</p><ul><li>参数（右值）的符号必须是右值引用符号，即<code>&amp;&amp;</code>。</li><li>参数（右值）不可以是常量，因为我们需要修改右值。</li><li>参数（右值）的资源链接和标记必须修改，否则，右值的析构函数就会释放资源，转移到新对象的资源也就无效了。</li></ul><p>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。转移赋值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>        <br>    <span class="hljs-comment">//移动赋值函数</span><br>    <span class="hljs-comment">//参数为非const的右值引用</span><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(MyString &amp;&amp;tmp)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(&amp;tmp == <span class="hljs-keyword">this</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//先释放原来的内存</span><br>        len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">delete</span> [] str;<br><br>        <span class="hljs-comment">//无需重新申请堆区空间</span><br>        len = tmp.len;<br>        str = tmp.str; <span class="hljs-comment">//地址赋值</span><br>        tmp.str = <span class="hljs-literal">NULL</span>;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;移动赋值函数\n&quot;</span>;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>   ...<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="标准库函数-std-move"><a href="#标准库函数-std-move" class="headerlink" title="标准库函数 std::move()"></a>标准库函数 std::move()</h3><p>如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用。标准库提供了函数 <code>std::move()</code>，这个函数以非常简单的方式将左值引用转换为右值引用。</p><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward()"></a>完美转发 std::forward()</h3><p>完美转发适用于这样的场景：<strong>需要将一组参数原封不动的传递给另一个函数</strong>。</p><p>“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：<strong>左值／右值和 const&#x2F;non-const</strong>。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样。在泛型函数中，这样的需求非常普遍。</p><p>C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。</p><p>C++11中的引用折叠规则：</p><table><thead><tr><th>TR的类型定义</th><th>声明v的类型</th><th>v的实际类型</th></tr></thead><tbody><tr><td>T &amp;</td><td>TR</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;&amp;</td><td>T &amp;</td></tr><tr><td>T  &amp;&amp;</td><td>TR</td><td>T  &amp;&amp;</td></tr><tr><td>T &amp;&amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T  &amp;&amp;</td><td>TR &amp;&amp;</td><td>T  &amp;&amp;</td></tr></tbody></table><p><strong>一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用。</strong></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>C++11中有<code>unique_ptr</code>、<code>shared_ptr</code>与<code>weak_ptr</code>等智能指针(smart pointer)，定义在<code>&lt;memory&gt;</code>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><code>unique_ptr</code>持有对对象的独有权，同一时刻只能有一个<code>unique_ptr</code>指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p><p><code>unique_ptr</code>指针本身的生命周期：从<code>unique_ptr</code>指针创建时开始，直到离开作用域。</p><p>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用<code>delete</code>操作符，用户可指定其他操作)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;   <span class="hljs-comment">// 无法复制的unique_ptr</span><br>    <span class="hljs-comment">//unique_ptr&lt;int&gt; up2 = up1;        // err, 不能通过编译</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">move</span>(up1);    <span class="hljs-comment">// 现在p3是数据的唯一的unique_ptr</span><br>    up3.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 显式释放内存</span><br>    up1.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 不会导致运行时错误</span><br>    <br>    up4.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">44</span>)); <span class="hljs-comment">//&quot;绑定&quot;动态对象</span><br>    <br>    up4 = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价</span><br>    <br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">55</span>))</span></span>;<br>    <span class="hljs-type">int</span> *p = up5.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//只是释放控制权，不会释放内存</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//释放堆区资源</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><code>shared_ptr</code>允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个<code>shared_ptr</code>共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数2</span><br>    <br>    sp1.<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">//显式让引用计数减1</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下<code>shared_ptr</code>可以正常运转，但是在循环引用的场景下，<code>shared_ptr</code>无法正确释放内存。循环引用，顾名思义，<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>，在表示双向关系时，是很可能出现这种情况的，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Father&gt; father_;<br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son = <span class="hljs-built_in">make_shared</span>&lt;Son&gt;();<br>    <span class="hljs-keyword">auto</span> father = <span class="hljs-built_in">make_shared</span>&lt;Father&gt;();<br>    son-&gt;father_ = father;<br>    father-&gt;son_ = son;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Son<br>Father<br>son: 2<br>father: 2</p></blockquote><p>可以看到，程序分别执行了Son和Father的构造函数，但是没有执行析构函数，出现了内存泄漏。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><code>weak_ptr</code>是为配合<code>shared_ptr</code>而引入的一种智能指针来协助<code>shared_ptr</code>工作，它可以从一个<code>shared_ptr</code>或另一个<code>weak_ptr</code>对象构造，<strong>它的构造和析构不会引起引用计数的增加或减少</strong>。没有重载 <code>*</code> 和<code> -&gt;</code> 但可以使用<code>lock</code>获得一个可用的<code>shared_ptr</code>对象</p><p><code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存，而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>share_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值<code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp = sp1; <span class="hljs-comment">// 指向shared_ptr&lt;int&gt;所指对象</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印计数器 2</span><br><br>    sp1.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    sp2.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决循环引用的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    SharedPtr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    WeakPtr&lt;Father&gt; father_;  <span class="hljs-comment">// 将SharedPtr改为WeakPtr</span><br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();  <span class="hljs-comment">// 创建一个Son对象，返回指向Son对象的指针son_</span><br>    <span class="hljs-keyword">auto</span> father_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Father</span>();  <span class="hljs-comment">// 创建一个Father对象，返回指向Father对象的指针father_</span><br>    <span class="hljs-function">SharedPtr&lt;Son&gt; <span class="hljs-title">son</span><span class="hljs-params">(son_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：son.counter=1, son.weakref=0</span><br>    <span class="hljs-function">SharedPtr&lt;Father&gt; <span class="hljs-title">father</span><span class="hljs-params">(father_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：father.counter=1, father.weakref=0</span><br>    son.resource-&gt;father_ = father;  <span class="hljs-comment">// 调用WeakPtr赋值函数：father.counter=1, father.weakref=1</span><br>    father.resource-&gt;son_ = son;  <span class="hljs-comment">// 调用SharedPtr赋值函数：son.counter=2, son.weakref=0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h2><p>闭包有很多种定义，一种说法是，闭包是带有上下文的函数。即有状态的函数。</p><p>那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。</p><p>函数是代码，状态是一组变量，将代码和一组变量捆绑 (bind) ，就形成了闭包。</p><p>闭包的状态捆绑，必须发生在运行时。</p><h3 id="仿函数：重载-operator"><a href="#仿函数：重载-operator" class="headerlink" title="仿函数：重载 operator()"></a>仿函数：重载 operator()</h3><p>仿函数实现闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFunctor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> tmp) : <span class="hljs-built_in">round</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; <span class="hljs-keyword">return</span> tmp + round; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> round;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> round = <span class="hljs-number">2</span>;<br>    <span class="hljs-function">MyFunctor <span class="hljs-title">f</span><span class="hljs-params">(round)</span></span>;<span class="hljs-comment">//调用构造函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">//operator()(int tmp)</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对象，或者实现了opetator()的对象。</p><p>C++11中，新增加了一个<code>std::function</code>类模板，它是对C++中现有的可调用实体的一种类型安全的包裹。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//普通全局函数</span><br>    cout &lt;&lt; __func__ &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">foo_func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//类中静态函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//仿函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//绑定一个普通函数</span><br>    function&lt; <span class="hljs-type">void</span>(<span class="hljs-type">void</span>) &gt; f1 = func;<br>    <span class="hljs-built_in">f1</span>();<br> <br>    <span class="hljs-comment">//绑定类中的静态函数</span><br>    function&lt; <span class="hljs-type">int</span>(<span class="hljs-type">int</span>) &gt; f2 = Foo::foo_func;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">111</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">//绑定一个仿函数</span><br>    Bar obj;<br>    f2 = obj;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">222</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     运行结果：</span><br><span class="hljs-comment">        func</span><br><span class="hljs-comment">        foo_func(111) -&gt;: 111</span><br><span class="hljs-comment">        operator()(222) -&gt;: 222</span><br><span class="hljs-comment">    */</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::function</code>对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与<code>NULL</code>或者<code>nullptr</code>进行比较。</p><h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p><code>std::bind</code>是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。</p><p>C++98中，有两个函数<code>bind1st</code>和<code>bind2nd</code>，它们分别可以用来绑定<code>functor</code>的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得<code>bind1st</code>和<code>bind2nd</code>的可用性大大降低。</p><p>在C++11中，提供了<code>std::bind</code>，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>C++11中的lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。<br>lambda表达式的基本构成：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022009099.png" alt="lambda表达式"></p><ol><li><p>函数对象参数</p><p><code>[]</code>，标识一个lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义lambda为止时lambda所在作用范围内可见的局部变量（包括lambda所在类的this）。函数对象参数有以下形式：</p><ul><li>空。没有使用任何函数对象参数。</li><li>&#x3D;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>&amp;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量)。</li><li>this。函数体内可以使用lambda所在类中的成员变量。</li><li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>&amp;a。将a按引用进行传递。</li><li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li><li>&#x3D;，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul></li><li><p>操作符重载函数参数<br>标识重载的<code>()</code>操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p></li><li><p>可修改标示符<br><code>mutable</code>声明，这部分可以省略。按值传递函数对象参数时，加上<code>mutable</code>修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p></li><li><p>错误抛出标示符</p><p><code>exception</code>声明，这部分也可以省略。</p></li><li><p>函数返回值</p><p><code>-&gt;返回值类型</code>，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p></li><li><p>是函数体<br><code>&#123;&#125;</code>，标识函数的实现，这部分不能省略，但函数体可以为空。</p></li></ol><p>除去在语法层面上的不同，lambda和仿函数有着相同的内涵——都可以捕获一些变量作为初始化状态，并接受参数进行运行。</p><p>而事实上，仿函数是编译器实现lambda的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式。</p><p>lambda表达式的类型在C++11中被称为<strong>“闭包类型”</strong>，每一个lambda表达式则会产生一个**临时对象(右值)**。因此，严格地将，lambda函数并非函数指针。</p><p>不过C++11标准却允许lambda表达式向函数指针的转换，但提前是<strong>lambda函数没有捕获任何变量</strong>，且函数指针所示的函数原型，必须跟lambda函数函数有着相同的调用方式。</p><p>lambda表达式的价值在于，就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在C++11之前，C&#x2F;C++一直是一种顺序的编程语言。顺序是指所有指令都是串行执行的，即在相同的时刻，有且仅有单个CPU的程序计数器执行代码的代码段，并运行代码段中的指令。而C&#x2F;C++代码也总是对应地拥有一份操作系统赋予进程的包括堆、栈、可执行的（代码）及不可执行的（数据）在内的各种内存区域。</p><p>而在C++11中，一个相当大的变化就是引入了多线程的支持。这使得C&#x2F;C++语言在进行线程编程时，不比依赖第三方库。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷 C++11/14 笔记</title>
    <link href="/posts/bea73fec/"/>
    <url>/posts/bea73fec/</url>
    
    <content type="html"><![CDATA[<h2 id="Variadic-Template"><a href="#Variadic-Template" class="headerlink" title="Variadic Template"></a>Variadic Template</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>可变参数模板。</p><ol><li><p>谈的是模板Templates：</p><ul><li>函数模板 </li><li>类模板</li></ul></li><li><p>变化的是模板参数：</p><ul><li>参数个数：利用参数个数逐一递减的特性，实现递归函数的调用，使用函数模板完成。</li><li>参数类型：利用参数个数逐一递减以致参数类型也逐一递减的特性，实现递归继承或递归复合，以类模板完成。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;                <span class="hljs-comment">//这里的...是关键字的一部分：模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; firstArg, <span class="hljs-type">const</span> Types&amp;... args)</span>     <span class="hljs-comment">//这里的...要写在自定义类型Types后面：函数参数类型包</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; firstArg &lt;&lt; endl;<br>    <span class="hljs-built_in">print</span>(args...);                                     <span class="hljs-comment">//这里的...要写在变量args后面：函数参数包</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>注意三种不同的<code>...</code>的应用环境，这些都是<strong>语法规则</strong>，所以记住即可。</p></li><li><p>还要注意的是，在可变模板参数内部可以使用<code>sizeof...(args)</code>得到实参的个数。</p></li><li><p>如果同时定义了：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*......*/</span>&#125;<br></code></pre></td></tr></table></figure><p>该函数重载了<code>void print()</code>，<code>void print(const T&amp; firstArg, const Types&amp;... args)</code> 是其特化版本，编译器会优先调用特化版本。 </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>实现函数的 递归调用</p><p> 举了一个unordered容器中hash函数的计算例子：万用的哈希函数，函数入口<code>return hash_val(c.fname, c.lname, c.no)</code>;</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerHash</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(c.fname, c.lname, c.no);<br>        <span class="hljs-comment">// 2-1-1-...-1-3</span><br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val, <span class="hljs-type">const</span> Types&amp;... args)</span></span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args);<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// 2</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 3</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val)</span></span>&#123;<br>    <span class="hljs-built_in">hash_conbine</span>(seed, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022007091.png" alt="递归调用"></p><ol><li>实现递归继承</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Values&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;<br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;&gt; &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;Head, Tail...&gt;<br>    : <span class="hljs-keyword">private</span> tuple&lt;Tail...&gt;                  <span class="hljs-comment">//注意这里的私有继承</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> tuple&lt;Tail...&gt; inherited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">tuple</span>() &#123;&#125;<br>    <span class="hljs-built_in">tuple</span>(Head v, Tail... vtail)<br>        :<span class="hljs-built_in">m_head</span>(v), <span class="hljs-built_in">inherited</span>(vtail...) &#123;&#125;<br><br>    <span class="hljs-function">Head <span class="hljs-title">head</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_head; &#125;<br>    <span class="hljs-function">inherited&amp; <span class="hljs-title">tail</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;       <span class="hljs-comment">//这里涉及派生类到基类的类型转换</span><br><br><span class="hljs-keyword">protected</span>:<br>    Head m_head;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022008946.png" alt="递归继承"></p><h2 id="模板表达式中的空格"><a href="#模板表达式中的空格" class="headerlink" title="模板表达式中的空格"></a>模板表达式中的空格</h2><p>C++11可以去掉模块表达式前面的空格。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>标准库允许使用nullptr取代0或者NULL来对指针赋值。</p><ul><li>nullptr 是个新关键字</li><li>nullptr 可以被自动转换为各种 pointer 类型，但不会被转换为任何整数类型</li><li>nullptr的类型为std::nullptr_t，定义于 <cstddef> 头文件中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 调用 f(int).</span><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">NULL</span>);     <span class="hljs-comment">// 如果定义NULL为0，则调用 f(int)，否则具有二义性</span><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 调用 f(void *).</span><br></code></pre></td></tr></table></figure><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><ol><li>C++11 auto可以进行自动类型推导。<ul><li><strong>C语言</strong>默认的局部变量是auto类型的</li><li><strong>C++11</strong> auto可以进行自动类型推导</li></ul></li><li>使用auto的场景：类型太长或者类型太复杂</li></ol><h2 id="一致性初始化（uniform-initialization）"><a href="#一致性初始化（uniform-initialization）" class="headerlink" title="一致性初始化（uniform initialization）"></a>一致性初始化（uniform initialization）</h2><p>C++11之前初始化时存在多个版本 <code>&#123;&#125;，（），=</code>。让使用者使用时比较混乱，C++11提供一种万用的初始化方法，就是使用大括号<code>&#123;&#125;</code>。</p><p>原理解析：当编译器看到大括号包起来的东西<code>&#123;t1,t2...tn&#125;</code>时，会生成一个<code>initializer_list&lt;T&gt;</code>（<code>initializer_list</code>关联至一个<code>array&lt;T,n&gt;</code>）。调用函数（例如构造函数<code>ctor</code>）时该<code>array</code>内的元素可被编译器分解<strong>逐一传给函数</strong>；元素逐一分解传递给函数进行初始化。</p><p>但是如果调用函数自身提供了<code>initializer_list&lt;T&gt;</code>参数类型的构造函数时，则不会分解而是直接传过去。直接整包传入进行初始化。所有的容器都可以接受这样的参数。</p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer_list"></a>Initializer_list</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i;      <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span> j&#123;&#125;;    <span class="hljs-comment">// j = 0</span><br><span class="hljs-type">int</span>* p;     <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span>* q&#123;&#125;;   <span class="hljs-comment">// q = nullptr</span><br></code></pre></td></tr></table></figure><ol><li><p><code>initializer_list&lt;T&gt;</code>使用举例：</p><ul><li><code>initializer_list&lt;T&gt;</code>是一个<code>class</code>（类模板），这个必须类型要一致，跟模板不定的参数类型相比，模板不定的参数类型可以都不一样。</li><li><code>initializer_list&lt;T&gt;</code>类似于容器的使用方法</li></ul></li><li><p><code>initializer_list</code>源码剖析：</p><ul><li><code>initializer_list&lt;T&gt;</code>背后有<code>array</code>数组支撑，<code>initializer_list</code>关联一个<code>array&lt;T,n&gt;</code></li><li><code>initializer_list&lt;T&gt;</code>包含一个指向<code>array</code>的指针，它的拷贝只是一个浅拷贝，比较危险，两个指针指向同一个内存。</li></ul></li><li><p>initializer_list在STL中的使用：</p><ul><li>所有容器都接受指定任意数量的值用于构造或赋值或者<code>insert()</code>或<code>assign()</code>。</li><li>算法<code>max()</code>和<code>min()</code>也接受任意参数。</li></ul></li></ol><h2 id="explict"><a href="#explict" class="headerlink" title="explict"></a>explict</h2><p><code>explicit</code>关键字一直存在，只能作用在构造函数中，目的是阻止编译器进行不应该允许的构造函数进行隐式转换。声明为<code>explicit</code>的构造函数不能进行隐式转换，只能允许使用者明确调用构造函数。</p><p>C++11之前，只有<code>non-explicit one argument</code>的构造函数才能进行隐式转换，2.0之后支持<code>more than one argument</code>的构造函数的隐式转换。 </p><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (decl : coll) &#123;<br>    statement<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br>vector&lt;<span class="hljs-type">double</span>&gt; vec;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:  vec) &#123;...&#125;;     <span class="hljs-comment">// 赋值，无法改变容器的内容</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; elem:  vec) &#123;...&#125;;    <span class="hljs-comment">// 引用</span><br></code></pre></td></tr></table></figure><p>基于范围的<code>for</code>循环对于<code>explicit</code>类型申明的转换是不可以的。</p><h2 id="x3D-default-x3D-delete"><a href="#x3D-default-x3D-delete" class="headerlink" title="&#x3D; default, &#x3D; delete"></a>&#x3D; default, &#x3D; delete</h2><p>在 C++ 中，如果自定义了 big-five 函数，编译器就不会再生成默认的相关函数，但是如果我们在后边加上<code>= default</code> 关键字，就可以重新获得并使用编译器为我们生成的默认函数（显式缺省:告知编译器即使自己定义了也要生成函数默认的缺省版本）；</p><p><code>=delete</code>关键字相对于上面来说则是相反的，<code>=delete</code>表示不要这个函数，就是说这个函数已经删除了不能用了，一旦别人使用就会报错（显式删除：告知编译器不生成函数默认的缺省版本)，引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p><p>补充：</p><p>1、编译器提供的默认函数：</p><p>C++中，当我们设计与编写一个类时，若不显著申明，则类会默认为我们提供如下几个函数：</p><ol><li>构造函数(<code>A()</code>)</li><li>析构函数（<code>~A()</code>）</li><li>拷贝构造函数(<code>A(A&amp;)</code>)</li><li>拷贝赋值函数（<code>A&amp; operator=(A&amp;)</code>）</li><li>移动构造函数（<code>A(A&amp;&amp;)</code>）</li><li>移动赋值函数（<code>A&amp; operator=(A&amp;&amp;)</code>）</li></ol><p>注意：拷贝函数如果涉及指针就要区分浅拷贝（指针只占4字节，浅拷贝只把指针所占的那4个字节拷贝过去）和深拷贝（不仅要拷贝指针所占的字节，还要把指针所指的东西也要拷贝过去）；</p><p>默认提供全局的默认操作符函数：</p><ol><li><code>operator</code></li><li><code>operator &amp;</code></li><li><code>operator &amp;&amp;</code></li><li><code>operator *</code></li><li><code>operator-&gt;</code></li><li><code>operator-&gt;*</code></li><li><code>operator new</code></li><li><code>operator delete</code></li></ol><p><strong>2、何时需要自定义big-three(构造函数、拷贝构造、拷贝赋值)&#x2F;big-five(新增移动构造函数、移动赋值函数)？</strong></p><p>如果类中带有<code>pointer member</code>（指针成员），那我们就可以断定必须要给出 big-three ；<br>如果不带，绝大多与情况下就不必给出 big-three 。</p><p>3、<code>default</code>、<code>delete</code>关键字使用示例</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022012705.png" alt="=default, =delete"></p><p>在c++中，如果你自定义了big-five函数，编译器就不会再为你生成默认的相关函数，但是如果我们在后边加上<code>= default</code>关键字，就可以重新获得并使用编译器为我们生成的默认函数（显式缺省:告知编译器即使自己定义了也要生成函数默认的缺省版本）；</p><p><code>=delete</code>关键字相对于上面来说则是相反的，<code>=delete</code>表示不要这个函数，就是说这个函数已经删除了不能用了，一旦别人使用就会报错（显式删除：告知编译器不生成函数默认的缺省版本)，引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022013341.png" alt="image-20220802201319128"></p><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;<br><br><span class="hljs-comment">//使用</span><br>Vec&lt;<span class="hljs-type">int</span>&gt; coll;<br></code></pre></td></tr></table></figure><p>Alias Template 无法特化。</p><p>应用实例(引出模板模板参数)</p><p>考虑这样一种需求，假设我们需要实现一个函数<code>test_moveable(容器对象，类型对象)</code>，从而能实现传入任意的容器和类型，都能将其组合为一个新的东西：容器&lt;类型&gt;，这样的话我们的函数应该怎么设计呢？</p><p>（1）解法一：函数模板(无法实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_moveable</span><span class="hljs-params">(Container cntr, T elem)</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;T&gt; c;            <span class="hljs-comment">//[Error] &#x27;Container&#x27; is not a template</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>        c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">T</span>());<br>    <br>    <span class="hljs-built_in">output_static_data</span>(<span class="hljs-built_in">T</span>());<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>    c1.<span class="hljs-built_in">swap</span>(c2);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）解法二：函数模板+iterator+traits(可以实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_moveable</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::value_type Valtype;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>        c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Valtype</span>());<br>    <br>    <span class="hljs-built_in">output_static_data</span>(*(c.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>    c1.<span class="hljs-built_in">swap</span>(c2);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是可以达到效果的，但是却改变了函数签名，使用的时候我们需要这样调用：<code>test_moveable(list&lt;int&gt;())</code>，和我们开始设计的是不一样的。那么，有没有 template 语法能够在模板接受一个 template 参数 Container 时，当 Container 本身又是一个 class template ，能取出 Container 的template 参数？例如收到一个<code>vector&lt;string&gt;</code>，能够取出其元素类型<code>string</code>？那么这就引出了<strong>模板模板参数</strong>的概念。也就是下面的解法三。</p><p>（3）解法三：模板模板参数 + alias template(可以实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>          <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 模板模板参数中的T可以不写，默认就是前面的T</span><br>              <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>         &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XCls</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    Container&lt;T&gt; c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">XCLs</span>()<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>            c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">T</span>());<br> <br>        <span class="hljs-built_in">output_static_data</span>(<span class="hljs-built_in">T</span>());<br>        <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>        <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>        c1.<span class="hljs-built_in">swap</span>(c2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用时会报错</span><br>XCls&lt;MyString, vector&gt; c1;        <span class="hljs-comment">//[Error] vector的实际类型和模板中的Container&lt;T&gt;类型不匹配</span><br></code></pre></td></tr></table></figure><p>这是因为 <code>vector</code> 其实有<strong>两个模板参数</strong>，虽然第二个有默认值，我们平时也可以像<code>vector&lt;int&gt;</code>这样用。但是在模板中直接这样写类型是不匹配的（ <code>Container</code> 只有一个模板参数 ）。所以这里就用到了我们一开始提到的模板别名，只要传入的是<code>vector</code>的模板别名就可以了，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//不得在function body之内声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;<br> <br>XCls&lt;MyString, Vec&gt; c1;<br></code></pre></td></tr></table></figure><h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>类型别名类似于typedef。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">//相当于</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><code>using</code> 的用法：</p><ol><li>打开命令空间或者命令空间的成员</li><li>类似第一种，打开类的成员</li><li>类型别名和模板别名（C++ 11开始支持）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::cin;                 <span class="hljs-comment">//1</span><br><span class="hljs-keyword">using</span> _Base::_M_alloacte;       <span class="hljs-comment">//2</span><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="noexpect"><a href="#noexpect" class="headerlink" title="noexpect"></a>noexpect</h2><p>保证该函数不会丢出异常，可以在后面加上条件,也就是说在某种条件满足情况下，不会抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> noexpect</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexpect</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>一般异常处理流程</strong>：当程序发生异常时会将异常信息上报返回给调用者，如果有异常处理则处理，如果该调用者没有处理异常则会接着上报上一层，若到了最上层都没有处理，就会调用<code>std::terminate()-&gt;std::abort()</code>，然后终止程序。</p><div class="note note-warning">            <p>移动构造函数和移动赋值函数。如果构造函数没有<code>noexcept</code>，<code>vector</code>将不敢使用它。</p>          </div><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p><code>override</code>用于明确要重写父类的虚函数上，相当于告诉编译器这个函数就是要重写父类虚函数这样一个意图，让编译器帮忙检查，而没有这个关键字，编译器是不会帮你检查的。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022015702.png" alt="override"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><code>final</code>新增两种功能：</p><ol><li>禁止基类被继承</li><li>禁止虚函数被重写</li></ol><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="decltype-定义"><a href="#decltype-定义" class="headerlink" title="decltype 定义"></a>decltype 定义</h3><p>引入新关键字<code>decltype</code>可以让编译器找出表达式的类型，为了区别<code>typeof</code>，以下做一个概念区分：</p><ul><li><code>typeof</code>是一个一元运算，放在一个运算数之前，运算数可以是任意类型，非常依赖平台，已过时，由<code>decltype</code>代替；理解为：我们根据<code>typeof()</code>括号里面的变量，自动识别变量类型并返回该类型；</li><li><code>typedef</code>：定义一种类型的别名，而不只是简单的宏替换；</li><li><code>define</code>：简单的宏替换；</li><li><code>typeid()</code> 返回变量类型的字符串，用于<code>print</code>变量类型。</li></ul><h3 id="decltype-用法"><a href="#decltype-用法" class="headerlink" title="decltype 用法"></a>decltype 用法</h3><ol><li>用来声明函数的返回值类型，一种新的指定函数返回值类型的方式；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Add</span><span class="hljs-params">(T1 x, T2 y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x + y)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>模板之间的应用</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022016392.png" alt="模板之间的应用"></p><ol start="3"><li><p>用来求 lambda 表达式的类型</p><p>lambda 是匿名的函数对象或仿函数，每一个都是独一无二的；如果需要声明一个这种对象的话，需要用模板或者 auto ；如果需要他的 type ，可以使用 decltype ；lambda 没有默认构造函数和析构函数。</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022017251.png" alt="lambda表达式"></p><h2 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h2><h3 id="lambda-语法以及调用方式"><a href="#lambda-语法以及调用方式" class="headerlink" title="lambda 语法以及调用方式"></a>lambda 语法以及调用方式</h3><p>定义： lambda 是一组功能的组合定义， lambda 可以定义为内联函数，可以被当做一个参数或者一个对象，类似于仿函数。</p><p>最简单的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">[] &#123;<br>    statements<br>&#125;;<br><br><span class="hljs-keyword">auto</span> l = [] &#123;<br>    statements<br>&#125;;<br><br><span class="hljs-built_in">l</span>(); <br></code></pre></td></tr></table></figure><p>完整形式：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022019028.png" alt="lambda表达式"></p><table><thead><tr><th></th><th>含义</th></tr></thead><tbody><tr><td>[]</td><td>lambda 导入器，取用外部变量</td></tr><tr><td>()</td><td>类似函数参数</td></tr><tr><td>mutable</td><td>[]中的导入数据是否可变</td></tr><tr><td>throwSpec</td><td>抛出异常</td></tr><tr><td>retType</td><td>类似函数返回值</td></tr><tr><td>{}</td><td>类似函数体</td></tr></tbody></table><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022017584.png" alt="image-20220802201742502"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022018597.png" alt="image-20220802201822504"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++项目笔记——MyTinySTL(1)概述</title>
    <link href="/posts/135304f3/"/>
    <url>/posts/135304f3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/ww1820/MyTinySTL">ww1820&#x2F;MyTinySTL: A tiny STL in C++11，练手项目 (github.com)</a></p></blockquote><h2 id="STL（Standard-Template-Library）"><a href="#STL（Standard-Template-Library）" class="headerlink" title="STL（Standard Template Library）"></a>STL（Standard Template Library）</h2><ul><li>C++ Standard Library，C++ 标准库<ul><li>C++ Standard Template Library，C++ 标准模板库</li></ul></li></ul><p>STL 是 <strong>C++ 标准库的一部分</strong>，不用单独安装。. C++ STL 借助模板（Template）把常用的 <strong>数据结构</strong> 及其<strong>算法</strong>都实现了一遍，并且做到了数据结构和算法的<strong>分离</strong>（GP <strong>vs.</strong> OOP）。</p><p>C++标准库以头文件的形式呈现：</p><ul><li>新式C++头文件不带<code>.h</code> 后缀，如<code>#include&lt;vector&gt;</code></li><li>旧式C++头文件带<code>.h</code> 后缀，如<code>#include&lt;stdio.h&gt;</code></li><li>新式头文件内的组件封装于<code>namespace std</code></li><li>旧式头文件内的组件不封装于<code>namespace std</code></li></ul><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><ol><li>分配器（Allocators）：内存管理。</li><li>迭代器（Iterators）：泛化的指针，算法通过迭代器访问容器中的数据。</li><li>容器（Containers）：封装了大量常用的数据结构。</li><li>算法（Algorithms）：定义了一些常用算法，处理数据。</li><li>仿函数（Functors）：具有函数特质的对象（重载<code>operator()</code>的类）。</li><li>适配器（Adapters）：修改接口。</li></ol><p><img src="https://aweiii.coding.net/p/blog/d/img/git/raw/main/posts/STLComponents.png" alt="STLComponents"></p><h2 id="容器的分类与结构"><a href="#容器的分类与结构" class="headerlink" title="容器的分类与结构"></a>容器的分类与结构</h2><ul><li>顺序容器：<ul><li>Array：长度固定的数组，存储空间连续，支持随机访问</li><li>Vector：动态数组，存储空间连续，支持随机访问</li><li>Deque：双端队列，存储空间分段连续，支持随机访问</li><li>List：双向链表，存储空间不连续，不支持随机访问</li><li>Forward-List：单向链表，存储空间不连续，不支持随机访问</li></ul></li><li>关联容器：红黑树实现，有序。Multi的key可以重复<ul><li>Set&#x2F;MultiSet</li><li>Map&#x2F;MultiMap</li></ul></li><li>无序容器：哈希表（Separate Chaining）实现<ul><li>Unoedered Set&#x2F;MultiSet</li><li>Unoedered Map&#x2F;MultiMap</li></ul></li></ul><p><img src="https://aweiii.coding.net/p/blog/d/img/git/raw/main/posts/p1.png" alt="容器的分类与结构"></p><div class="note note-warning">            <ol><li><p>C++ Primer 中指出  <code>string</code> 是与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</p></li><li><p>deque由<strong>若干段</strong>连续空间串接而成，一旦有必要在deque的头部或尾端增加新的空间，便配置一段定量连续的空间，串接在deque的头部或尾端。deque的最大任务，就是在这些分段连续的空间上维护其整体连续的假象，并提供随机存取的接口。</p><p>deque首次插入一个元素，默认会动态分配512字节空间，当这512字节空间用完后，它会再动态分配自己另外的512字节空间，然后<strong>虚拟地</strong>连在一起。<strong>deque的随机访问和遍历性能比vector差。</strong></p></li></ol>          </div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="主要文件结构"><a href="#主要文件结构" class="headerlink" title="主要文件结构"></a>主要文件结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs stylus">MyTinySTL<br>│      alloc<span class="hljs-selector-class">.h</span>       <span class="hljs-comment">// 分配器</span><br>│      allocator<span class="hljs-selector-class">.h</span>   <br>│      construct<span class="hljs-selector-class">.h</span><br>│      uninitialized<span class="hljs-selector-class">.h</span><br>│      memory<span class="hljs-selector-class">.h</span><br>│      iterator<span class="hljs-selector-class">.h</span>    <span class="hljs-comment">// 迭代器</span><br>│      type_traits<span class="hljs-selector-class">.h</span> <span class="hljs-comment">// 萃取器</span><br>│      list<span class="hljs-selector-class">.h</span>        <span class="hljs-comment">// 容器</span><br>│      vector<span class="hljs-selector-class">.h</span><br>│      deque<span class="hljs-selector-class">.h</span><br>│      rb_tree<span class="hljs-selector-class">.h</span><br>│      set<span class="hljs-selector-class">.h</span><br>│      map<span class="hljs-selector-class">.h</span><br>│      hashtable<span class="hljs-selector-class">.h</span><br>│      unordered_map<span class="hljs-selector-class">.h</span><br>│      unordered_set<span class="hljs-selector-class">.h</span><br>│      astring<span class="hljs-selector-class">.h</span><br>│      basic_string<span class="hljs-selector-class">.h</span><br>│      queue<span class="hljs-selector-class">.h</span><br>│      stack<span class="hljs-selector-class">.h</span><br>│      algo<span class="hljs-selector-class">.h</span> <span class="hljs-comment">// 算法</span><br>│      algobase<span class="hljs-selector-class">.h</span><br>│      algorithm<span class="hljs-selector-class">.h</span><br>│      numeric<span class="hljs-selector-class">.h</span><br>│      heap_algo<span class="hljs-selector-class">.h</span><br>│      set_algo<span class="hljs-selector-class">.h</span><br>│      functional<span class="hljs-selector-class">.h</span>  <span class="hljs-comment">//仿函数</span><br>│      exceptdef<span class="hljs-selector-class">.h</span>   <span class="hljs-comment">//其他</span><br>│      util<span class="hljs-selector-class">.h</span><br>│<br>└─Test            <span class="hljs-comment">// 测试文件</span><br>    │  test<span class="hljs-selector-class">.cpp</span>      <span class="hljs-comment">// 程序入口</span><br>    │  algorithm_performance_test<span class="hljs-selector-class">.h</span><br>    │  algorithm_test<span class="hljs-selector-class">.h</span><br>    │  deque_test<span class="hljs-selector-class">.h</span><br>    │  list_test<span class="hljs-selector-class">.h</span><br>    │  map_test<span class="hljs-selector-class">.h</span><br>    │  queue_test<span class="hljs-selector-class">.h</span><br>    │  set_test<span class="hljs-selector-class">.h</span><br>    │  stack_test<span class="hljs-selector-class">.h</span><br>    │  string_test<span class="hljs-selector-class">.h</span><br>    │  test<span class="hljs-selector-class">.h</span><br>    │  unordered_map_test<span class="hljs-selector-class">.h</span><br>    │  unordered_set_test<span class="hljs-selector-class">.h</span><br>    │  vector_test<span class="hljs-selector-class">.h</span><br>    │  CMakeLists<span class="hljs-selector-class">.txt</span><br>    │  README.md<br></code></pre></td></tr></table></figure><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mystl::test;<br><br>  std::cout.<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">//算法测试: 包含了 mystl 的 81 个算法测试 algorithm_test.h</span><br>  <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>  <span class="hljs-comment">// 仅仅针对 sort, binary_search 做了性能测试 algorithm_performance_test.h</span><br>  algorithm_performance_test::<span class="hljs-built_in">algorithm_performance_test</span>();<br>  <span class="hljs-comment">// vector test : 测试 vector 的接口与 push_back 的性能</span><br>  vector_test::<span class="hljs-built_in">vector_test</span>();<br>  <span class="hljs-comment">// list test : 测试 list 的接口与 insert, sort 的性能</span><br>  list_test::<span class="hljs-built_in">list_test</span>();<br>  <span class="hljs-comment">// deque test : 测试 deque 的接口和 push_front/push_back 的性能</span><br>  deque_test::<span class="hljs-built_in">deque_test</span>();<br>  <span class="hljs-comment">// queue test : 测试 queue, priority_queue 的接口和它们 push 的性能</span><br>  queue_test::<span class="hljs-built_in">queue_test</span>();<br>  queue_test::<span class="hljs-built_in">priority_test</span>();<br>  <span class="hljs-comment">// stack test : 测试 stack 的接口 和 push 的性能</span><br>  stack_test::<span class="hljs-built_in">stack_test</span>();<br>  <span class="hljs-comment">// map test : 测试 map, multimap 的接口与它们 insert 的性能</span><br>  map_test::<span class="hljs-built_in">map_test</span>();<br>  map_test::<span class="hljs-built_in">multimap_test</span>();<br>  <span class="hljs-comment">// set test : 测试 set, multiset 的接口与它们 insert 的性能</span><br>  set_test::<span class="hljs-built_in">set_test</span>();<br>  set_test::<span class="hljs-built_in">multiset_test</span>();<br>  <span class="hljs-comment">// unordered_map test : 测试 unordered_map, unordered_multimap 的接口与它们 insert 的性能</span><br>  unordered_map_test::<span class="hljs-built_in">unordered_map_test</span>();<br>  unordered_map_test::<span class="hljs-built_in">unordered_multimap_test</span>();<br>  <span class="hljs-comment">// unordered_set test : 测试 unordered_set, unordered_multiset 的接口与它们 insert 的性能</span><br>  unordered_set_test::<span class="hljs-built_in">unordered_set_test</span>();<br>  unordered_set_test::<span class="hljs-built_in">unordered_multiset_test</span>();<br>  <span class="hljs-comment">// string test : 测试 string 的接口和 insert 的性能</span><br>  string_test::<span class="hljs-built_in">string_test</span>();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_MSC_VER) &amp;&amp; defined(_DEBUG)</span><br>  _CrtDumpMemoryLeaks();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// check memory leaks</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于宏的两点：</p><ol><li><p>特殊符号 <code>#</code> 和 <code>##</code> </p><p><code>#</code> ： 预处理时，将<code>#</code>后连接的实参字符串化</p><p><code>##</code> ：一种分隔连接方式，它的作用是先分隔，然后进行强制连接。在普通的宏定义中，预处理器一般把空格解释成分段标志，对于每一段和前面比较，相同的就被替换。但是这样做的结果是，被替换段之间存在一些空格。如果我们不希望出现这些空格，就可以通过添加一些<code>##</code>来替代空格。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE1(type,name)   type name_##type##_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE2(type,name)   type name##_##type##_type</span><br><br><span class="hljs-built_in">TYPE1</span>(<span class="hljs-type">int</span>, c); <span class="hljs-comment">// int 　name_int_type; (因为##号将后面分为 name_ 、type 、 _type三组，替换后强制连接)</span><br><span class="hljs-built_in">TYPE2</span>(<span class="hljs-type">int</span>, d); <span class="hljs-comment">// int 　d_int_type;    (因为##号将后面分为 name、_、type 、_type四组，替换后强制连接)</span><br></code></pre></td></tr></table></figure></li><li><p>宏定义中的<code>do&#123; &#125;while(0)</code></p><p>使用do{…}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 测试案例的类名，替换为 test_case_TEST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TESTCASE_NAME(testcase_name) \</span><br><span class="hljs-meta">    testcase_name##_TEST</span><br><br><span class="hljs-comment">// 使用宏定义掩盖复杂的测试样例封装过程，把 TEXT 中的测试案例放到单元测试中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYTINYSTL_TEST_(testcase_name)                        \</span><br><span class="hljs-meta">class TESTCASE_NAME(testcase_name) : public TestCase &#123;        \</span><br><span class="hljs-meta">public:                                                       \</span><br><span class="hljs-meta">    TESTCASE_NAME(testcase_name)(const char* case_name)       \</span><br><span class="hljs-meta">        : TestCase(case_name) &#123;&#125;;                             \</span><br><span class="hljs-meta">    virtual void Run();                                       \</span><br><span class="hljs-meta">private:                                                      \</span><br><span class="hljs-meta">    static TestCase* const testcase_;                         \</span><br><span class="hljs-meta">&#125;;                                                            \</span><br><span class="hljs-meta">                                                              \</span><br><span class="hljs-meta">TestCase* const TESTCASE_NAME(testcase_name)                  \</span><br><span class="hljs-meta">    ::testcase_ = UnitTest::GetInstance()-&gt;RegisterTestCase(  \</span><br><span class="hljs-meta">        new TESTCASE_NAME(testcase_name)(#testcase_name));    \</span><br><span class="hljs-meta">void TESTCASE_NAME(testcase_name)::Run()</span><br><br><span class="hljs-comment">// 简单测试的宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST(testcase_name) \</span><br><span class="hljs-meta">  MYTINYSTL_TEST_(testcase_name)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Run()后边没有写实现，是为了用宏定义将测试用例放入到 Run 的实现里，例如：</span><br><span class="hljs-comment">TEST(AddTestDemo)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">EXPECT_EQ(3, Add(1, 2));</span><br><span class="hljs-comment">EXPECT_EQ(2, Add(1, 1));</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">上述代码将 &#123; EXPECT_EQ(3, Add(1, 2)); EXPECT_EQ(2, Add(1, 1)); &#125; 接到 Run() 的后面</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>预处理阶段，上述代码在<code>TEST</code> 处展开后，<code>TEST</code> 后面<code>&#123;...&#125;</code> 的内容将拼接到 <code>Run()</code> 后，成为<code>Run()</code> 的实现。</p><p><code>MYTINYSTL_TEST_(testcase_name)</code> 展开后声明一个名为 <code>testcase_name_TEST</code> 的类（<code>testcase_name</code> 是形参），13行声明了一个静态指针常量成员，指向一个测试用例，16行对该静态成员进行定义，并将其加入到用例集合中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/qq_40571533/article/details/102558371?spm=1001.2014.3001.5502">MyTinySTL阅读笔记—概述_xiaoxiao涛的博客-CSDN博客_mytinystl源码分析</a></p><p>[2] <a href="https://github.com/Alinshans/MyTinySTL">Alinshans&#x2F;MyTinySTL: Achieve a tiny STL in C++11 (github.com)</a></p><p>[3] <a href="https://github.com/Alinshans/MyTinySTL/wiki">Home · Alinshans&#x2F;MyTinySTL Wiki (github.com)</a></p><p>[4] <a href="https://www.cnblogs.com/Anker/p/3418792.html">C语言宏高级用法 总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中虚函数、虚继承内存模型</title>
    <link href="/posts/3e911f6d/"/>
    <url>/posts/3e911f6d/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>转自：<a href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p>          </div><blockquote><p>C++中虚函数、虚继承的内存模型是一个经典问题，其实现依赖于编译器，但其主要原理大体相同。本文以问题导向的方式，详细介绍了g++中虚函数和虚继承的内存模型及其原理。</p></blockquote><h1 id="1-多态类型"><a href="#1-多态类型" class="headerlink" title="1 多态类型"></a>1 多态类型</h1><p>在C++中，多态类型是指声明或者继承了至少一个虚函数的类型，反之则为非多态类型。<br>对于非多态类型的变量，其类型信息都可以在编译时确定。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br>...<br><br>A a;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>();  <span class="hljs-comment">// 可以在编译时确定a的类型为A</span><br>a.<span class="hljs-built_in">foo</span>();     <span class="hljs-comment">// 可以在编译时确定A::foo在内存中的地址</span><br><span class="hljs-built_in">sizeof</span>(a);   <span class="hljs-comment">// 尽管A为空，但由于需要在内存中确定a的地址，因此A类型对象所占空间为1个字节</span><br></code></pre></td></tr></table></figure><p>而对于多态类型，一些信息必须延迟到运行时才可以确定，例如它的实际类型、所调用的虚函数的地址等。下面的这个例子中，类型<code>B</code>继承了声明有虚函数的类型<code>A</code>，因此<code>A</code>和<code>B</code>都是多态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 声明虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-comment">// 隐式继承了虚函数</span><br>&#125;;<br><br>...<br><br>B b&#123;&#125;;<br>A&amp; a_rb = b; <span class="hljs-comment">// 将b绑定到A的左值引用a_rb上</span><br><br><span class="hljs-built_in">typeid</span>(<span class="hljs-keyword">decltype</span>(a_rb)).<span class="hljs-built_in">name</span>(); <span class="hljs-comment">// decltype产生的是编译时即可确定的声明类型，因此为A</span><br><span class="hljs-built_in">typeid</span>(a_rb).<span class="hljs-built_in">name</span>()；  <span class="hljs-comment">// 由于a_rb是多态类型的glvalue，typeid在运行时计算，因此为B</span><br><br>a_rb.<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// 这里调用的是B中的foo，其函数地址是运行时确定的</span><br><span class="hljs-built_in">sizeof</span>(b);   <span class="hljs-comment">// 这里的sizeof是编译器决定的，通常为8 (64位)</span><br></code></pre></td></tr></table></figure><h1 id="2-虚函数的内存模型"><a href="#2-虚函数的内存模型" class="headerlink" title="2 虚函数的内存模型"></a>2 虚函数的内存模型</h1><p>我们可以用基类型<code>A</code>的引用或者指针持有实际类型为派生类<code>B</code>的对象，这意味着，编译时我们无法通过其声明类型来确定其实际类型，也就无法确定应该调用哪个具体的虚函数。考虑到程序中的每个函数都在内存中有着唯一的地址，我们可以将具体函数的地址作为成员变量，存放在对象之中，这样就可以在运行时，通过访问这个成员变量，获取到实际类型虚函数的地址。</p><h2 id="2-1-单继承内存模型"><a href="#2-1-单继承内存模型" class="headerlink" title="2.1 单继承内存模型"></a>2.1 单继承内存模型</h2><p>现代的C++编译器都采用了<strong>表格驱动</strong>的对象模型。具体来说，对于每一个多态类型，其所有的虚函数的地址都以一个表格的方式存放在一起，每个函数的偏移量在基类型和导出类型中均相同，这使得虚函数相对于表格首地址的偏移量在可以在编译时确定。虚函数表格的首地址储存在每一个对象之中，称为虚(表)指针(vptr)或者虚函数指针(vfptr)，这个虚指针始终位于对象的起始地址。使用多态类型的引用或指针调用虚函数时，首先通过虚指针和偏移量计算出虚函数的地址，然后进行调用。<br>例如，有如下所示的类型<code>A</code>和<code>B</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;; <span class="hljs-comment">// 重写f0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>它们的对象模型和虚表模型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br> <span class="hljs-function">object                                            A <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 - vptr_A --------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 - <span class="hljs-type">int</span> ax                                    |    <span class="hljs-title">A::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +--------------+</span><br><span class="hljs-function">                                                   |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function"></span><br><span class="hljs-function">struct B</span><br><span class="hljs-function"> object                                         </span><br><span class="hljs-function">     <span class="hljs-number">0</span> - struct A                                  B VTable (不完整)</span><br><span class="hljs-function">     <span class="hljs-number">0</span> -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     <span class="hljs-number">8</span> -   int ax                                  |    B::f0()   |</span><br><span class="hljs-function">    <span class="hljs-number">12</span> - int bx                                    +--------------+</span><br><span class="hljs-function">sizeof(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>注意到，由于<code>B</code>重写了方法<code>f0()</code>，因此它的虚表在同样的位置，将<code>A::f0()</code>覆盖为<code>B::f0()</code>。当发生<code>f0()</code>函数调用时，对于实际类型为<code>A</code>的对象，其VTable偏移量为<code>offset0</code>的位置为<code>A::f0()</code>， 对于实际类型为<code>B</code>的对象，对应位置为<code>B::f0()</code>，这样就实现了运行时虚函数函数地址的正确选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>B b;<br>A &amp;a_ra = a;<br>A &amp;a_rb = b;<br>a_ra.<span class="hljs-built_in">f0</span>(); <span class="hljs-comment">// call (a_ra-&gt;vptr_A + offset0) --&gt; A::f0()</span><br>a_rb.<span class="hljs-built_in">f0</span>(); <span class="hljs-comment">// call (a_rb-&gt;vptr_A + 0ffset0) --&gt; B::f0()</span><br></code></pre></td></tr></table></figure><p>在以上的例子中，<code>B</code>中虚函数都已经在<code>A</code>中声明过，如果类型<code>B</code>中出现了基类型<code>A</code>中没有的虚函数，新的虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。例如<code>B</code>中新增加了函数<code>f2()</code>，虚函数表变化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br> object                                         <br>     <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                                  <span class="hljs-function">B <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 -   <span class="hljs-type">int</span> ax                                  |    <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function">    12 - <span class="hljs-type">int</span> bx                                    +--------------+</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function">                                                   |    B::f2()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time Type Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前，所示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                                          <span class="hljs-function">B <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function"> object                                            +--------------+</span><br><span class="hljs-function">     0 - <span class="hljs-keyword">struct</span> A                                  |  RTTI <span class="hljs-keyword">for</span> B  |</span><br><span class="hljs-function">     0 -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 -   <span class="hljs-type">int</span> ax                                  |    <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function">    12 - <span class="hljs-type">int</span> bx                                    +--------------+</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function">                                                   |    B::f2()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>现在的虚表中，不仅含有函数地址，还含有RTTI的地址，之后还会加入许多新项目。虚表中的每一项都称作一个实体(entity)。<br>上述的解决方案，可以很好的处理单链继承的情况。在单链继承中，每一个派生类型都包含了其基类型的数据以及虚函数，这些虚函数可以按照继承顺序，依次排列在同一张虚表之中，因此只需要一个虚指针即可。并且由于每一个派生类都包含它的直接基类，且没有第二个直接基类，因此其数据在内存中也是线性排布的，这意味着实际类型与它所有的基类型都有着相同的起始地址。例如，<code>B</code>继承<code>A</code>，<code>C</code>继承<code>B</code>，它们的定义和内存模型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">int</span> cx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>内存模型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                      C VTable（不完整)<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                                              +------------+<br>object                                                | RTTI <span class="hljs-keyword">for</span> C |<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                            +-------&gt; +------------+<br>    <span class="hljs-number">0</span> -   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                          |         |   C::<span class="hljs-built_in">f0</span>()  |<br>    <span class="hljs-number">0</span> -     vptr_A -------------------------+         +------------+<br>    <span class="hljs-number">8</span> -     <span class="hljs-type">int</span> ax                                    |   B::<span class="hljs-built_in">f1</span>()  |<br>   <span class="hljs-number">12</span> -   <span class="hljs-type">int</span> bx                                      +------------+<br>   <span class="hljs-number">16</span> - <span class="hljs-type">int</span> cx                                        |   C::<span class="hljs-built_in">f2</span>()  |<br><span class="hljs-built_in">sizeof</span>(C): <span class="hljs-number">24</span>    align: <span class="hljs-number">8</span>                             +------------+<br></code></pre></td></tr></table></figure><p>从上图可以看出，使用一个类型<code>A</code>或<code>B</code>的引用持有实际类型为<code>C</code>的对象，它的起始地址仍然指向<code>C</code>的起始地址，这意味着单链继承的情况下，动态向下转换和向上转换时，不需要对this指针的地址做出任何修改，只需要对其重新“解释”。<br>然而，并非所有派生类都是单链继承的，它们的起始地址和其基类的起始地址不一定始终相同。</p><h2 id="2-2-多继承内存模型"><a href="#2-2-多继承内存模型" class="headerlink" title="2.2 多继承内存模型"></a>2.2 多继承内存模型</h2><p>假设类型<code>C</code>同时继承了两个独立的基类<code>A</code>和<code>B</code>， 它们的定义关系如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-type">int</span> bx;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">int</span> cx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>与单链继承不同，由于<code>A</code>和<code>B</code>完全独立，它们的虚函数没有顺序关系，即<code>f0</code>和<code>f1</code>有着相同对虚表起始位置的偏移量，不可以顺序排布。 并且<code>A</code>和<code>B</code>中的成员变量也是无关的，因此基类间也不具有包含关系。这使得<code>A</code>和<code>B</code>在<code>C</code>中必须要处于两个不相交的区域中，同时需要有两个虚指针分别对它们虚函数进行索引。 其内存布局如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                <span class="hljs-function">C <span class="hljs-title">Vtable</span> <span class="hljs-params">(<span class="hljs-number">7</span> entities)</span></span><br><span class="hljs-function">                                                +--------------------+</span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> C                                        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span>  |</span><br><span class="hljs-function">object                                          +--------------------+</span><br><span class="hljs-function">    0 - <span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-params">(primary base)</span>                 |     RTTI <span class="hljs-keyword">for</span> C     |</span><br><span class="hljs-function">    0 -   vptr_A -----------------------------&gt; +--------------------+       </span><br><span class="hljs-function">    8 -   <span class="hljs-type">int</span> ax                                |       <span class="hljs-title">C::f0</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   16 - <span class="hljs-keyword">struct</span> B                                +--------------------+</span><br><span class="hljs-function">   16 -   vptr_B ----------------------+        |       <span class="hljs-title">C::f1</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   24 -   <span class="hljs-type">int</span> bx                       |        +--------------------+</span><br><span class="hljs-function">   28 - <span class="hljs-type">int</span> cx                         |        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">-16</span>)</span>|</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(C)</span>: <span class="hljs-number">32</span>    align: <span class="hljs-number">8</span>              |        +--------------------+</span><br><span class="hljs-function">                                       |        |     RTTI for C     |</span><br><span class="hljs-function">                                       +------&gt; +--------------------+</span><br><span class="hljs-function">                                                |    Thunk C::f1()   |</span><br><span class="hljs-function">                                                +--------------------+</span><br></code></pre></td></tr></table></figure><p>在上图所示的布局中，<code>C</code>将<code>A</code>作为主基类，也就是将它虚函数“并入”<code>A</code>的虚函数表之中，并将<code>A</code>的虚指针作为<code>C</code>的内存起始地址。<br>而类型<code>B</code>的虚指针<code>vptr_B</code>并不能直接指向虚表中的第4个实体，这是因为<code>vptr_B</code>所指向的虚表区域，在格式上必须也是一个完整的虚表。因此，需要为<code>vptr_B</code>创建对应的虚表放在虚表A的部分之后 。<br>在上图中，出现了两个“新”的实体，一个是<code>offset_to_top</code>，另一个是<code>Thunk</code>。<br>在多继承中，由于不同的基类起点可能处于不同的位置，因此当需要将它们转化为实际类型时，<code>this</code>指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体<code>offset_to_top</code>表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让<code>this</code>指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体<code>offset_to_top</code>也会存在于每一个多态类型之中。<br>而实体<code>Thunk</code>又是什么呢？如果不考虑这个<code>Thunk</code>，这里应该存放函数<code>C::f1()</code>的地址。然而，dump虚表可以看到，<code>Thunk C::f1()</code>和<code>C::f1()</code>的地址并不一样。<br>为了弄清楚<code>Thunk</code>是什么，我们首先要注意到，如果一个类型<code>B</code> 的引用持有了实际类型为<code>C</code>的变量，这个引用的起始地址在<code>C+16</code>处。当它调用由类型<code>C</code>重写的函数<code>f1()</code>时，如果直接使用<code>this</code>指针调用<code>C::f1()</code>会由于<code>this</code>指针的地址多出16字节的偏移量导致错误。 因此在调用之前，this指针必须要被调整至正确的位置 。这里的<code>Thunk</code>起到的就是这个作用：首先将<code>this</code>指针调整到正确的位置，即减少16字节偏移量，然后再去调用函数<code>C::f1()</code>。</p><h2 id="2-3-构造与析构过程"><a href="#2-3-构造与析构过程" class="headerlink" title="2.3 构造与析构过程"></a>2.3 构造与析构过程</h2><p>在多态类型的构造和析构过程中，所调用的虚函数并不是最终的实际类型的对应函数，而是当前已经创建了的(或尚未析构的)类型的对应函数。这句话比较绕口，我们通过一个例子来说明。如下所示的两个类型<code>A</code>和<code>B</code>， 它们在构造和析构时都会调用对应的虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">B</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br><br>    ~<span class="hljs-built_in">B</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">// 输出：ABBA</span><br></code></pre></td></tr></table></figure><p>运行上述程序，可以得到输出“ABBA”，表明程序依次调用了<code>A::A()</code>、<code>B::B()</code>、<code>B::~B()</code>、<code>A::~A()</code>。直观上理解，在构造<code>A</code>时，<code>B</code>中的数据还没有创建，因此B重写的虚函数当然不可使用，因此应该调用<code>A</code>中的版本；反过来，析构的时候，由于<code>B</code>先析构，在<code>B</code>析构之后，<code>B</code>中的函数当然也不可用，因此也应该调用<code>A</code>中的版本。<br>在程序运行中，这一过程是通过动态的修改对象的虚指针实现的。<br>根据C++中继承类的构造顺序，首先基类<code>A</code>被构造。在构造<code>A</code>时， 对象自身的虚指针指向<code>A</code>的虚表。由于<code>A</code>的虚表中，<code>f0()</code>的位置保存着<code>A::f0()</code>的地址，因此<code>A::f0()</code>被调用。在<code>A</code>的构造结束后，<code>B</code>的构造启动，此时虚指针被修改为指向<code>B</code>的虚表。析构过程与此相反。</p><h1 id="3-虚继承内存模型"><a href="#3-虚继承内存模型" class="headerlink" title="3 虚继承内存模型"></a>3 虚继承内存模型</h1><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。<br>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p><h2 id="3-1-菱形继承的内存模型"><a href="#3-1-菱形继承的内存模型" class="headerlink" title="3.1 菱形继承的内存模型"></a>3.1 菱形继承的内存模型</h2><p>下面展示了一个经典的菱形虚继承关系，为了避免重复包含<code>A</code>中的成员，类型<code>B</code>和<code>C</code>分别虚继承<code>A</code>。类型<code>D</code>继承了<code>B</code>和<code>C</code>。依据其继承方式的不同，<code>D</code>中的<code>B</code>、<code>C</code>的偏移量可以在编译时确定，而<code>A</code>的偏移量在运行时确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/****************************/</span><br>&#123;                                     <span class="hljs-comment">/*                          */</span><br>    <span class="hljs-type">int</span> bx;                           <span class="hljs-comment">/*             A            */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*           v/ \v          */</span><br>&#125;;                                    <span class="hljs-comment">/*           /   \          */</span> <br>                                      <span class="hljs-comment">/*          B     C         */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/*           \   /          */</span><br>&#123;                                     <span class="hljs-comment">/*            \ /           */</span><br>    <span class="hljs-type">int</span> cx;                           <span class="hljs-comment">/*             D            */</span> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*                          */</span><br>&#125;;                                    <span class="hljs-comment">/****************************/</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-type">int</span> dx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先对类型<code>A</code>的内存模型进行分析。由于虚继承影响的是子类，不会对父类造成影响，因此A的内存布局和虚表都没有改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                   A VTable<br>                                                   +------------------+<br>                                                   | <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>) |<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                                           +------------------+<br> object                                            |    RTTI <span class="hljs-keyword">for</span> A    |<br>     <span class="hljs-number">0</span> - vptr_A --------------------------------&gt;  +------------------+<br>     <span class="hljs-number">8</span> - <span class="hljs-type">int</span> ax                                    |      A::<span class="hljs-built_in">f0</span>()     |<br><span class="hljs-built_in">sizeof</span>(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +------------------+<br>                                                   |      A::<span class="hljs-built_in">bar</span>()    |<br>                                                   +------------------+<br></code></pre></td></tr></table></figure><p>类型<code>B</code>类和类型<code>C</code>没有本质的区别，因此只分析类型<code>B</code>。下图为类型B的内存模型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          B VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">16</span>)  |<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                                  +---------------------+<br>object                                    |      RTTI <span class="hljs-keyword">for</span> B     |<br>    <span class="hljs-number">0</span> - vptr_B -------------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> - <span class="hljs-type">int</span> bx                            |       B::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_A --------------+          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> ax               |          +---------------------+         |<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-16</span>) |o----+   |<br>                               |          +---------------------+     |   |<br>                               |          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-16</span>) |     |   |<br>                               |          +---------------------+     |   |<br>                               |          |      RTTI <span class="hljs-keyword">for</span> B     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+</span><br></code></pre></td></tr></table></figure><p>对于形式类型为<code>B</code>的引用，在编译时，无法确定它的基类<code>A</code>它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为<strong>vbase_offset</strong>，位于<strong>offset_to_top</strong>上方。<br>除此之外，如果在<code>B</code>中调用<code>A</code>声明且<code>B</code>没有重写的函数，由于<code>A</code>的偏移量无法在编译时确定，而这些函数的调用由必须在<code>A</code>的偏移量确定之后进行， 因此这些函数的调用相当于使用<code>A</code>的引用调用。也因此，当使用虚基类<code>A</code>的引用调用重载函数时 ，每一个函数对<code>this</code>指针的偏移量调整都可能不同，它们被记录在镜像位置的<code>vcall_offset</code>中。例如，调用<code>A::bar()</code>时，<code>this</code>指针指向的是<code>vptr_A</code>，正是函数所属的类<code>A</code>的位置，因此不需要调整，即<code>vcall_offset(0)</code>；而<code>B::f0()</code>是由类型<code>B</code>实现的， 因此需要将<code>this</code>指针向前调整<code>16</code>字节。<br>对于类型<code>D</code>，它的虚表更为复杂，但虚表中的实体我们都已熟悉。 以下为<code>D</code>的内存模型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          D VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">32</span>)  |<br>                                          +---------------------+<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>                                  |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br>object                                    +---------------------+<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> (primary base)           |      RTTI <span class="hljs-keyword">for</span> D     |<br>    <span class="hljs-number">0</span> -   vptr_B  ----------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> -   <span class="hljs-type">int</span> bx                          |       D::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_C  ------------------+     |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">16</span>)  |<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> cx                    |     +---------------------+<br>   <span class="hljs-number">28</span> - <span class="hljs-type">int</span> dx                      |     |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-16</span>) |<br>   <span class="hljs-number">32</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> (<span class="hljs-keyword">virtual</span> base)     |     +---------------------+<br>   <span class="hljs-number">32</span> -   vptr_A --------------+    |     |      RTTI <span class="hljs-keyword">for</span> D     |<br>   <span class="hljs-number">40</span> -   <span class="hljs-type">int</span> ax               |    +---&gt; +---------------------+<br><span class="hljs-built_in">sizeof</span>(D): <span class="hljs-number">48</span>    align: <span class="hljs-number">8</span>      |          |       D::<span class="hljs-built_in">f0</span>()       |<br>                               |          +---------------------+<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>                               |          +---------------------+         |<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-32</span>) |o----+   |<br>                               |          +---------------------+     |   |<br>                               |          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-32</span>) |     |   |<br>                               |          +---------------------+     |   |<br>                               |          |      RTTI <span class="hljs-keyword">for</span> D     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">D::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+ </span><br></code></pre></td></tr></table></figure><h2 id="3-2-析构过程"><a href="#3-2-析构过程" class="headerlink" title="3.2 析构过程"></a>3.2 析构过程</h2><p>与非虚继承相似，通过虚继承产生的派生类在构造和析构时，所调用的虚函数只是当前阶段的的虚表中对应的函数。一个问题也就由此产生，由于在虚基类的不同的派生类中，虚基类相对于该类型的偏移量是可以不同的，如果直接使用2.3中的方法，直接用继承虚基类的类型自身的虚表作为构建该类时使用的虚表，会由于偏移量的不同，导致无法正确获取虚基类中的对象。<br>这个描述比较抽象拗口，我们通过3.1中的菱形继承的例子进行解释。四个类型<code>A</code>，<code>B</code>，<code>C</code>和<code>D</code>的继承关系如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/****************************/</span><br>&#123;                                     <span class="hljs-comment">/*                          */</span><br>    <span class="hljs-type">int</span> bx;                           <span class="hljs-comment">/*             A            */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*           v/ \v          */</span><br>&#125;;                                    <span class="hljs-comment">/*           /   \          */</span><br>                                      <span class="hljs-comment">/*          B     C         */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/*           \   /          */</span><br>&#123;                                     <span class="hljs-comment">/*            \ /           */</span><br>    <span class="hljs-type">int</span> cx;                           <span class="hljs-comment">/*             D            */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;              <span class="hljs-comment">/*                          */</span><br>&#125;;                                    <span class="hljs-comment">/****************************/</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-type">int</span> dx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>观察实际类型为<code>B</code>和实际类型为<code>D</code>对象的内存布局可以发现，如果实际类型为<code>B</code>，虚基类A对B的首地址的偏移量为16；若实际类型为<code>D</code>，则其中A对B首地址的偏移量为32。这明显与<code>B</code>自身的虚表冲突。如果构建<code>D::B</code>时还采用的是<code>B</code>自身的虚表，会由于偏移量的不同导致错误。<br>这一问题的解决方法其实很粗暴，那就是在对象构造、析构阶段，会用到多少种虚表，会用到多少种虚指针就生成多少种虚指针。在构造或析构时，“按需分配”。<br>例如，这里的类型<code>D</code>是类型<code>B</code>和<code>C</code>的子类，而<code>B</code>和<code>C</code>虚继承了类型<code>A</code>。 这种继承关系会导致<code>D</code>内部含有的<code>B</code>(称作<code>B-in-D</code>)、<code>C</code>(称作<code>C-in-D</code>)的虚表与<code>B</code>、<code>C</code>的虚表不同。 因此，这需要生成两张新的虚表，即<code>B-in-D</code>和<code>C-in-D</code>的虚表。<br>由于<code>B-in-D</code>也是<code>B</code>类型的一种布局，<code>B</code>的一个虚表对应两个虚指针，分别是<code>vptr_B</code>和<code>vptr_A</code>，因此它也有两个着两个虚指针。在构造或析构<code>D::B</code>时，其对象的内存布局和虚表布局如图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          B-in-D VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">32</span>)  |<br>                                          +---------------------+<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> (Constructing/Deconstructing B)  |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br>object                                    +---------------------+<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> (primary base)           |      RTTI <span class="hljs-keyword">for</span> B     |<br>    <span class="hljs-number">0</span> -   vptr_B -----------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> -   <span class="hljs-type">int</span> bx                          |       B::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_C                          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> cx                          +---------------------+         |<br>   <span class="hljs-number">28</span> - <span class="hljs-type">int</span> dx                            |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-32</span>) |o----+   |<br>   <span class="hljs-number">32</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> (<span class="hljs-keyword">virtual</span> base)           +---------------------+     |   |<br>   <span class="hljs-number">32</span> -   vptr_A --------------+          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-32</span>) |     |   |<br>   <span class="hljs-number">40</span> -   <span class="hljs-type">int</span> ax               |          +---------------------+     |   |<br><span class="hljs-built_in">sizeof</span>(D): <span class="hljs-number">48</span>    align: <span class="hljs-number">8</span>      |          |      RTTI <span class="hljs-keyword">for</span> B     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+</span><br></code></pre></td></tr></table></figure><p>同样的，在<code>C-in-D</code>中也会有两个虚指针，分别是<code>vptr_C</code>和<code>vptr_A</code>。此外，在最终的<code>D</code>中还有三个虚指针，总计7个不同的虚指针，它们指向3张虚表的7个不同位置。因此编译器为类型D总共生成了3个不同的虚表，和7个不同的虚指针。将这7个虚指针合并到一个表中，这个表就是**虚表的表(Virtual Table Table, VTT)**。显然，只有当一个类的父类是继承了虚基类的类型时，编译器才会为它创建VTT。<br>在构造和析构过程中，子类的构造函数或析构函数向基类传递一个合适的、指向VTT某个部分指针，使得父类的构造函数或析构函数获取到正确的虚表。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ul><li>虚函数地址通过虚指针索引的虚函数表在运行时确定；</li><li>虚表中不仅储存了虚函数的地址，还储存了类型<code>RTTI</code>的地址、距实际类型首地址偏移量等信息；</li><li>虚函数的调用可能涉及到<code>this</code>指针的变更，需要<code>Thunk</code>等方式实现；</li><li>对于虚基类的派生类，虚基类的偏移量由实际类型决定，因此在<strong>运行时才可以确定虚基类的地址</strong>；</li><li>在多态类型的构造和析构过程中，通过修改虚指针使其指向不同的虚表，可以实现在不同的阶段调用不同的虚函数；</li><li>对于虚继承的情况，由于同一类型虚表的虚表在不同具体类型中可以不同，在构造和析构时，需要通过<code>VTT</code>传递正确的虚表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>类相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/4a17b156/"/>
    <url>/posts/4a17b156/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
