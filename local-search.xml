<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>八股文之计算机网络</title>
    <link href="/posts/947f1ab2/"/>
    <url>/posts/947f1ab2/</url>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>得分点 协议栈自上而下依次为：<strong>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</strong><br>在计算机网络中要做到正确的数据交换，就必须提前约定好相应的规则。OSI七层模型是一个协议栈，就是为了<strong>统一计算机网络标准，方便数据的交换</strong>。它自上而下依次为：</p><ol><li>应用层：应用层是体系结构中的最高层，是应用<strong>进程间通信和交互的规则</strong>，进程指计算机中运行的程序。也是<strong>用户与应用程序之间的一个接口</strong>，操作程序（软件，Web应用），进而触发更下层的服务。 协议：<strong>HTTP、HTTPS、FTP、TFTP、SMTP</strong>等；</li><li>表示层：对从应用层获取到的数据报文数据进行<strong>格式处理、安全处理和压缩处理</strong>。 格式：JPEG、ASCll、加密格式等；</li><li>会话层：对当前主机进程和目标主机进程<strong>会话的建立、管理和终止行为</strong>；</li><li>传输层：对两台主机进程也就是应用层提供<strong>数据传输服务</strong>。定义了传输数据的<strong>进程端口号</strong>，负责数据包的<strong>排序、差错检验和流量控制等</strong>。 协议：<strong>UDP、TCP</strong>；</li><li>网络层：主要进行<strong>逻辑地址</strong>的查询。 协议：<strong>ICMP、IGMP、IP（IPv4、IPv6）</strong></li><li>数据链路层：建立<strong>相邻节点的逻辑连接</strong>，进行逻辑地址寻址、差错校验等。 协议：<strong>ARP、RARP、PPP 等</strong></li><li>物理层：物理层上数据的单位是Bit比特，数据的传输都是通过0（或1）比特流来实现的，而0（或1）比特流与<strong>电压的高低</strong>有关。负责了最底层数据传输的建立、传输和断开。</li></ol><h2 id="请你说说-TCP-x2F-IP-五层模型"><a href="#请你说说-TCP-x2F-IP-五层模型" class="headerlink" title="请你说说 TCP&#x2F;IP 五层模型"></a>请你说说 TCP&#x2F;IP 五层模型</h2><p>协议栈自上而下依次为：应用层、传输层、网络层、数据链路层、物理层。<br>五层协议体系结构结合了OSI模型和TCP&#x2F;IP模型的优点，既简洁又能将每一层描述清楚。在计算机网络中要做到正确的数据交换，就必须提前约定好相应的规则。它是一个协议栈，就是为了统一计算机网络标准，方便数据的交换。它自上而下依次为：</p><ol><li>应用层：应用层是体系结构中的最高层，定义了<strong>应用进程间通信和交互的规则</strong>。本层任务就是通过应用进程间的信息数据流通完成特定的网络应用（软件、Web应用等）。因为不同的应用程序都需要不同的应用层协议，所以应用层协议较多，如万维网应用的HTTP协议、电子邮件的SMTP协议、文件传送的FTP协议等。请将应用层交互的数据称为报文，以免产生概念的混淆。 协议：<strong>HTTP、HTTPS、FTP、TFTP、SMTP</strong>等； </li><li>传输层：运输层的任务是负责向<strong>两个计算机中进程之间的通信</strong>提供一种通用的数据传输服务，应用层通过运输层可以传输报文。通用是指不会针对特定的应用层协议进行详细的划分，多种应用层协议公用同一个运输层服务，所以运输层有<strong>复用</strong>的功能。当然也有<strong>分发</strong>的功能，指将接受到的信息分别交付到应用层不同的进程中。 协议：UDP、TCP </li><li>网络层：网络层的任务是负责<strong>为网络上不同的主机提供通信服务</strong>。在发送数据时，网络层将运输层产生的报文段或者用户数据报封装成分组或者包（packet）进行传送。由于网络层使用IP协议，所以分组或包（packet）也叫IP数据报，简称数据报。网络层还需要寻找合适的路由路线，让源主机运输层发送下来的数据报能通过路由器找到目的主机。 协议：ICMP、IGMP、IP（IPv4、IPv6）、ARP、RARP（七层模型中在数据链路层）</li><li>数据链路层：数据链路层简称链路层。两个节点传输数据时，<strong>链路层将网络层交下来的数据报组装成帧，在链路上传送帧</strong>。每一帧都包括数据和控制信息（同步信息、地址信息、差错控制等）。</li><li>物理层：物理层上数据的<strong>单位是Bit比特</strong>，数据的传输都是通过0（或1）比特流来实现的，而<strong>0（或1）比特流与电压的高低有关</strong>。物理层中比特流的传输不再加控制信息，需要注意的是比特流应从首部开始传送。</li></ol><h2 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h2><ol><li>应用层</li></ol><p>TCP&#x2F;IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。<br>应用层只需要专注于<strong>为用户提供应用功能</strong>，比如 <strong>HTTP、FTP、Telnet、DNS、SMTP</strong>等。<br><strong>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</strong></p><ol start="2"><li>传输层</li></ol><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：<strong>传输控制协议（TCP）和用户数据报协议（UDP）</strong>。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p><ol start="3"><li>网络层</li></ol><p>网络层对应 OSI 参考模型的网络层，主要负责<strong>相同或不同网络中计算机之间的通信</strong>。在网际互联层， IP 协议提供的是一个<strong>不可靠、无连接</strong>的数据报传递服务。网络层负责网络包的<strong>封装、分片、路由、转发</strong>。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p><ol start="4"><li>网络接口层</li></ol><p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它<strong>负责监视数据在主机和网络之间的交换</strong>。事实上，TCP&#x2F;IP 并未真正描述这一层的实现，而由参与互连的各<strong>网络使用自己的物理层和数据链路层协议</strong>，然后与 TCP&#x2F;IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p><h2 id="OSI-模型和-TCP-x2F-IP-模型异同比较"><a href="#OSI-模型和-TCP-x2F-IP-模型异同比较" class="headerlink" title="OSI 模型和 TCP&#x2F;IP 模型异同比较"></a>OSI 模型和 TCP&#x2F;IP 模型异同比较</h2><ol><li><p>相同点</p><ol><li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了<strong>层次</strong>结构。</li><li>都能够提供<strong>面向连接</strong>和<strong>无连接</strong>两种通信服务机制。</li></ol></li><li><p>不同点</p><ol><li>OSI 采用的七层模型； TCP&#x2F;IP 是四层结构。</li><li>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</li><li>OSI 先有模型，后有协议规范，适合于描述各种网络；TCP&#x2F;IP 是先有协议集然后建立模型，不适用于非 TCP&#x2F;IP 网络。</li><li>TCP&#x2F;IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</li><li>OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP&#x2F;IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</li></ol></li></ol><h2 id="OSI-和-TCP-x2F-IP-协议之间的对应关系"><a href="#OSI-和-TCP-x2F-IP-协议之间的对应关系" class="headerlink" title="OSI 和 TCP&#x2F;IP 协议之间的对应关系"></a>OSI 和 TCP&#x2F;IP 协议之间的对应关系</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091911960.png" alt="OSI 和 TCP/IP 协议之间的对应关系"></p><h2 id="为什么-TCP-x2F-IP-去除了表示层和会话层"><a href="#为什么-TCP-x2F-IP-去除了表示层和会话层" class="headerlink" title="为什么 TCP&#x2F;IP 去除了表示层和会话层"></a>为什么 TCP&#x2F;IP 去除了表示层和会话层</h2><p>OSI 参考模型在提出时，他们的理想是非常好的，但实际上，<strong>由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包</strong>，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的，例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP&#x2F;IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。</p><h2 id="数据如何在各层之间传输【数据的封装过程】"><a href="#数据如何在各层之间传输【数据的封装过程】" class="headerlink" title="数据如何在各层之间传输【数据的封装过程】"></a>数据如何在各层之间传输【数据的封装过程】</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091912873.png" alt="数据的封装过程"></p><ul><li>传输层，给应用数据前面增加了 TCP 头；</li><li>网络层，给 TCP 数据包前面增加了 IP 头；</li><li>网络接口层，给 IP 数据包前后分别增加了帧头和帧尾；</li></ul><h2 id="发送网络数据的时候，涉及几次内存拷贝操作？"><a href="#发送网络数据的时候，涉及几次内存拷贝操作？" class="headerlink" title="发送网络数据的时候，涉及几次内存拷贝操作？"></a>发送网络数据的时候，涉及几次内存拷贝操作？</h2><ol><li>第一次，调用发送数据的系统调用的时候，内核会申请一个<strong>内核态的 sk_buff</strong> 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>第二次，在使用 TCP 传输协议的情况下，<strong>从传输层进入网络层</strong>的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li><li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</li></ol><h2 id="从输入URL到网页显示，期间发生了什么"><a href="#从输入URL到网页显示，期间发生了什么" class="headerlink" title="从输入URL到网页显示，期间发生了什么"></a>从输入URL到网页显示，期间发生了什么</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091912384.png" alt="image.png"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091912300.png" alt="image.png"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091912106.png" alt="image.png"></p><ol><li>浏览器<strong>解析URL</strong>，URL中包含：访问数据协议，Web服务器名称和资源文件路径；浏览器对URL进行解析之后，确定<strong>Web服务器</strong>和<strong>文件名</strong>；</li><li>浏览器通过<strong>DNS获取到Web服务器的IP</strong>地址之后生成HTTP请求报文；</li><li>HTTP基于TCP传输协议，浏览器向服务器发送HTTP请求前先<strong>三次握手</strong>建立连接；</li><li>判断浏览器本地是否存在<strong>HTTP缓存</strong>，如果是强制缓存且在有效期内，则不发送HTTP请求，如果是HTTP协商缓存，则向服务器与服务器协商，若采用本地缓存，则服务器返回304；如果不在有效期内，发送<strong>HTTP请求</strong>；</li><li>如果请求参数有问题，服务器端返回404，如果服务器端出错返回500；</li><li>如果返回正常HTML文件，浏览器载入HTML代码，开始<strong>渲染页面</strong>同时获取HTML页面中图片、音频、视频、CSS、JS，在这期间获取到JS文件之后，会直接执行JS代码，阻塞浏览器渲染，因为渲染引擎和JS引擎互斥，不能同时工作，所以通常把Script标签放在body标签的底部，另外可以把多个访问小文件的请求合并成一个大的请求，减少HTTP请求；</li><li>渲染过程就是先将HTML转换成dom树，再将CSS样式转换成stylesheet，根据dom树和stylesheet创建布局树，对布局树进行分层，为每个图层生成绘制列表，再将图层分成图块，紧接着光栅化将图块转换成位图，最后合成绘制生成页面。</li></ol><h2 id="域名解析（DNS）工作流程"><a href="#域名解析（DNS）工作流程" class="headerlink" title="域名解析（DNS）工作流程"></a>域名解析（DNS）工作流程</h2><ol><li>客户端<strong>发起DNS请求</strong>，向本地DNS服务器请求该域名的ip地址；</li><li>本地DNS服务器接收到客户端的请求后，如果<strong>缓存列表</strong>找到该域名的ip地址，则直接返回该ip地址给客户端；如果没有，本地DNS服务器会向<strong>根域名服务器</strong>请求；</li><li>根域名服务器收到请求之后，会将请求解析域名的<strong>顶级域名服务器</strong>地址返回给本地DNS服务器；</li><li>本地DNS服务器收到响应后，转而向顶级域名服务器请求，顶级域名服务器返回<strong>权威DNS服务器</strong>地址；</li><li>本地DNS服务器向该权威DNS服务器发出请求，权威DNS服务器查询后将对应的ip地址告诉本地DNS服务器；</li><li>最后本地DNS服务器将该ip地址<strong>返回给客户端</strong>。</li></ol><h2 id="什么是端口"><a href="#什么是端口" class="headerlink" title="什么是端口"></a>什么是端口</h2><ol><li>概念：端口用一个16位端口号进行标识。即一个电脑允许有65535个不同的端口号，<strong>端口只具有本地意义</strong>，不同计算机上相同端口代表的服务是不同的；</li><li>常用默认端口：</li></ol><p>DNS：43<br>HTTP：80<br>HTTPS: 443<br>TCP：80<br>SQL：3306<br>redis：6379<br>SSH：22<br>tomcat：8080</p><ol start="3"><li>端口的作用：实现TCP、UDP的复用与分用<ol><li>不同的应用进程通过端口将数据传递给TCP和UDP，实现传输层的<strong>复用</strong>；</li><li>TCP和UDP接受到数据之后，根据端口号<strong>分发</strong>给不同的进程，实现传输层的<strong>分用</strong>。</li></ol></li><li>为什么不引入进程标识来代替端口？因为<strong>进程标识是动态创建与撤销的</strong>，时刻在变化，发送方不好确定该指定哪个进程标识符，而且不同操作系统的进程标识符的格式也不同。</li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h2><p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。<br>HTTP 是一个在计算机世界里专门在<strong>「两点」</strong>之间<strong>「传输」</strong>文字、图片、音频、视频等<strong>「超文本」</strong>数据的<strong>「约定和规范」</strong>。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>分为5类</p><ol><li>1xx，一般是表示请求成功，继续等待<strong>下一步</strong>请求 ， 例如 100</li><li>2xx：一般表示<strong>请求成功</strong><ol><li>200：请求成功，并返回请求体， 此请求一般会缓存</li><li>204：请求成功，不返回请求体 (一般是put&#x2F;delete请求)，默认情况下可以被缓存，响应头中会有一个Etag（强校验器）</li></ol></li><li>3xx：一般表示<strong>重定向</strong><ol><li>301：永久重定向，资源永久性的移到新网址，浏览器自动会进行url跳转，并且爬虫会收录新的url，但是URl跳转过程中可能会改变跳转方式</li><li>308：永久重定向，资源永久性的移到新网址，浏览器自动会进行url跳转，并且爬虫会收录新的url，与301相比，不会改变跳转请求方式</li><li>302：临时重定向，资源暂时性的移到新网址，进行url跳转，但是爬虫不会收录新的url，跳转时可能改变url请求方式</li><li>307：临时重定向，资源暂时性的移到新网址，进行url跳转，但是爬虫不会收录新的url，与302相比，不会改变跳转时请求url方法</li><li>304：表示资源未改变，可以使用<strong>本地缓存</strong></li></ol></li><li>4xx：一般表示<strong>客户端错误</strong><ol><li>400：表示url请求错误</li><li>401：表示客户端身份认证不正确</li><li>402：表示rul请求方法错误</li><li>403：请求正确，但是服务器拒绝提供服务，一般是访问权限不足</li><li>404：访问的资源可能永久或者暂时的丢失，一般成为坏链或死链</li></ol></li><li>5xx：一般表示<strong>服务器出错</strong><ol><li>500：服务器遇到意外情况</li><li>503：服务器处于不可接收状态，一般是服务器达到连接上限，停机维护</li><li>505：表示服务器使用的http版本不同，服务器不支持该版本</li></ol></li></ol><h2 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h2><ol><li>Host 字段</li></ol><p>客户端发送请求时，用来指定<strong>服务器的域名</strong>。</p><ol start="2"><li>Content-Length 字段</li></ol><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的<strong>数据长度</strong>。</p><ol start="3"><li>Connection 字段（Keep-Alive）</li></ol><p>Connection 字段最常用于客户端要求服务器使用 TCP <strong>持久连接</strong>，以便其他<strong>请求复用</strong>。</p><ol start="4"><li>Content-Encoding 字段</li></ol><p>Content-Encoding 字段说明<strong>数据的压缩方法</strong>。表示服务器返回的数据使用了什么压缩格式。</p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><ol><li>GET 的语义是<strong>从服务器获取指定的资源</strong>，POST 的语义是<strong>根据请求负荷（报文body）对指定的资源做出处理</strong>；</li><li>get有<strong>url长度限制</strong>（2048字节）而post没有；</li><li>get的参数是<strong>显式</strong>的，get的参数会附加在url之 中，以 “ ？ “分割url和传输数据，多个参数用 “&amp;”连接；而post是<strong>隐式</strong>的，post是放在请求体中；</li><li>get请求会<strong>保存</strong>在浏览器历史记录中，也可以保存在web服务器日志中； </li><li>get在浏览器回退时是<strong>无害</strong>的，而post会<strong>再次提交</strong>请求；</li><li>get请求只能进行url编码，而post支持多种编码方式；</li><li>get请求的参数数据类型只接受ASCII字符，而post没有限制。</li></ol><h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><h3 id="HTTP缓存技术有哪些"><a href="#HTTP缓存技术有哪些" class="headerlink" title="HTTP缓存技术有哪些"></a>HTTP缓存技术有哪些</h3><p>对于一些具有<strong>重复性的 HTTP 请求</strong>，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。<br>所以，<strong>避免发送 HTTP 请求的方法就是通过缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。<br>HTTP 缓存有两种实现方式，分别是<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的<strong>主动性在于浏览器这边</strong>。<br>返回的是 200 状态码，但在 size 项中标识的是<strong>from disk cache</strong>，就是使用了强制缓存。<br>强缓存是利用下面这两个 <strong>HTTP 响应头部（Response Header）字段</strong>实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><strong>Cache-Control</strong>， 是一个相对时间；</li><li><strong>Expires</strong>，是一个绝对时间；</li></ul><p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器<strong>第一次请求访问服务器资源</strong>时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了<strong>过期时间</strong>大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是与服务端协商之后，<strong>通过协商结果来判断是否使用本地缓存</strong>。<br>协商缓存可以基于两种头部来实现。<br>第一种：请求头部中的<strong>If-Modified-Since</strong>字段与响应头部中的<strong>Last-Modified</strong>字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 Last-Modified：标示这个响应资源的<strong>最后修改时间</strong>；</li><li>请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的 <strong>If-None-Match</strong>字段与响应头部中的<strong>ETag</strong> 字段，这两个字段的意思是：</p><ul><li>响应头部中 Etag：<strong>唯一标识响应资源</strong>；</li><li>请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是<strong>基于时间实现</strong>的，第二种实现方式是基于一个<strong>唯一标识实现</strong>的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于<strong>时间篡改</strong>导致的不可靠问题。</p><p>ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的<strong>粒度是秒级</strong>的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><h2 id="HTTP-x2F-1-1的特性"><a href="#HTTP-x2F-1-1的特性" class="headerlink" title="HTTP&#x2F;1.1的特性"></a>HTTP&#x2F;1.1的特性</h2><ol><li>优点<ol><li>简单，header + body，易于理解</li><li>灵活和易于扩展，允许自定义和扩充</li><li>应用广泛和跨平台</li></ol></li><li>缺点<ol><li>无状态，它在完成有关联性的操作时会非常麻烦（解决方法：cookie）</li><li>明文传输</li><li>不安全<ol><li>明文传输</li><li>不验证通信放信息</li><li>无法验证报文完整性</li></ol></li></ol></li><li>HTTP1.1 性能<ol><li>长连接</li><li>队头阻塞</li></ol></li></ol><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><ol><li><p>区别</p><ol><li>HTTP 是超文本传输协议，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 <strong>SSL&#x2F;TLS 安全协议</strong>，使得报文能够加密传输。</li><li>HTTP <strong>连接建立</strong>相对简单， <strong>TCP 三次握手</strong>之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 <strong>SSL&#x2F;TLS</strong> 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）<strong>申请数字证书</strong>，来保证服务器的身份是可信的。</li></ol></li><li><p>解决了哪些问题</p><ol><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ol></li><li><p>HTTPS 在 HTTP 与 TCP 层之间加入了 <strong>SSL&#x2F;TLS</strong> 协议，可以很好的解决了上述的风险</p><ol><li>窃听风险：混合加密算法实现了机密性</li><li>篡改风险：摘要算法实现完整性</li><li>冒充风险：数字证书解决了冒充风险</li></ol></li></ol><p><strong>混合加密</strong></p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li></ul><p><strong>摘要算法+数字签名</strong></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091913040.png" alt="image.png"></p><p>哈希获取摘要，私钥加密摘要获取数字签名。</p><p><strong>数字证书</strong><br>由CA颁布</p><h2 id="HTTPS如何建立连接"><a href="#HTTPS如何建立连接" class="headerlink" title="HTTPS如何建立连接"></a>HTTPS如何建立连接</h2><ol><li>TCP三次握手</li><li>SSL&#x2F;TLS 四次握手</li></ol><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p><strong>SSL&#x2F;TLS 协议建立的详细流程：</strong></p><ol><li>ClientHello</li></ol><p>首先，由客户端向服务器发起<strong>加密通信请求</strong>，也就是 <strong>ClientHello</strong> 请求。<br>在这一步，客户端主要向服务器发送以下信息：</p><ol><li>客户端支持的 <strong>SSL&#x2F;TLS 协议版本</strong>，如 TLS 1.2 版本。</li><li>客户端生产的<strong>随机数（Client Random）</strong>，后面用于生成「会话秘钥」条件之一。</li><li>客户端支持的<strong>密码套件列表</strong>，如 RSA 加密算法。</li><li>SeverHello</li></ol><p>服务器收到客户端请求后，向客户端发出响应，也就是 <strong>SeverHello</strong>。服务器回应的内容有如下内容：</p><ol><li><strong>确认 SSL&#x2F; TLS 协议版本</strong>，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的<strong>随机数（Server Random）</strong>，也是后面用于生产「会话秘钥」条件之一。</li><li><strong>确认的密码套件列表</strong>，如 RSA 加密算法。</li><li>服务器的<strong>数字证书</strong>。</li></ol><p>3.客户端回应<br>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，<strong>验证服务器的数字证书</strong>的真实性。<br>如果证书没有问题，客户端会从数字证书中取出服务器的<strong>公钥</strong>，然后使用它<strong>加密报文</strong>，向服务器发送如下信息：</p><ol><li>一个<strong>随机数（pre-master key）</strong>。该随机数会被服务器公钥加密。</li><li>加密通信算法改变<strong>通知</strong>，表示随后的信息都将用<strong>「会话秘钥」</strong>加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个<strong>摘要，用来供服务端校验</strong>。</li></ol><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。<br>服务器和客户端有了这<strong>三个随机数</strong>（Client Random、Server Random、pre-master key），接着就用双方协商的<strong>加密算法</strong>，各自生成本次通信的<strong>「会话秘钥」</strong>。</p><ol start="4"><li>服务器的最后回应</li></ol><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：</p><ol><li>加密通信算法改变<strong>通知</strong>，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个<strong>摘要</strong>，用来供客户端校验。</li></ol><p>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><h2 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h2><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并<strong>验证其完整性和来源</strong>，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091913604.png" alt="image.png"><br>具体过程如下：</p><ol><li>首先，消息被<strong>分割成多个较短的片段</strong>,然后分别对每个片段进行<strong>压缩</strong>。</li><li>接下来，经过压缩的片段会被加上<strong>消息认证码</strong>（MAC 值，这个是通过<strong>哈希算法生成</strong>的），这是为了保证完整性，并进行数据的认证。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了<strong>防止重放攻击</strong>，在计算消息认证码时，还加上了<strong>片段的编码</strong>。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起<strong>通过对称密码进行加密</strong>。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ol><h2 id="HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3的演变"><a href="#HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3的演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3的演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3的演变</h2><h3 id="HTTP-x2F-1-1-与-HTTP-x2F-1-0"><a href="#HTTP-x2F-1-1-与-HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.1 与 HTTP&#x2F;1.0"></a>HTTP&#x2F;1.1 与 HTTP&#x2F;1.0</h3><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p><ul><li>使用<strong>长连接</strong>的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li>没有请求<strong>优先级控制</strong>；</li><li>请求只能从客户端开始，服务器只能<strong>被动响应</strong>。</li></ul><h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091914514.png" alt="image.png"><br>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><ul><li><strong>头部压缩</strong>，HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</li><li><strong>二进制格式</strong>，头信息和数据体都是<strong>二进制</strong>，并且统称为帧（frame）。</li><li><strong>并发传输</strong>，<strong>引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接</strong>。针对不同的 HTTP 请求用独一无二的 <strong>Stream ID</strong>来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，<strong>不同 Stream 的帧是可以乱序发送的</strong>，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</li><li><strong>服务器主动推送资源</strong>，服务端不再是被动地响应，可以主动向客户端发送消息。客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li></ul><p><strong>缺陷：</strong><br>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，<strong>HTTP&#x2F;2 应用层才能从内核中拿到数据</strong>，这就是 HTTP&#x2F;2 队头阻塞问题。（滑动窗口）</p><h3 id="HTTP-x2F-3-0"><a href="#HTTP-x2F-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h3><p>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP，基于 UDP 的 <strong>QUIC</strong> 协议 可以实现类似 TCP 的可靠性传输。</p><ul><li>无队头阻塞，每个Stream有独立的滑动窗口</li><li>更快的连接建立，QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS</li><li>连接迁移，基于连接ID而非四元组</li></ul><h2 id="HTTP-x2F-1-1如何优化"><a href="#HTTP-x2F-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h2><ol><li>尽量避免发送 HTTP 请求：</li></ol><p><strong>缓存技术</strong></p><ol start="2"><li>在需要发送 HTTP 请求时，考虑如何减少请求次数：<ol><li><strong>减少重定向次数</strong>，由代理服务器完成重定向并进行缓存</li><li><strong>合并请求</strong>，减少重复发送的HTTP头部，合并资源</li><li><strong>延迟发送请求</strong>，懒加载</li></ol></li><li>减少服务器的 HTTP 响应的数据大小：<ol><li>有损压缩：音频、视频、图片</li><li>无损压缩：文本文件、程序可执行文件、程序源代码</li></ol></li></ol><h2 id="HTTP-x2F-2-0-1"><a href="#HTTP-x2F-2-0-1" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h2><ol><li>头部压缩</li></ol><p>HTTP&#x2F;1.1body可以使用content-encoding字段指定压缩方式，但是没有针对header的优化手段<br>问题：</p><ol><li>固定字段</li><li>重复字段</li><li>ASCII编码，效率低下</li></ol><p><strong>HPACK 算法</strong>主要包含三个组成部分：</p><ol><li>静态字典，写入到 HTTP&#x2F;2 框架里的，不会变化的；</li><li>动态字典，在编码解码的时候随时更新；</li><li>Huffman 编码（压缩算法）；</li><li>二进制编码</li></ol><p>于将 HTTP&#x2F;1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。</p><ol start="3"><li>并发传输</li></ol><p>引入Stream ，多个 Stream 复用一条 TCP 连接，达到并发的效果，解决了 HTTP&#x2F;1.1 队头阻塞的问题，<strong>提高了 HTTP 传输的吞吐量</strong>。<br>在 HTTP&#x2F;2 连接上，<strong>不同 Stream 的帧是可以乱序发送的</strong>（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。</p><ol start="4"><li>服务器推送</li></ol><p>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过<strong>PUSH_PROMISE</strong>帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p><h2 id="HTTP-x2F-3-0-1"><a href="#HTTP-x2F-3-0-1" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h2><p>HTTP&#x2F;2 虽然具有多个流并发传输的能力，但是传输层是 <strong>TCP 协议</strong> ，于是存在以下 <strong>缺陷</strong>：</p><ul><li><strong>队头阻塞</strong>，HTTP&#x2F;2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，<strong>应用层也无法从内核中读取到这部分数据</strong>，从 HTTP 视角看，就是多个请求被阻塞了；</li><li>TCP 和 TLS <strong>握手时延</strong>，TCL 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li><li><strong>连接迁移</strong>需要重新连接，移动设备从 4G 网络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li></ul><p>HTTP&#x2F;3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。<br>QUIC 协议的特点：</p><ul><li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，<strong>某个流发生丢包了，只会影响该流，其他流不受影响</strong>；</li><li><strong>建立连接速度快</strong>，因为<strong>QUIC 内部包含 TLS1.3</strong>，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li><li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>「连接 ID 」</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li></ul><p>另外 HTTP&#x2F;3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP&#x2F;2 的 HPACK 队头阻塞问题。</p><h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><p>现在电脑上装的各种<strong>联网</strong>软件，比如xx管家，xx卫士，它们都作为<strong>客户端（client）需要跟服务端（server）建立连接收发消息</strong>，此时都会用到应用层协议，在这种 client&#x2F;server (c&#x2F;s) 架构下，它们可以使用自家造的RPC协议，因为它只管连自己公司的服务器就ok了。<br>但有个软件不同，<strong>浏览器（browser）</strong>，不管是chrome还是IE，它们不仅要能访问自家公司的<strong>服务器（server）</strong>，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP就是那个时代用于统一 <strong>browser&#x2F;server (b&#x2F;s)</strong> 的协议。<br>也就是说在多年以前，<strong>HTTP主要用于b&#x2F;s架构，而RPC更多用于c&#x2F;s架构。但现在其实已经没分那么清了，b&#x2F;s和c&#x2F;s在慢慢融合。很多软件同时支持多端，比如某度云盘，既要支持网页版</strong>，还要支持<strong>手机端和pc端</strong>，如果通信协议都用HTTP的话，那服务器只用同一套就够了。而RPC就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP-头部格式"><a href="#TCP-头部格式" class="headerlink" title="TCP 头部格式"></a>TCP 头部格式</h2><p>源端口号、目的端口号、序列号、应答号、首部长度、控制位、窗口大小、校验和、紧急指针</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091914670.png" alt="image.png"></p><h2 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><strong>面向连接</strong>：一定是<strong>「一对一」</strong>才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以<strong>保证一个报文一定能够到达接收端</strong>；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道<strong>「消息的边界」</strong>，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h2 id="服务端最大的TCP连接数"><a href="#服务端最大的TCP连接数" class="headerlink" title="服务端最大的TCP连接数"></a>服务端最大的TCP连接数</h2><p>服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p><ul><li><strong>文件描述符限制</strong>，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li><strong>系统级</strong>：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看；</li><li><strong>用户级</strong>：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf 查看；</li><li><strong>进程级</strong>：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 查看；</li></ul></li><li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP是面向连接的基于字节流的可靠传输层协议，UDP是无连接的基于数据报的传输层协议；</p><ol><li><strong>服务对象</strong><ol><li>TCP 是<strong>点对点</strong>服务，每个连接只有两个端点</li><li>UDP支持<strong>一对一、一对多、多对一、多对多</strong>的交互通信</li></ol></li><li><strong>连接</strong><ol><li>TCP面向连接，传输之前必须三次握手建立好连接</li><li>UDP无连接</li></ol></li><li><strong>可靠性</strong><ol><li>TCP<strong>可靠交付</strong>：差错控制、按序到达</li><li>UDP<strong>尽力而为</strong>，不保证可靠交付</li></ol></li><li><strong>拥塞控制、流量控制</strong><ol><li>TCP提供差错控制与流量控制</li><li>UDP没有拥塞可控制</li></ol></li><li><strong>报文长度</strong><ol><li>TCP<strong>最大报文长度为MSS</strong>，一般为1460字节，TCP会根据滑动窗口的大小和当前网络的拥塞情况调整报文长度</li><li>UDP基于<strong>数据报</strong>，不合并，不拆分，保留应用层传递下来的报文</li></ol></li><li><strong>头部开销</strong><ol><li>TCP头部有20字节（源端口、目的端口、序列号、确认号、首部长度、标志位、窗口大小、校验和、紧急指针、其他选项）</li><li>UDP首部长度为8字节（源端口、目的端口、数据长度、校验和）</li></ol></li><li><strong>适用场景</strong><ol><li>特点：TCP可靠传输慢，UDP不可靠传输快</li><li><strong>通信数据完整性</strong>要求高于<strong>通信实时性</strong>时，则应选用TCP（如文件传输、重要状态的更新等）；反之，采用UDP（如 视频传输、实时通信等）</li></ol></li></ol><h2 id="TCP三次握手的过程"><a href="#TCP三次握手的过程" class="headerlink" title="TCP三次握手的过程"></a>TCP三次握手的过程</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091914236.png" alt="image.png"></p><ol><li>第一次握手：客户端向服务器端发送连接请求报文段，包含自身数据通讯初始序号，<strong>进入SYN-SENT</strong>状态。</li><li>第二次握手：服务器端收到连接请求报文段后，如果同意，发送应答，包含自身数据通讯初始序号，进入<strong>SYN-RECEIVED</strong>状态。</li><li>第三次握手：客户端收到应答，最后向服务器端发送确认报文，进入<strong>ESTABLISHED</strong>状态，此时成功建立长连接。</li></ol><h2 id="TCP-三次握手的原因"><a href="#TCP-三次握手的原因" class="headerlink" title="TCP 三次握手的原因"></a>TCP 三次握手的原因</h2><ol><li><strong>避免历史连接</strong>（主要原因）</li></ol><p>在两次握手的情况下，旧的SYN比新的SYN先到达，<strong>「被动发起方」没有中间状态给「主动发起方」来阻止历史连接</strong>，导致「被动发起方」可能建立一个历史连接，造成资源浪费。<br>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。</p><ol start="2"><li>同步双方序列号</li></ol><p>TCP 协议的通信双方， 都必须维护一个「序列号」，<strong>序列号是可靠传输的一个关键因素</strong>，它的作用：</p><ul><li>接收方可以<strong>去除重复的数据</strong>；</li><li>接收方可以根据数据包的序列号<strong>按序接收</strong>；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）</li></ul><ol start="3"><li>避免资源浪费</li></ol><h2 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2><p>如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，当一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。<br>因为 <strong>IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传</strong>。<br>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「<strong>整个 TCP 报文（头部 + 数据）</strong>」。<br>因此，可以得知由 IP 层进行分片传输，是<strong>非常没有效率的</strong>。<br>所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。<br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大<strong>增加了重传的效率</strong>。</p><h2 id="TCP四次挥手的过程"><a href="#TCP四次挥手的过程" class="headerlink" title="TCP四次挥手的过程"></a>TCP四次挥手的过程</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091914627.png" alt="image.png"></p><ol><li>第一次挥手：客户端认为数据发送完毕，向服务器端发送<strong>连接释放请求FIN</strong>。</li><li>第二次挥手：服务器收到连接释放请求，告诉应用层释放TCP连接。然后发送ACK包，进入<strong>CLOSE-WAIT</strong>状态，此时表明客户端到服务器端的连接已经释放，不再接受客户端的数据。因为TCP是全双工的，所以服务器仍可以发送数据。</li><li>第三次挥手：当服务器端数据发送完毕，向客户端发送连接释放请求FIN，进入<strong>LAST-ACK</strong>状态。</li><li>第四次挥手：客户端收到连接释放请求，向服务器端发送确认应答报文，此时客户端进入<strong>TIME-WAIT</strong>状态，<strong>持续2倍的MSL（最长报文段寿命）</strong>，若期间没有收到服务器端的数据报文，进入CLOSED状态。服务器端收到确认应答后，也进入CLOSED状态。</li></ol><h2 id="TCP-为什么需要四次挥手"><a href="#TCP-为什么需要四次挥手" class="headerlink" title="TCP 为什么需要四次挥手"></a>TCP 为什么需要四次挥手</h2><p>再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。</p><h2 id="请你说说TIME-WAIT"><a href="#请你说说TIME-WAIT" class="headerlink" title="请你说说TIME_WAIT"></a>请你说说TIME_WAIT</h2><p>四次挥手结束，<strong>主动方</strong>进入TIME_WAIT状态。 </p><ol><li>TCP连接第四次挥手结束时，主动发起连接释放请求的一方进入TIME_WAIT状态，此时主动发起连接释放请求的一方会<strong>等待2MSL（最大报文生存期）</strong>才会回到初始状态CLOSED。 </li><li>产生TIME_WAIT的<strong>原因：</strong><ol><li><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收。</strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，所以无法根据序列号来判断新老数据。如果服务端在关闭连接之前发送的报文，被网络延迟了。服务端以相同的四元组重新打开了新连接，前面被延迟的报文这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。<strong>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，</strong>因此 TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时长，这个时间足以<strong>让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失</strong>，再出现的数据包一定都是新建立连接所产生的。</li><li><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong>。当主动发起连接释放请求的一方最后发送ACK确认数据包在网络中<strong>丢失</strong>时，由于TCP的重传机制，被动关闭的一方会<strong>重新发送FIN</strong>，在FIN到达主动关闭的一方之前，主动关闭的一方需要维持这条连接，也就是主动的一方TCP资源不可以释放，直到被动关闭一方的FIN到达之后，主动关闭方<strong>重新发送ACK</strong>确认数据包，经过<strong>2MSL时间周期没有再收到被动关闭一方的FIN之后，才会恢复到CLOSED状态</strong>，如果没有TIME_WAIT这个状态，当FIN到达时，主动方会用<strong>RST来响应</strong>，在被动关闭的一方看来似乎是一个错误，实际上是正常的连接释放过程。</li></ol></li></ol><h2 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h2><p>危害：</p><ol><li>占用<strong>系统资源</strong>，比如文件描述符、内存资源、CPU资源、线程资源等；</li><li>占用<strong>端口</strong>。</li></ol><p>客户端和服务端TIME_WAIT过多造成的影响是不同的。<br>客户端：<br>客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务器建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务器建立连接了。<br>不过，即使是在这种场景下，只要连接的是不同的服务器，端口是可以重复使用的，所以客户端还是可以向其他服务器发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。<br>服务端：<br>并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p><h2 id="TIME-WAIT-优化"><a href="#TIME-WAIT-优化" class="headerlink" title="TIME_WAIT 优化"></a>TIME_WAIT 优化</h2><ol><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；可以<strong>复用处于TIME_WAIT</strong>的socket为新的连接所用；</li><li>修改<strong>TIME_WAIT最大上限</strong>，默认18000，一旦超过这个值，系统会将后面的TIME_WAIT直接重置；</li><li>程序中使用<strong>SO_LINGER</strong>，调用close后会立即发送RST，跳过TIME_WAIT状态直接关闭，但是这种行为非常危险，不值得提倡。</li></ol><h2 id="请你说说-CLOSE-WT"><a href="#请你说说-CLOSE-WT" class="headerlink" title="请你说说 CLOSE_WT"></a>请你说说 CLOSE_WT</h2><p>在TCP四次挥手阶段，当主动方提出连接释放请求时，被动方给予响应ACK确认应答，但是TCP连接是全双工的，也需要被动方发送连接释放请求，即FIN。但是被动方并没有立即发送FIN，还在读取数据或者传输数据， 进入CLOSE_WAIT状态。 自身，没有关闭连接。</p><h2 id="如果已经建立了连接，但是客户端突然出现故障了"><a href="#如果已经建立了连接，但是客户端突然出现故障了" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了"></a>如果已经建立了连接，但是客户端突然出现故障了</h2><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：<br>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，<strong>每隔一个时间间隔，发送一个探测报文</strong>，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><h2 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么</h2><p><strong>TCP 的连接信息是由内核维护的</strong>，所以当服务端的进程崩溃后，<strong>内核需要回收该进程的所有 TCP 连接资源</strong>，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能<strong>与客户端完成 TCP四次挥手的过程</strong>。</p><h2 id="请你说说-TCP-如何实现可靠传输"><a href="#请你说说-TCP-如何实现可靠传输" class="headerlink" title="请你说说 TCP 如何实现可靠传输"></a>请你说说 TCP 如何实现可靠传输</h2><p>三次握手、重传、校验和 、流量控制、拥塞控制</p><ol><li><strong>三次握手</strong>建立可靠的连接，对发送的数据进行编号，确保交付给应用层的数据是有序的</li><li>接收方收到后会根据<strong>校验和</strong>进行检查，看数据是否发生了改变，没改变就发送确认号，此时发送方接受到确认号才会将数据从缓冲区删除，如果没有接受到确认号，就会<strong>超时重传</strong></li><li>同时TCP还有<strong>流量控制</strong>和<strong>拥塞控制</strong></li></ol><h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><p>常见的重传机制：</p><ol><li>超时重传<ol><li>数据包丢失</li><li>确认应答丢失</li></ol></li><li>快速重传<ol><li>不以时间为驱动，而是以数据驱动重传</li><li>连续收到三个相同的ACK</li></ol></li><li>SACK（选择性确认）<ol><li>可以将已收到的数据的信息发送给「发送方」</li></ol></li><li>D-SACK<ol><li>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</li><li>好处：<ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol></li></ol></li></ol><h2 id="TCP超时重传机制，时间是多少"><a href="#TCP超时重传机制，时间是多少" class="headerlink" title="TCP超时重传机制，时间是多少"></a>TCP超时重传机制，时间是多少</h2><p>TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求<strong>在发送端每发送一个报文段，就启动一个定时器并等待确认信息。接收端成功接收新数据后返回确认信息。</strong>若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和<strong>重传</strong>。<br>影响超时重传机制协议效率的一个关键参数是<strong>重传超时时间</strong>（RTO）。RTO的值被设置过大过小都会对协议造成不利影响。</p><ol><li>如果RTO设置过大将会使发送端经过较长时间的等待才能发现报文段丢失，降低了连接数据传输的吞吐量；</li><li>若RTO过小，发送端尽管可以很快地检测出报文段的丢失，但也可能将一些延迟大的报文段误认为是丢失，造成不必要的重传，浪费了网络资源。</li></ol><p>TCP协议使用<strong>自适应算法以适应互联网分组传输时延的变化</strong>。这种算法的基本要点是TCP监视每个连接的传输时延，由此每一个TCP连接推算出合适的RTO值，当连接时延性能变化时，TCP也能够相应地自动修改RTO的设定，以适应这种网络的变化。 TCP协议采用自适应算法记录数据包的往返时延，并根据往返时延设定RTO的取值。一般来说，RTO的取值会略大于RTT以保证数据包的正常传输。RTO的计算方式为： RTO &#x3D; RTTs + 4xRTTd 其中RTTs为加权平均往返时间，RTTd是偏差的加权平均值。</p><h2 id="说一说TCP的流量控制"><a href="#说一说TCP的流量控制" class="headerlink" title="说一说TCP的流量控制"></a>说一说TCP的流量控制</h2><p>得分点 流量控制就是让发送方的发送速率不要过快，让接收方来得及接收所有的数据。<br>如果发送方把数据发送得过快，接收方可能就来不及接受到所有的数据，中间可能会丢失数据报。流量控制就是<strong>让发送方的发送速率不要过快，让接收方来得及接收所有的数据</strong>。 利用<strong>滑动窗口</strong>这个机制可以很方便的实现在TCP连接上控制对方发送数据报的速率。例如：发送方和接受方端建立TCP连接的时候，接受方告诉发送方“我的接收窗口，rwnd&#x3D; 400”，这时候发送方的发送窗口发送的数据报总大小不能超过接收端给出的接收窗口的数值，这个数值的单位是字节，而不是报文段。</p><h2 id="说一说滑动窗口"><a href="#说一说滑动窗口" class="headerlink" title="说一说滑动窗口"></a>说一说滑动窗口</h2><p>得分点 <strong>流量控制</strong>中的窗口会持续的向前滑动，因此这个窗口被称为滑动窗口。<br>TCP每发送一个数据，就要进行一次确认应答，如果收到上一个数据包的应答才发送下一个数据的话，数据包的往返时间越长，<strong>通信效率就会越低</strong>。为了解决这个问题TCP引入了窗口的概念，无需等待确认应答，可以继续发送数据，实现累计确认。<br><strong>窗口是操作系统开辟的一个缓冲区。</strong></p><ol><li><strong>发送方</strong>在收到ACK之前会保留窗口中已经发送的数据，如果按期收到ACK，此时数据就可以从缓冲区中清除；</li><li><strong>接受方</strong>窗口表示未接受到但可以接受的数据，当收到下一个期望到达的数据时，窗口向后滑动，</li></ol><p>当接受方繁忙，应用层无法及时读取缓冲区数据时，接受方的滑动窗口会减少，最后可能会发生<strong>窗口关闭</strong>；当接受方资源非常紧张时，操作系统直接减少接收缓冲区的大小，应用层又无法及时读取数据，就会发送<strong>数据丢包的现象</strong>，为了防止这种情况发生，TCP 规定是<strong>不允许同时减少缓存又收缩窗口的</strong>，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</p><h2 id="糊涂窗口综合证"><a href="#糊涂窗口综合证" class="headerlink" title="糊涂窗口综合证"></a>糊涂窗口综合证</h2><p>如果接受方太忙，来不及取走接受窗口的数据，那么会导致发送方的窗口越来越小。到最后如果接受方腾出几个字节并告诉发送方现在有几个字节的窗口，那么发送方就会发送几个字节的数据，TCP的效率会变得很低。<br>糊涂窗口综合症状可以发生在发送方和接受方：</p><ul><li>接受方可以通告一个小窗口</li><li>发送方可以发送小数据</li></ul><p>解决方法：</p><ol><li><strong>不让接受方通告小窗口</strong>：</li></ol><p>当「窗口大小」小于<strong>min( MSS，缓存空间&#x2F;2 )<strong>，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方</strong>通告窗口为 0</strong>，也就阻止了发送方再发数据过来。<br>等到接收方处理了一些数据后，窗口大小大于 **min( MSS，缓存空间&#x2F;2 )**，就可以把窗口打开让发送方发送数据过来。</p><ol start="2"><li>发送方避免发送小数据：</li></ol><p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的<strong>任意一个条件</strong>，才可以发送数据：</p><ol><li>等到窗口大小 &gt;&#x3D; MSS **并且 **数据大小 &gt;&#x3D; MSS</li><li>收到之前发送数据的ACK包（要求TCP连接上最多只能有一个未被确认的小分组）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> 有数据要发送 &#123;<br>    <span class="hljs-keyword">if</span> 可用窗口大小 &gt;= MSS <span class="hljs-keyword">and</span> 可发送的数据 &gt;= MSS &#123;<br>    立刻发送MSS大小的数据<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> 有未确认的数据 &#123;<br>            将数据放入缓存等待接收ACK<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            立刻发送数据 <span class="hljs-comment">// 仍然会发送小数据</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TCP-是如何解决窗口关闭时，潜在的死锁现象呢？"><a href="#TCP-是如何解决窗口关闭时，潜在的死锁现象呢？" class="headerlink" title="TCP 是如何解决窗口关闭时，潜在的死锁现象呢？"></a>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</h2><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器</strong>。<br>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li><li>如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。</li></ul><h2 id="说说TCP的拥塞控制机制"><a href="#说说TCP的拥塞控制机制" class="headerlink" title="说说TCP的拥塞控制机制"></a>说说TCP的拥塞控制机制</h2><p>防止太多的数据进入到网络中，四个算法：<strong>慢启动、拥塞避免、快重传、快恢复</strong>。<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091915079.png" alt="image.png"><br>拥塞控制就是防止太多的数据进入到网络中，这样可以使网络中的路由器或者链路不会过载，首先要求当前的网络可以承受住现有的网络负荷，它是一个全局性的过程，拥塞控制的算法有以下四种：<strong>慢启动、拥塞避免、快重传、快恢复</strong>。 </p><ol><li>慢启动（slow-start）：当客户端发送数据的时候，如果一次性把大量的数据字节发送到网络中，就有可能引起网络拥塞，因为并不清楚网络的负荷状态。所以较好的方法是先探测一下，<strong>由小到大逐渐增大发送窗口</strong>，也就是慢慢地增大窗口数值。通常刚开始发送报文段时先把拥塞窗口cwnd设置为一个最大报文段MSS的值，每收到一对新的报文段确认后，把拥塞窗口的数值再加一个MSS<strong>（指数增加）</strong>。</li><li>拥塞避免（congestion avoidance）：让拥塞窗口cwnd缓缓地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，让拥塞窗口按照线性规律慢慢增长，比慢开始算法的拥塞窗口增长速率慢很多<strong>（线性增加）</strong>。</li><li>快重传（fast retransmit）：要求接收方每收到一个失序的报文段之后就立即发出重复确认而不是等待自己发送数据时捎带确认，为的就是让发送方能尽早地知道有报文段没有到达接收方。</li><li>快恢复（fast recovery）：两个要点，一是当发送方连续收到三个重复确认时，就执行”乘法减小“算法，把慢开始门限ssthresh减半，这是为了预防网络发生拥塞。二是发送方认为网络很可能没有发生阻塞，因此不会执行慢开始算法，而是把cwnd值设置成慢开始门限ssthresh减半之后的数值<strong>（减半+3）</strong>，然后执行拥塞避免算法，使拥塞窗口呈线性增长。</li></ol><h2 id="请你说说-TCP-粘包"><a href="#请你说说-TCP-粘包" class="headerlink" title="请你说说 TCP 粘包"></a>请你说说 TCP 粘包</h2><p>得分点<strong>TCP基于字节流，无法判断发送方报文段边界</strong>，一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。<br>粘包的原因：</p><ol><li>应用程序写入数据的字节大小大于套接字发送缓冲区的大小；</li><li>进行MSS（最大段长度）的TCP分段；</li><li>以太网的payload大于MTU分片。</li></ol><p>解决办法：</p><ol><li>固定长度的消息；</li><li><strong>特殊字符作为边界</strong>，如http中的回车换行；</li><li>自定义的消息结构。</li></ol><h2 id="UDP怎么实现可靠的传输"><a href="#UDP怎么实现可靠的传输" class="headerlink" title="UDP怎么实现可靠的传输"></a>UDP怎么实现可靠的传输</h2><p>得分点 <strong>将运输层TCP的可靠传输机制在应用层实现</strong>。<br>UDP不是面向连接的协议，因此<strong>资源消耗小，处理速度快</strong>的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。如果想要使用UDP还要保证数据的可靠传输，就要将TCP在传输层功能，如确认机制、重传功能、流量控制、拥塞控制等功能实现在了应用层。<br>现在已经有基于 UDP 协议实现的可靠传输协议的成熟方案了，那就是 QUIC 协议，已经应用在了 HTTP&#x2F;3。</p><p><strong>一、QUIC的可靠传输</strong><br>要基于UDP完成可靠的传输，需要解决两个主要的问题：</p><ol><li>超时重传</li><li>序列号</li></ol><p>QUIC主要是通过Packet Header和 QUIC Frame Header实现可靠传输的：</p><ol><li>Packet Header，分为Long Packet Header 和 Short Packet Header：<ol><li>Long Packet Header用于首次建立连接，QUIC也需要三次握手建立连接，目的是为了协商连接ID，后续传输时双方只需要固定住连接 ID，从而实现连接迁移功能。</li><li>Short Packet Header用于数据传输，Short Packet Header中有一个Packet Number，它是每个报文唯一的编号，是严格递增的，也就是说就算 Packet N丢失了，重传的数据包的Packet Number也不是N了。这样设计的目的是为了<strong>解决TCP重传歧义的问题</strong>，TCP发生重传时，发送端无法判断出是「原始报文的响应」还是「重传报文的响应」，这样在<strong>计算 RTT（往返时间）就不精准</strong>，会影响重传时间的计算；</li></ol></li><li>QUIC Frame Header，一个Packet报文中可以存放多个 QUIC Frame。每个Frame都有不同的类型，功能和格式都不相同。Stream类型的报文就可以看作HTTP报文，包含：<ol><li>Stream ID，作用：用于区别多个并发传输的 HTTP 消息，，类似于 HTTP2 的 Stream ID；</li><li>Offset：类似于 TCP 协议中的 Seq 序号，保证数据的<strong>顺序性和可靠性</strong>；</li><li>Length：指明Frame数据的长度；</li><li>负载数据。</li></ol></li></ol><p>基于TCP 的HTTP2.0多个stream共同使用一个滑动窗口，会因为某个数据包重传而导致窗口队头阻塞，QUIC为每个stream都分配了一个独立的滑动窗口，通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以<strong>支持乱序确认而不影响数据包的正确组装</strong>，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。</p><p><strong>二、QUIC的流量控制</strong><br>QUIC 实现了两种级别的<strong>流量控制</strong>，分别为 Stream 和 Connection 两种级别：</p><ol><li><strong>Stream 级别的流量控制</strong>：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li><li><strong>Connection 流量控制</strong>：限制连接中所有 <strong>Stream 相加起来的总字节数</strong>，防止发送方超过连接的缓冲容量。</li></ol><p><strong>三、QUIC的拥塞控制</strong><br>QUIC 协议当前默认使用了 TCP 的 拥<strong>塞控制算法</strong>，但QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统内核支持。传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，所以 TCP 拥塞控制算法迭代速度是很慢的。而 QUIC 可以随浏览器更新，QUIC 的拥塞控制算法就可以有较快的迭代速度。</p><p><strong>四、QUIC的连接迁移</strong><br>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。<br>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。<br>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，因此连接的迁移成本是很高的。<br>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，达到了<strong>连接迁移</strong>的功能。</p><h2 id="请你说说-TCP-和-UDP-的使用场景"><a href="#请你说说-TCP-和-UDP-的使用场景" class="headerlink" title="请你说说 TCP 和 UDP 的使用场景"></a>请你说说 TCP 和 UDP 的使用场景</h2><p>回答角度：优缺点，应用场景<br>UDP的<strong>优点</strong>是<strong>快</strong>，没有TCP各种机制，少了很多首部信息和重复确认的过程，节省了大量的网络资源。<strong>缺点</strong>是<strong>不可靠不稳定</strong>，只管数据的发送不管过程和结果，网络不好的时候很容易造成数据丢失。又因为网络不好的时候不会影响到主机数据报的发送速率，这对很多实时的应用程序很重要，因为像语音通话、视频会议等要求源主机要以恒定的速率发送数据报，<strong>允许网络不好的时候丢失一些数据，但不允许太大的延迟</strong>。DNS和ARP协议也是基于UDP实现的，要求快速获取IP、MAC地址，如果基于TCP那么对整个因特网的资源占用过大且速度慢。还有游戏应用程序也是通过UDP来传输报文段，允许出现丢帧导致的卡顿，但是对游戏的整体体验不会产生严重的影响。所以UDP在语音、视频、寻址、游戏、广播方面有很好的应用前景，实时性高，允许部分的数据丢失。<br>TCP的<strong>优点</strong>是<strong>面向连接提供可靠交付</strong>，即对数据有保证、无差错的进行运输。当需要<strong>数据准确无误的运输给对方时</strong>，如浏览器中需要获取服务器资源使用的<strong>HTTP&#x2F;HTTPS</strong>协议，需要保证文件准确、无差错，邮件服务器中使用的<strong>SMTP</strong>协议，保证邮件内容准确无误的传递给对方，或者是大型应用程序文件，这些都要保证文件的准确、无差错的运输给对方，所以一定要基于TCP来运输，而不是UDP。<br>综上，<strong>通信数据完整性</strong>要求高于<strong>通信实时性</strong>时，则应选用TCP（如文件传输、重要状态的更新等）；反之，采用UDP（如 视频传输、实时通信等）。</p><h2 id="在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><ol><li>合法的SYN：如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。那么就会<strong>重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</li><li>非法的SYN：如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。那么就会<strong>重传第四次挥手的 ACK 报文</strong>，客户端收到后，发现并不是自己期望收到确认号，就回 <strong>RST 报文给服务端</strong>。</li></ol><h2 id="TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>这两个完全是两样不同东西，实现的层面也不同：</p><ul><li>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 <strong>HTTP 长连接</strong>；</li><li>TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 <strong>TCP 保活机制</strong>；</li></ul><h2 id="cookies方案为什么不直接取代半连接队列？"><a href="#cookies方案为什么不直接取代半连接队列？" class="headerlink" title="cookies方案为什么不直接取代半连接队列？"></a>cookies方案为什么不直接取代半连接队列？</h2><p>目前看下来syn cookies方案省下了半连接队列所需要的队列内存，还能解决 SYN Flood攻击，那为什么不直接取代半连接队列？<br>凡事皆有利弊，cookies方案虽然能防 SYN Flood攻击，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。<br>另外，<strong>编码解码cookies，都是比较耗CPU的</strong>，利用这一点，如果此时攻击者构造大量的第三次握手包（ACK包），同时带上各种瞎编的cookies信息，服务端收到ACK包后以为是正经cookies，憨憨地跑去解码（耗CPU），最后发现不是正经数据包后才丢弃。<br>这种通过构造大量ACK包去消耗服务端资源的攻击，叫<strong>ACK攻击</strong>，受到攻击的服务器可能会因为CPU资源耗尽导致没能响应正经请求。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会<strong>通过主机「路由表」确定 IP 数据包下一跳</strong>。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 <strong>ARP 协议</strong>，求得下一跳的 MAC 地址。<br>ARP提供了将IP地址转换为链路层地址的机制，而且只为在同一个子网上的主机和路由器接口解析IP地址。 ARP寻址的具体过程如下：<br>假设主机A和B<strong>在同一个网段</strong>，主机A要向主机B发送数据报文，具体的地址解析过程如下：</p><ol><li>主机A首先查看自己的<strong>ARP缓存表</strong>，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B；</li><li>如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后<strong>以广播方式发送一个ARP请求报文</strong>。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和<strong>全0的MAC地址</strong>。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但<strong>只有被请求的主机（即主机B）会对该请求进行处理</strong>。</li><li>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，<strong>当两者相同时进行如下处理</strong>：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址<strong>存入自己的ARP表中</strong>。之后以<strong>单播方式</strong>发送<strong>ARP响应报文</strong>给主机A，其中包含了自己的MAC地址。</li><li>主机A收到ARP响应报文后，<strong>将主机B的MAC地址加入到自己的ARP表中</strong>以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</li></ol><p>当主机A和主机B<strong>不在同一网段</strong>时，主机A就会先向<strong>网关</strong>发出ARP请求，ARP请求报文中的<strong>目标IP地址为网关的IP地址</strong>。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果<strong>网关没有主机B的ARP表项</strong>，网关会<strong>广播ARP请求</strong>，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。<br>ARP表项又分为动态ARP表项和静态ARP表项。</p><ol><li>动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。</li><li>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖。直到重新启动计算机为止。</li></ol><h2 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h2><ol><li>客户端首先发起 **DHCP 发现报文（DHCP DISCOVER） **的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文（DHCP OFFER） **向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST）</strong>进行响应，回显配置的参数。</li><li>最后，服务端用<strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li></ol><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p> NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。<strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong><br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091915437.png" alt="image.png"></p><p>由于 NAT&#x2F;NAPT 都依赖于自己的转换表，因此会有以下的问题：</p><ul><li><strong>外部无法主动与 NAT 内部服务器建立连接</strong>，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生<strong>性能开销</strong>。</li><li>通信过程中，如果 NAT <strong>路由器重启</strong>了，所有的 TCP 连接都将被<strong>重置</strong>。</li></ul><p>解决的方法主要有两种方法。</p><ol><li>第一种就是改用 IPv6</li></ol><p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6 普及速度还需要一些时间。</p><ol start="2"><li>第二种 NAT 穿透技术</li></ol><p>NAT 穿透技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。<br>也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。<br>说人话，就是<strong>客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信</strong>，就不需要 NAT 设备来进行转换了。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091916597.png" alt="image.png"></p><h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><ul><li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h2 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091917099.png" alt="image.png"></p><h2 id="traceroute的工作原理"><a href="#traceroute的工作原理" class="headerlink" title="traceroute的工作原理"></a>traceroute的工作原理</h2><p>traceroute 的第一个作用就是故意设置特殊的 TTL，<strong>来追踪去往目的地时沿途经过的路由器</strong>。<br>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 1 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。<br>比如，将 TTL 设置 为 1，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。接下来将 TTL 设置为 2，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。这样的过程，traceroute 就可以拿到了所有的路由器 IP。<br>traceroute 在发送 UDP 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号：33434。然后对于每个下一个探针，它都会增加一个，这些端口都是通常认为不会被使用，不过，没有人知道当某些应用程序监听此类端口时会发生什么。<br>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。<br>它的工作原理如下：<br>首先在发送端主机发送 IP 数据报时，将 IP 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。<br>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。<br>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 MTU 值，以便能到达目标主机。</p><h1 id="计算机网络中的安全"><a href="#计算机网络中的安全" class="headerlink" title="计算机网络中的安全"></a>计算机网络中的安全</h1><h2 id="安全攻击有哪些"><a href="#安全攻击有哪些" class="headerlink" title="安全攻击有哪些"></a>安全攻击有哪些</h2><h2 id="ARP-攻击"><a href="#ARP-攻击" class="headerlink" title="ARP 攻击"></a>ARP 攻击</h2><h2 id="对称加密和非对称的区别，非对称加密有哪些"><a href="#对称加密和非对称的区别，非对称加密有哪些" class="headerlink" title="对称加密和非对称的区别，非对称加密有哪些"></a>对称加密和非对称的区别，非对称加密有哪些</h2><p>得分点 密钥、公钥、私钥 </p><ol><li>对称加密：对称加密指的就是<strong>加密和解密使用同一个秘钥</strong>，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。常见的对称加密算法有：<strong>DES、AES、3DES</strong>等。</li><li>非对称加密：非对称加密指的是：<strong>加密和解密使用不同的秘钥</strong>，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。常见的非对称加密算法：<strong>RSA，ECC</strong>等。 </li><li><strong>对称加密和非对称加密相比安全性低</strong>，因为加密和解密是同一个密钥，数据包被拦截之后不安全。而非对称加密中，公钥用来加密，私钥用来解密。公钥可以公开给任何用户进行加密，私钥永远在服务器或某个客户端手里，非常安全，数据被拦截也没用，因为私钥未公开就永远无法打开数据包。</li></ol><h2 id="DDoS-有哪些，如何防范"><a href="#DDoS-有哪些，如何防范" class="headerlink" title="DDoS 有哪些，如何防范"></a>DDoS 有哪些，如何防范</h2><p>DDoS 为分布式拒绝服务攻击，是指<strong>处于不同位置的多个攻击者同时向一个或数个目标发动攻击</strong>，或者一个攻击者控制了不同位置上的多台机器并利用这些机器对受害者同时实施攻击。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机一起发起网络攻击。</p><p>DDoS 攻击主要有两种形式：<strong>流量攻击</strong>和<strong>资源耗尽攻击</strong>。前者主要针对网络带宽，攻击者和已受害主机同时发起大量攻击导致网络带宽被阻塞，从而淹没合法的网络数据包；后者主要针对服务器进行攻击，大量的攻击包会使得服务器资源耗尽或者 CPU 被内核应用程序占满从而无法提供网络服务。</p><p>常见的 DDos 攻击主要有：TCP 洪水攻击（SYN Flood）、放射性攻击（DrDos）、CC 攻击（HTTP Flood）等。</p><p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足网络带宽的前提下，我们应尽量提升路由器、网卡、交换机等硬件设施的配置。</p><p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood等流量型攻击。此外，负载均衡，CDN 等技术都能够有效对抗 DDoS 攻击</p><h2 id="防御-SYN-攻击的方法"><a href="#防御-SYN-攻击的方法" class="headerlink" title="防御 SYN 攻击的方法"></a>防御 SYN 攻击的方法</h2><p>SYN攻击：当服务器受到SYN攻击，可能会导致TCP半连接队列全满，这时后面来的SYN包都会被丢弃。<br>防御SYN攻击的方法有以下几种：</p><ol><li>增大半连接队列；</li><li>开启tcp_cookies功能；</li><li>减少SYN+ACK的重传次数（及时断开半连接队列）</li></ol><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>在完成整个域名解析的过程之后，并没有收到本该收到的IP地址，而是接收到了一个错误的IP地址。比如输入的网址是百度，但是却进入了奇怪的网址，并且地址栏依旧是百度。在这个过程中，攻击者一般是<strong>修改了本地路由器的DNS地址</strong>，从而访问了一个<strong>伪造的DNS服务器</strong>，这个伪造的服务器解析域名的时候返回了一个攻击者精心设计的网站，这个网站可能和目标网站一模一样，当用户输入个人账户时，数据会发送给攻击者，从而造成个人财产的丢失。<br>预防DNS劫持可以通过以下几种方法：</p><ol><li>准备多个域名，当某个域名被劫持时，暂时使用另一个 </li><li>手动修改DNS，在地址栏输入<a href="http://192.168.1.1,进入路由器配置,填写主dns服务器为114.114.114.114,填写备用dns服务器为8.8.8.8/">http://192.168.1.1，进入路由器配置，填写主DNS服务器为114.114.114.114，填写备用DNS服务器为8.8.8.8</a></li><li>修改路由器密码</li><li>给运营商打投诉电话，讲明被劫持的情况</li></ol><h1 id="网络编程相关"><a href="#网络编程相关" class="headerlink" title="网络编程相关"></a>网络编程相关</h1><h2 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091917164.png"></p><h2 id="accept发生在三次握手哪个阶段"><a href="#accept发生在三次握手哪个阶段" class="headerlink" title="accept发生在三次握手哪个阶段"></a>accept发生在三次握手哪个阶段</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091917162.png" alt="img"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何查看TCP的连接状态"><a href="#如何查看TCP的连接状态" class="headerlink" title="如何查看TCP的连接状态"></a>如何查看TCP的连接状态</h2><p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091917048.png" alt="image.png"></p><h2 id="常用默认端口号"><a href="#常用默认端口号" class="headerlink" title="常用默认端口号"></a>常用默认端口号</h2><p>DNS：43<br>HTTP：80<br>HTTPS: 443<br>TCP：80<br>SQL：3306<br>redis：6379<br>SSH：22<br>tomcat：8080</p><h2 id="假设客户端有多个网卡，就会有多个-IP-地址，那-IP-头部的源地址应该选择哪个-IP-呢？"><a href="#假设客户端有多个网卡，就会有多个-IP-地址，那-IP-头部的源地址应该选择哪个-IP-呢？" class="headerlink" title="假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？"></a>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</h2><p>根据路由表规则，将目的ip与每个条目的子网掩码进行与运算，目的子网号匹配成功时将该网卡的ip地址作为源ip地址，如果都不匹配，则交给默认网关。</p><h2 id="查看ARP缓存内容"><a href="#查看ARP缓存内容" class="headerlink" title="查看ARP缓存内容"></a>查看ARP缓存内容</h2><p>在 Linux 系统中，我们可以使用 <code>arp -a</code>命令来查看 ARP 缓存的内容。</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股文之C++基础语法</title>
    <link href="/posts/4abcf3b2/"/>
    <url>/posts/4abcf3b2/</url>
    
    <content type="html"><![CDATA[<h1 id="编译内存相关"><a href="#编译内存相关" class="headerlink" title="编译内存相关"></a>编译内存相关</h1><h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><ol><li>为什么需要编译<ol><li>我们常见的 C&#x2F;C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为<strong>机器可执行的二进制指令</strong>，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂。</li></ol></li><li>编译的过程</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921568.png" alt="image.png"></p><ol><li><strong>编译预处理</strong>：引入头文件，去除注释，处理条件编译指令，宏替换，添加行号</li><li><strong>编译</strong>：对预处理后的文件进行<strong>词法分析、语法分析、语义分析、符号汇总、汇编代码的生成，代码优化</strong>。简单来说就是将.cpp源文件翻译成汇编代码</li><li><strong>汇编</strong>：将汇编代码翻译成机器指令，一个.cpp文件生成一个.o文件</li><li><strong>链接</strong>：单独的.o文件可能无法执行，因为一个程序可能由多个源文件组成。链接的目的是为了将多个目标文件链接成一个整体，从而生成一个可被操作系统加载执行的ELF文件</li><li><strong>动态链接与静态链接</strong><ol><li>静态链接：在链接生成可执行文件时，将所有外部调用函数拷贝到最终的可执行文件中，该程序被执行时，运行所需的全部代码都会装入到该进程的虚拟空间中。<ol><li>命名规则：<ol><li>Linux：.a</li><li>Windows：.lib</li></ol></li></ol></li><li>动态链接：代码生成可执行文件时，该程序调用的部分程序被放到动态链接库或共享对象的某个目标文件中，链接程序只在最终的可执行文件中<strong>记录了共享对象的名字等一些信息</strong>，最终生成的ELF文件中并<strong>不包含这些调用程序的二进制指令</strong>。在程序执行时，当需要调用这部分程序时，操作系统会从将这些动态链或者共享对象进行加载，并将全部内容会被映射到该进行运行的虚拟地址的空间。动态链接库采用了延迟绑定技术。<ol><li>命名规则：<ol><li>Linux：.so</li><li>Windows：.dll</li></ol></li></ol></li><li>二者的优缺点：<ol><li>静态链接<ol><li>缺点：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个<strong>副本</strong>，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）</li><li>优点：执行的时候运行速度<strong>快</strong>，因为可执行程序具备了程序运行的所有内容</li></ol></li><li>动态链接<ol><li>缺点：动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失</li><li>优点：节省内存、更新方便</li></ol></li><li>静态链接是由<strong>链接器</strong>完成的，动态链接最终是由<strong>操作系统</strong>来完成链接的功能</li></ol></li></ol></li></ol><p>补充：<a href="https://aweiii.work/posts/bb4cd573/#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93">静态库和动态库</a></p><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><ol><li>ELF文件</li></ol><p>可执行与可链接格式 (Executable and Linkable Format) 是一种用于<strong>可执行文件、目标代码、共享库和核心转储 （core dump）</strong>的标准文件格式。<br>其文件构成如下：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921950.png" alt="image.png"><br>ELF文件内部是分段存储的 ：</p><ul><li>.text section：代码段，存放机器代码，只读</li><li>.rodata section：只读数据段，文字常量</li><li>.data section：数据段，存放已初始化的全局&#x2F;静态变量、常量</li><li>.bss section：未初始化的全局变量，仅是占位符，不占据任何磁盘空间，区分.data和.bss是为了空间效率</li></ul><ol start="2"><li>内存分区：</li></ol><p>C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局&#x2F;静态存储区、常量存储区、代码区。</p><ul><li><strong>栈</strong>：栈中主要存放函数的<strong>局部变量、函数参数、返回地址</strong>等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。</li><li><strong>堆</strong>：动态申请的内存空间，就是由 <strong>malloc</strong> 函数或者 <strong>new</strong> 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，<strong>如果进程结束后还没有释放，操作系统会自动回收</strong>。</li><li><strong>全局区&#x2F;静态存储区</strong>：主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li><li><strong>常量存储区</strong>：.rodata 段，存放的是常量，不允许修改，程序运行结束自动释放。</li><li><strong>代码区</strong>：.text 段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li></ul><p>补充：</p><ol><li>static变量存放在全局数据区&#x2F;静态存储区</li><li>全局const存放在.rodata段，局部const存放在栈区</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921968.png" alt="image.png"></p><h2 id="程序栈帧"><a href="#程序栈帧" class="headerlink" title="程序栈帧"></a>程序栈帧</h2><p>程序中函数的调用过程：<br>每次在调用函数时，会按照<strong>从右向左的顺序</strong>依次将函数调用参数压入到栈中，并在栈中压入<strong>返回地址</strong>与<strong>当前的栈帧基地址rbp</strong>，然后跳转到调用函数内部，pc 跳转函数内部执行该函数的指令。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922436.jpeg" alt="程序栈帧"></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ol><li><strong>申请方式不同</strong><ul><li>栈由系统自动分配</li><li>堆是程序员申请和释放的</li></ul></li><li><strong>申请后系统响应</strong> <ul><li>分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出</li><li>申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上</li></ul></li><li>栈在内存中是<strong>连续的</strong>一块空间（向低地址扩展）最大容量是<strong>系统预定好</strong>的，堆在内存中的空间（向高地址扩展）是<strong>不连续</strong>的</li><li><strong>申请效率</strong>： <ul><li>栈是有系统自动分配，申请效率高，但程序员无法控制</li><li>堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片</li></ul></li><li><strong>存放内容</strong>： <ul><li>栈中存放的是局部变量，函数的参数</li><li>堆中存放的内容由程序员控制</li></ul></li></ol><p><strong>补充：</strong></p><ol><li><strong>你觉得堆快一点还是栈快一点？</strong></li></ol><p>毫无疑问是栈快一点。<br>因为<strong>操作系统会在底层对栈提供支持</strong>，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。<br>而<strong>堆的操作是由C&#x2F;C++函数库提供</strong>的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p><ol start="2"><li>Linux下非编译器决定栈带下，而是有OS决定的，Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置），即：Windows下可以由<strong>编译器</strong>来决定栈大小，而在Linux下由<strong>系统环境变量</strong>来控制栈的大小<ol><li>Linux 默认栈大小：8M</li><li>Windows默认栈大小：1M</li></ol></li></ol><h2 id="变量定义与生存周期"><a href="#变量定义与生存周期" class="headerlink" title="变量定义与生存周期"></a>变量定义与生存周期</h2><ol><li>作用域<ol><li>全局变量：全局作用域，extern 声明</li><li>静态全局变量：文件作用域</li><li>局部变量&#x2F;静态局部变量：局部作用域</li></ol></li><li>生命周期<ol><li>全局变量：整个程序运行期间</li><li>局部变量：函数被调用期间，程序块内部</li><li>静态局部变量：整个程序运行期间</li></ol></li><li>分配内存<ol><li>静态变量一般存储在数据段，其中 .data 存储已经已经初始化的静态变量和全局变量，.bss 存储未初始化的静态变量与全局变量。这里<strong>静态变量包括全局变量，局部全局变量，静态局部变量</strong></li><li>局部变量一边存储在栈区或者堆区</li></ol></li><li>补充<ol><li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段，bss 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以<strong>保持原来的赋值</strong>。而栈变量或堆变量<strong>不能保证在下一次调用的时候依然保持原来的值</strong>。</li><li>静态变量和全局变量的区别：静态变量仅在变量的<strong>作用范围内</strong>可见，实际是依靠<strong>编译器来控制作用域</strong>。全局变量在整个程序范围内都可可见，只需声明该全局变量，即可使用。</li><li>全局变量定义在不要在头文件中定义：如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错，因此不能再头文件中定义全局变量。一般情况下我们将<strong>变量的定义放在 .cpp 文件中</strong>，一般<strong>在 .h 文件使用extern 对变量进行声明</strong>。</li></ol></li></ol><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>原则：</p><ol><li>结构体变量的<strong>首地址</strong>能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li><li>结构体每个成员相对于结构体首地址的<strong>偏移量 （offset）</strong> 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的<strong>总大小</strong>为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol><p>进行内存对齐的<strong>原因</strong>：（主要是<strong>硬件设备</strong>方面的问题）</p><ol><li>某些硬件设备<strong>只能存取对齐数据</strong>，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p>优点：</p><ol><li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><p><strong>补充：静态成员变量存放在全局数据区内，在编译的时候已经分配好内存空间，所以对结构体的总内存大小不做任何贡献。</strong></p><h2 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h2><ol><li><p>大小端判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)(a);<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x12</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;big endian\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x34</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;little endian\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>大小端转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ORDER_TRANS(i) ((i &amp; 0xff000000) &gt;&gt; 24 ) |  ( (i &amp; 0x00ff0000) &gt;&gt; 8 ) | ( (i &amp; 0x0000ff00) &lt;&lt; 8 )  | ( (i &amp; 0x000000ff) &lt;&lt; 24 )</span><br></code></pre></td></tr></table></figure></li><li><p>网络字节序转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ntohl</span>(uint32 x)       <span class="hljs-comment">// uint32 类型 网络序转主机序</span><br><span class="hljs-built_in">htonl</span>(uint32 x)       <span class="hljs-comment">// uint32 类型 主机序转网络序</span><br><span class="hljs-built_in">ntohs</span>(uint16 x)       <span class="hljs-comment">// uint16 类型 网络序转主机序</span><br><span class="hljs-built_in">htons</span>(uint16 x)       <span class="hljs-comment">// uint16 类型 主机序转网络序</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ol><li>内存泄漏</li></ol><p>程序在<strong>堆</strong>中申请的动态内存，在程序使用完成时<strong>没有得到及时的释放</strong>。当这些变量的生命周期已结束时，该变量在堆中所占用的内存未能得到释放，从而就导致了堆中可使用的内存越来越少，最终可能产生系统运行较慢或者系统因内存不足而崩溃的问题。</p><ol><li>内存泄漏并<strong>非指内存从物理上消失</strong>，而是指程序在运行过程中，由于疏忽或错误而<strong>失去了对该内存的控制</strong>，从而造成了内存的浪费。</li><li>内存泄漏主要指<strong>堆</strong>上分配的变量，因为栈中分配的变量，随着函数退出时会自动回收。而堆是动态分配的，一旦用户申请了内存分配而为及时释放，那么该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存。</li><li>对于实际的程序来说，我们在调用过程中使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</li><li>内存泄漏导致的问题：</li></ol><p>由于内存未得到及时释放，从而可能导致<strong>可使用的动态内存空间会越来越少</strong>，一旦内存空间全部使用完，则程序可能会导致因为内存不够中止运行。由于内存泄漏导致的问题比较严重，现在许多语言都带有 GC 程序会自动对不使用的内存进行回收，从而避免内存泄漏。</p><h2 id="内存泄漏的预防与检测"><a href="#内存泄漏的预防与检测" class="headerlink" title="内存泄漏的预防与检测"></a>内存泄漏的预防与检测</h2><ol><li>预防<ol><li><strong>内部封装</strong>：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存</li><li><strong>智能指针</strong></li><li>良好的编码习惯<ol><li>将基类的析构函数定义为<strong>虚函数</strong></li><li>遵循RAII（Resource acquisition is initialization）原则：在对象构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源；</li><li>使用智能指针</li><li>有效引入内存检测工具</li></ol></li></ol></li><li>检测</li></ol><p>Valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922827.png" alt="image.png"></p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li>Massif：检查程序中堆栈使用中出现的问题。</li><li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li><li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li><li>检测原理：</li></ul><p>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。<br>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</p><h2 id="智能指针的简介与使用"><a href="#智能指针的简介与使用" class="headerlink" title="智能指针的简介与使用"></a>智能指针的简介与使用</h2><ol><li>智能指针</li></ol><p>智能指针是<strong>为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的</strong>。C++ 11 中提供了智能指针的定义，所有关于智能指针的定义可以参考 <strong><memory></strong> 头文件。<br>传统的指针在申请完成后，必须要调用 free 或者 delete 来释放指针，否则容易产生内存泄漏的问题；smart pointer <strong>遵循 RAII 原则，当 smart pointer 对象创建时，即为该指针分配了相应的内存，当对象销毁时，析构函数会自动释放内存</strong>。<br>需要注意的是，<strong>智能指针不能像普通指针那样支持加减运算</strong>。</p><ol start="2"><li>常用的3类智能指针：<ol><li>unique_ptr</li></ol></li></ol><p><strong>独享</strong>所有权的智能指针，资源<strong>只能被一个指针占有</strong>，该指针<strong>不能拷贝构造和赋值</strong>。但可以进行<strong>移动构造</strong>和<strong>移动赋值</strong>（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过move进行赋值。</p><ol start="2"><li>shared_ptr</li></ol><p>与 unique_ptr 不同的是，shared_ptr 中资源可以被多个指针共享，但是多个指针指向同一个资源不能被释放多次，因此使用<strong>计数机制</strong>表明资源被几个指针共享。<br>通过 use_count() 查看资源的所有者的个数，<strong>可以通过 unique_ptr、weak_ptr 来构造</strong>，调用 release() 释放资源的所有权，同时将计数减一，当<strong>计数减为 0 时会自动释放内存空间（T object）</strong>，从而避免了内存泄漏。特别需要注意的是 s<strong>hared_ptr 并不是线程安全的</strong>，但 shared_ptr 的计数是原子操作实现的，利用 atmoic CAS 指令实现。当引用计数和 weak count 同时为 0 时，<strong>控制块</strong>才会被最终释放掉。<br>shared_ptr能够实现其功能依赖于对于多个shared_ptr只实例化一个**_Sp_counted_base&lt;_Lp&gt;（控制块）**</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922970.png" alt="image.png"></p><ol start="3"><li>weak_ptr</li></ol><p>指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的<strong>循环引用问题</strong>。与 shared_ptr 配合使用，将 weak_ptr 转换为 share_ptr 时，虽然它能访问 share_ptr 所指向的资源但却不享有资源的所有权，不影响该资源的引用计数。<strong>有可能资源已被释放，但 weak_ptr 仍然存在，share_ptr 必须等待所有引用的 weak_ptr 全部被释放才会进行释放。因此每次访问资源时都需要判断资源是否有效</strong>。<br>shared_ptr 通过引用计数的方式来管理对象，当进行拷贝或赋值操作时，每个 shared_ptr 都会记录当前对象的引用计数，当引用计数为0时，内存将被自动释放。当<strong>对 shared_ptr 赋予新值或者 shared_ptr 对象被销毁时，引用计数会递减</strong>。但特殊情况出现循环引用时，shared_ptr 无法正常释放资源。<strong>循环引用</strong>，即 A 指向 B，B 指向 A，在表示双向关系时，是很可能出现这种情况的。</p><h2 id="智能指针创建"><a href="#智能指针创建" class="headerlink" title="智能指针创建"></a>智能指针创建</h2><p>C++14中加入了make_unique和make_shared，《Effective Modern C++》 学习笔记之条款二十一：优先选用 std::make_unique 和 std::make_shared，而非直接 new。</p><ol><li>make_unique</li></ol><p><strong>减少代码量，能够加快编译速度</strong>，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外意外情况下可能会导致内存泄漏。但是 make_unique 不允许自定析构器，不接受 std::initializer_list 对象。</p><ol start="2"><li>make_share</li></ol><p>这个主要是可以<strong>减少对堆中申请内存的次数</strong>，只需要申请一次即可。<br>当我们使用 new 时，我们将 new 出的资源指针赋给 share_ptr 的 ptr, 然后 share_ptr 本身还需要再次在堆上申请一块单独的内存作为它的管理区，存放引用计数、用户自定的函数等，因此创建 shared_ptr 时需要在堆上申请两次。<br>当我们使用 make_share 时，我们只需要申请一块大的内存，一半用来存储资源，另一半作为管理区, 存放引用计数、用户自定的函数等，此时需要在堆上申请一次即可。<br>make_share 虽然效率高，但是同样不能自定义析构器，同时 share_ptr 的对象资源可能会延迟释放，因为此时对象资源与管理区域在同一块内存中，必须要同时释放。</p><h2 id="include-“-“-和-lt-gt-的区别"><a href="#include-“-“-和-lt-gt-的区别" class="headerlink" title="include “ “ 和 &lt; &gt; 的区别"></a>include “ “ 和 &lt; &gt; 的区别</h2><ol><li>#include:</li></ol><p>include 关键字主要用来标识 C&#x2F;C++ 程序源代码编译时需要引用的头文件，编译器会自动去查找这些头文件中的变量、函数声明、结构体定义等相关信息，常见的有 include <filename> 和 #include “filename”，二者之间的区别：</p><ol><li>include<filename> 通常在编译器或者 IDE 中<strong>预先指定的搜索目录中进行搜索</strong>，通常会搜索 &#x2F;usr&#x2F;include 目录，此方法通常用于包括标准库头文件；</li><li>#include “filename” 在<strong>当前源文件所在目录中</strong>进行查找，如果没有；再到当前已经添加的<strong>系统目录</strong>（编译时以 -I 指定的目录）中查找，最后会在 &#x2F;usr&#x2F;include 目录下查找 。</li></ol><p>日常编写程序时，对于标准库中的头文件常用 include<filename>，对于自己定义的头文件常用 #include “filename”。</p><ol start="2"><li>__has_include：</li></ol><p>C++ 17 支持该特性，用来检查是否已经包含某个文件。</p><h1 id="语言对比"><a href="#语言对比" class="headerlink" title="语言对比"></a>语言对比</h1><h2 id="C与-C-对比"><a href="#C与-C-对比" class="headerlink" title="C与 C++ 对比"></a>C与 C++ 对比</h2><p>C 语言是典型<strong>面向过程（Procedure Oriented）</strong>的编程语言，C++ 则是典型<strong>面向对象（Object Oriented）</strong>的编程语言，当然 C++ 也<strong>支持面向过程编程</strong>。</p><ul><li><strong>面向过程（Procedure Oriented）</strong>：一种以过程为中心的编程思想，侧重于分析解决问题所需的<strong>步骤</strong>，使用函数把这些步骤依次实现。</li><li><strong>面向对象（Object Oriented）</strong>：侧重于把构成问题的事务分解为各个<strong>对象</strong>。建立对象的目的不是完成其中的一个步骤，而是<strong>描述</strong>某个事务在解决整个具体问题步骤中的<strong>属性和行为</strong>。面向对象语言的显著特征就是支持<strong>封装、继承、多态</strong>。</li></ul><ol><li>C 语言：</li></ol><p>C 语言诞生于 1969 年在贝尔实验室诞生，C 语言是面向过程的编程，它最重要的特点是函数，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的（数据结构+算法）。</p><ol start="2"><li>C++ 语言：</li></ol><p>C++ 诞生于 1979 年，设计者为 Bjarne Stroustrup.<br>C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数，<strong>过程的概念被淡化</strong>了（实际上过程还是有的，就是主函数的那些语句）。以<strong>类驱动程序运行</strong>，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</p><ol start="3"><li>两者之间的比较:</li></ol><p>C++ 既继承了 C 强大的<strong>底层操作</strong>特性，又被赋予了<strong>面向对象机制</strong>。它特性繁多，支持面向对象语言的多继承、对值传递与引用传递的区分以及 const 关键字，现代 C++ 编译器完全兼容 C 语言语法。</p><ul><li>二者的相同之处:</li></ul><p>C++ 能够<strong>大部分兼容 C 的语法</strong>，且二者之间相同的关键字和运算符功能和作用也几乎相同；二者之间的内存模型与硬件比较接近，几乎都可以直接操纵硬件。栈、堆、静态变量这些概念在两种语言都存在。</p><ul><li>二者的不同之处：<ol><li>C 为面向<strong>过程</strong>的编程语言，不支持面向<strong>对象</strong>，不支持继承、多态、封装。</li><li><strong>类型检查</strong>更为严格，C 语言中的类型转换几乎是任意的，但是 C++ 编译器对于类型转换进行非常严格检查，部分强制类型转换在 C 语言编译器下可以通过，但在 C++ 编译器下无法通过。</li><li>C 和 C++ 中都有<strong>结构</strong>的概念，但是在 C 语言中结构<strong>只有成员变量</strong>，而没成员方法，C 的成员变量<strong>没有权限控制</strong>，该结构体的变量对所有调用全部可见；而在 C++ 中结构中，它可以有自己的<strong>成员变量和成员函数</strong>，C++ 对类的成员变量具有<strong>访问权限控制</strong>。</li><li>增加了面向<strong>对象的机制、泛型编程的机制（Template）、异常处理、引用、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）</strong>。</li><li>应用领域：对于 C 语言程序员来说，程序的底层实现和内存分布基本上都可见，所以一般常用于<strong>直接控制硬件</strong>，特别是 C 语言在嵌入式领域应用很广，比如常见的驱动开发等与硬件直接打交道的领域，C++ 可以用于<strong>应用层开发</strong>，用户界面开发等与操作系统打交道的领域，特别是图形图像编程领域，几乎所有的高性能图形图像库都是用 C++ 实现的。</li></ol></li></ul><h2 id="Java与C的区别"><a href="#Java与C的区别" class="headerlink" title="Java与C的区别"></a>Java与C的区别</h2><ol><li>二者的相同之处:</li></ol><p>C++ 与 Java 均支持面对对象（Object Oriented），支持类、继承、封装等常见的概念。</p><ol start="2"><li>二者的不同之处：<ol><li>Java 被编译成字节码，并运行在虚拟机 JVM 上，和开发平台无关，具有<strong>跨平台</strong>的特性；C++ 直接编译成可执行文件，是否跨平台在于用到的<strong>编译器的特性是否有多平台的支持</strong>。</li><li>Java 是<strong>完全面向对象</strong>的语言，<strong>所有函数和变量部必须是类的一部分</strong>。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。</li><li>由于Java 被编译为字节码，只要安装能够运行 <strong>Java 的虚拟机</strong>即可运行 Java 程序，因此 Java 程序具有很强的<strong>可移植性</strong>，具有<strong>“一次编写，到处运行” 的跨平台特性</strong>；而 C++ 跨平台后，必须需要<strong>重新编译</strong>；</li><li>Java 语言具有<strong>垃圾回收机制</strong>，由系统进行分配和回收内存，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。Java 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，Java 中的内存回收是以线程的方式在后台运行的，利用空闲时间。<strong>C++ 则需要程序员进行内存管理</strong>，当资源释放时需要程序员进行手动释放内存空间。</li><li>C++ 支持<strong>多重继承，允许多个父类派生一个类</strong>，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；<strong>Java 不支持多重继承</strong>，但允许<strong>一个类可以继承多个接口</strong>，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。</li><li>C++ 支持<strong>方法与操作符的重载</strong>；但 Java 只支持<strong>方法重载</strong>，不支持操作符重载。</li><li>C++ 用 <strong>virtual 关键字标记的方法可以被覆盖</strong>；Java 中<strong>非 static 方法均可被覆盖</strong>，Java 中的方法默认均可以被覆盖。</li><li>C++ 可以直接操作<strong>指针</strong>，容易产生内存泄漏以及非法指针引用的问题；Java 并不是<strong>没有指针</strong>，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。</li><li>C++ 标准库不提供**thread 相关接口；Java 的标准 SDK 提供 <strong>thread 类</strong>。</li><li>C++ 支持<strong>结构体（structure）</strong>与 <strong>联合体（union）</strong>，Java 不支持结构体（structure）与联合体（union）。</li><li>从应用场景来说， C++ 可以直接编译成可执行文件，<strong>运行效率比 Java 高</strong>。Java 目前主要用来开发 <strong>Web 应用</strong>。C++ 主要用在<strong>嵌入式开发、网络、并发编程、图形图像处理、系统编程</strong>的方面。</li></ol></li></ol><h2 id="Python和C-的区别"><a href="#Python和C-的区别" class="headerlink" title="Python和C++的区别"></a>Python和C++的区别</h2><ol><li>二者的相同之处:</li></ol><p>C++ 与 Python <strong>均支持面向对象</strong>，二者均可用来编写大型应用程序。</p><ol start="2"><li>二者的不同之处：<ol><li>从语言自身来说，Python 为<strong>脚本语言，解释执行，不需要经过编译</strong>，所有的 python 源代码都是经过 Python 解释器；C++ 是一种需要<strong>编译</strong>后才能运行的语言，在特定的机器上编译后运行。</li><li>Python 变量的<strong>作用域</strong>不仅局限于（while，for）循环内，在循环外还可以继续访问在循环内定义的变量；C++ 则不允许循环外访问循环内定义的变量。</li><li>Python 没有严格限定函数的<strong>参数类型和返回值类型</strong>；C++ 则严格限定函数参数和返回值的类型。</li><li>从运行效率来说，<strong>C++ 运行效率高，安全稳定</strong>。Python 代码和 C++ 最终都会变成 CPU 指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object；其次，Python 是<strong>边解释边执行</strong>，和物理机 CPU 之间多了<strong>解释器</strong>这层，而 C++ 是<strong>编译执行</strong>的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li><li>从开发效率来说，Python <strong>开发效率高</strong>。Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li><li><strong>书写格式和语法不同</strong>，Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者，C++ 是<strong>严格静态类型声明语言</strong>，编译器在进行编译时必须经过严格的静态类型检查，如果发现类型检查错误，则中止编译；Python 为<strong>动态类型语言</strong>，我们在编写代码时不用指定变量的类型，只在执行时才会进行变量类型推导，确定变量类型。</li><li>C++ 可以直接用来操纵硬件，适合用来作为<strong>系统编程</strong>；Python 作为一门脚本语言，功能小巧而精湛，非常适合做<strong>工具开发</strong>和<strong>运维开发</strong>。</li></ol></li></ol><h2 id="Go和C-的区别"><a href="#Go和C-的区别" class="headerlink" title="Go和C++的区别"></a>Go和C++的区别</h2><ol><li>二者的相同之处：</li></ol><p>二者都为静态类型编程语言，二者都为编译性语言，都具有高性能的特点。</p><ol start="2"><li>二者的不同之处：<ol><li>Go 的许多越语法和逻辑跟 C 非常类似，Go 的<strong>运行效率很高</strong>，Go 主要是<strong>面向过程</strong>，对于面向对象支持较弱，<strong>不支持继承、多态</strong>这些概念，Go 通过<strong>结构体中含有方法来支持面向对象</strong>，<strong>Go 没有类</strong>的概念，同时也<strong>不支持构造函数与析构函数</strong>；C++ 则是<strong>面向对象（Object Oriented）</strong>，支持继承、多重继承、多态、重载这些特性。</li><li>Go 语言<strong>自带垃圾回收</strong>（garbage collection）；C++ 不支持内存垃圾自动回收，需要程序手动管理动态申请的内存。</li><li>Go 语言也支持指针，但是 Go 语言不支持指针的运算；C++ 支持指针，同时也支持指针运算。</li><li>C++ 编译器提供 SIMD 指令生成，但是 Go 编译器不支持 SIMD 指令的生成。</li><li>C++ 遵循的许可为 open source project 2.0，而 Go 遵循的许可为 BSD。</li><li>C++ 与 Go 都属于静态类型编程语言，但是 Go 语言需要遵循<strong>强类型语言规则</strong>，<strong>Go 不支持隐式类型转换</strong>。</li><li>Go 编译时如果需要引用外部函数则使用 <strong>import</strong>关键字，引入 packages，而 C++ 则使用**#include**关键字，引入头文件。</li><li>Go 不支持函数重载和操作符重载，而 C++ 支持函数重载与操作符重载。</li><li>Go 中的空指针用 <strong>nil</strong> 表示，而 C++ 中空指针可以用 <strong>nullptr 或者 0</strong> 表示。</li><li>C++ 支持异常处理，可以捕获异常，Go 使用 panic 并保存所有的错误信息。</li><li>Go 可以利用 goroutines 与 channel 来进行并发与多线程，C++ 只能使用线程</li></ol></li></ol><h2 id="Rust和C-的区别"><a href="#Rust和C-的区别" class="headerlink" title="Rust和C++的区别"></a>Rust和C++的区别</h2><ol><li>二者的相同之处：</li></ol><p>二者都支持指针操作，都可以用来作为系统编程语言，二者都可以用来操作底层硬件，二者都都具有与 C 语言程序相当的性能。</p><ol start="2"><li>二者的不同之处：<ol><li>Rust 不允许控制指针和悬空指针，C++ 则允许空指针；</li><li>Rust 只支持<strong>函数式编程</strong>，C++ 支持的语言特性较多；</li><li>Rust 没有头文件，C++ 有头文件；</li><li>Rust 语言自带有内存管理，保证内存使用安全，Rust 利用编译时的静态分析很大程度上保证了代码使用内存的安全性；而 C++ 需要进行手动申请和释放内存；</li><li>Rust 利用静态分析，在编译时会分析代码由于并发引起的数据竞争，较好的做好的并发处理；C++ 的使用多线程并发容易引起各种数据竞争的问题。</li></ol></li></ol><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><p>详细：<a href="https://aweiii.work/posts/3687adfb/">C++11 新特性</a></p><ol><li>类型推导<ol><li>auto</li><li>decltype</li></ol></li><li>闭包<ol><li><p>lambda表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture list] (parameter list) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">return</span> type<br>&#123;<br>function body;<br>&#125;;<br><br><span class="hljs-comment">// capture list</span><br>[]      <span class="hljs-comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span><br>[x, &amp;y] <span class="hljs-comment">// x以传值方式传入（默认），y以引用方式传入。</span><br>[&amp;]     <span class="hljs-comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span><br>[=]     <span class="hljs-comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span><br>[&amp;, x]  <span class="hljs-comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span><br>[=, &amp;z] <span class="hljs-comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span><br></code></pre></td></tr></table></figure></li><li><p>仿函数</p></li><li><p>bind绑定器</p></li></ol></li><li>范围for</li><li>右值引用</li></ol><p>C++ 表达式中的 “值分类”（value categories）属性为<strong>左值</strong>或<strong>右值</strong>。其中左值是对应（refer to）内存中<strong>有确定存储地址的对象的表达式的值</strong>，而右值是<strong>所有不是左值的表达式的值</strong>。因而，右值可以是字面量、临时对象等表达式。能否被赋值不是区分 C++ 左值与右值的依据，C++ 的 const 左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<strong>左值与右值的根本区别在于是否允许取地址 &amp; 运算符获得对应的内存地址</strong>。<br>C++ 03 在用<strong>临时对象或函数返回值</strong>给左值对象赋值时的深度拷贝（deep copy），因此<strong>造成性能低下</strong>。考虑到临时对象的生命期仅在表达式中持续，如果把临时对象的内容直接<strong>移动（move）</strong>给被赋值的左值对象（<strong>右值参数所绑定的内部指针复制给新的对象，然后把该指针置为空</strong>），<strong>效率改善</strong>将是显著的。<br>C++ 右值引用即绑定到右值的引用，用 &amp;&amp; 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。左值引用是绑定到左值对象上；右值引用是绑定到临时对象上。左值对象是指可以通过取地址 &amp; 运算符得到该对象的内存地址；而临时对象是不能用取地址 &amp; 运算符获取到对象的内存地址，具体的引用绑定规则如下:</p><ul><li>非常量左值引用（X &amp;）：只能绑定到 X 类型的左值对象；</li><li>常量左值引用（const X &amp;）：可以绑定到 X、const X 类型的左值对象，或 X、const X 类型的右值；</li><li>非常量右值引用（X &amp;&amp;）：只能绑定到 X 类型的右值；</li><li>常量右值引用（const X &amp;&amp;）：可以绑定规定到 X、const X 类型的右值。</li></ul><ol start="5"><li>标准库 move() 函数</li></ol><p>move() 函数：通过该函数可获得绑定到左值上的右值引用。通过 move 获取变量的右值引用，从而可以调用对象的移动拷贝构造函数和移动赋值构造函数。</p><ol start="6"><li>智能指针</li><li>使用或禁用对象的默认函数</li><li>constexpr<ol><li>常量表示式对编译器来说是优化的机会，编译器时常在<strong>编译期</strong>执行它们并且将值存入程序中。同样地，在许多场合下，C++ 标准要求使用常量表示式。例如在数组大小的定义上，以及枚举值（enumerator values）都要求必须是常量表示式。</li><li><strong>与const的区别</strong>：const修饰的变量可以在运行时才初始化，而constexpr则一定会在编译期初始化，constexpr才是名副其实的常量，而const表示的是read only的语义，但是也可能通过指针去修改它</li><li>用 constexpr 修饰函数将限制函数的行为：<ol><li>函数的回返值类型不能为void；</li><li>函数体不能声明变量或定义新的类型；</li><li>函数体只能包含声明、null语句或者一段return语句；</li><li>函数的内容必须依照 “return expr” 的形式，在参数替换后，expr 必须是个常量表达式；</li><li>这些常量表达式只能够调用其他被定义为 constexpr 的函数，或是其他常量形式的参数；</li><li>constexpr 修饰符的函数直到在该编译单元内被定义之前是不能够被调用的，声明为 constexpr 的函数也可以像其他函数一样用于常量表达式以外的调用。</li></ol></li></ol></li><li>初始化列表</li><li>nullptr</li></ol><h1 id="关键字与关键库函数"><a href="#关键字与关键库函数" class="headerlink" title="关键字与关键库函数"></a>关键字与关键库函数</h1><h2 id="sizeof-和-strlen-的区别"><a href="#sizeof-和-strlen-的区别" class="headerlink" title="sizeof 和 strlen 的区别"></a>sizeof 和 strlen 的区别</h2><ol><li>strlen 本身是<strong>库函数</strong>，因此在程序<strong>运行</strong>过程中计算长度；而 sizeof 是<strong>运算符</strong>，在<strong>编译</strong>时计算长度；sizeof 的<strong>参数</strong>可以是类型，也可以是变量，且必须是完整类型；strlen 的<strong>参数</strong>必须是 char * 类型的变量。</li><li>sizeof 接受的参数可以是对象也可以是表达式，但是 sizeof(expression) 在运行时<strong>不会对接受的表达式进行计算</strong>，编译器只会推导表达式的类型从而计算占用的字节大小；而 strlen 是一个函数，<strong>如果接受表达式则会对表达式进行运算</strong>。</li></ol><h2 id="lambda-表达式的应用"><a href="#lambda-表达式的应用" class="headerlink" title="lambda 表达式的应用"></a>lambda 表达式的应用</h2><p>闭包有很多种定义，一种说法是，闭包是<strong>带有上下文的函数，即有状态的函数</strong>。<br>那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。<br>lambda表达式的价值在于，<strong>就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密</strong>。</p><h2 id="explicit的作用"><a href="#explicit的作用" class="headerlink" title="explicit的作用"></a>explicit的作用</h2><p>用来<strong>声明类构造函数是显式调用</strong>的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。<strong>只可用于修饰单参构造函数</strong>，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。</p><h2 id="C-和-C-中-static-的作用"><a href="#C-和-C-中-static-的作用" class="headerlink" title="C 和 C++ 中 static 的作用"></a>C 和 C++ 中 static 的作用</h2><p>在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数。<br>在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</p><ol><li>static 全局静态变量：</li></ol><p>普通全局变量和 static 全局静态变量都为<strong>静态存储方式</strong>。普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；<br>静态全局变量则<strong>限制了其作用域</strong>，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</p><ol start="2"><li>static 局部静态变量：</li></ol><p>局部静态变量只能被初始化一次。与全局静态变量不同的是静态局部变量的作用域仅限于函数内部，它的<strong>作用域与函数内部的局部变量相同</strong>。实际上局部静态变量同样也存储在<strong>静态存储区</strong>，因此它的生命周期贯穿于整个程序运行期间。</p><ol start="3"><li>static 静态函数：<br>static 函数限制<strong>函数的作用域</strong>，仅可在定义该函数的文件内部调用。</li><li>static 静态成员变量：</li></ol><p>静态成员变量是<strong>在类内进行声明，在类外进行定义和初始化</strong>，在类外进行定义和初始化的时候不要出现 static 关键字和 private、public、protected 访问规则。<br>静态成员变量相当于类域中的全局变量，<strong>被类的所有对象所共享，包括派生类的对象</strong>，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化。<br>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</p><ol start="5"><li>static 静态成员函数：</li></ol><p>静态成员函数<strong>不能调用非静态成员变量或者非静态成员函数</strong>，因为静态成员函数<strong>没有 this 指针</strong>。静态成员函数做为类作用域的全局函数。<br>静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。</p><h2 id="const-作用以及用法"><a href="#const-作用以及用法" class="headerlink" title="const 作用以及用法"></a>const 作用以及用法</h2><ol><li>const变量</li><li>const指针</li><li>const引用</li><li>cosnt成员变量</li></ol><p>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。<br>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量。</p><ol start="5"><li>const参数与返回值</li><li>const成员函数</li></ol><h2 id="define-和-const-的区别"><a href="#define-和-const-的区别" class="headerlink" title="define 和 const 的区别"></a>define 和 const 的区别</h2><ol><li>编译阶段：define 是在<strong>编译预处理阶段</strong>进行替换，const 是在<strong>编译阶段</strong>确定其值。</li><li>安全性：define 定义的宏常量<strong>没有数据类型</strong>，只是进行简单的<strong>代码替换</strong>，不会进行<strong>类型安全的检查</strong>；const 定义的常量是<strong>有类型的</strong>，是要进行判断的，可以避免一些低级的错误。</li><li>存储空间：define 定义的宏定义只是作为<strong>代码替换</strong>的表达式而已，宏定义本身不占用内存空间，define 定义的宏常量，<strong>在程序中使用多少次就会进行多少次替换</strong>，内存中有<strong>多个备份</strong>，实际使用宏定义替换代码时占用的是<strong>代码段的空间</strong>；const 定义的常量占用<strong>静态存储区的只读空间</strong>，程序运行过程中<strong>常量只有一份</strong>。</li><li>调试：define 定义的宏常量<strong>不能调试</strong>，因为在预编译阶段就已经进行替换了；const 定义的常量<strong>可以进行调试</strong>。</li><li>define 可以<strong>接受参数</strong>构造非常复杂的表达式，const <strong>不能接受参数</strong>。</li></ol><h2 id="define-和-typedef-的区别"><a href="#define-和-typedef-的区别" class="headerlink" title="define 和 typedef 的区别"></a>define 和 typedef 的区别</h2><ol><li>#define 作为预处理指令，在<strong>编译预处理</strong>时进行<strong>替换操作</strong>，<strong>不作正确性检查</strong>，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是<strong>关键字</strong>，在<strong>编译</strong>时处理，有类型检查功能，用来给一个已经存在的<strong>类型一个别名</strong>，但不能在一个函数定义里面使用 typedef 。</li><li>typedef 用来定义<strong>类型的别名</strong>，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li><li>#define <strong>没有作用域的限制</strong>，只要是之前预定义过的宏，在以后的程序中都可以使用，如果在 .cpp 文件中定义了宏，则在整个文件中都可以使用该宏，如果在 .h 文件中定义了宏，则只要包含该头文件都可以使用；而 <strong>typedef 有自己的作用域</strong>，如果在函数之外定义了类型，则在整个文件中都可以使用该类型定义，如果在函数内部定义了该类型，则只能在函数内部使用该类型。</li><li>指针的操作：typedef 和 #define 在处理指针时不完全一样。</li></ol><h2 id="inline的作用以及使用方法"><a href="#inline的作用以及使用方法" class="headerlink" title="inline的作用以及使用方法"></a>inline的作用以及使用方法</h2><p>inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是<strong>直接在调用点处展开</strong>，这样可以大大<strong>减少由函数调用带来的开销</strong>，从而提高程序的运行效率。在内联函数出现之前，在 C&#x2F;C++ 的大型工程中常见用 #define 定义一些“函数”来消除调用这些函数的开销。<strong>内联函数设计的目的之一，就是取代 #define 的这项功能</strong>。由于使用 #define 定义的“函数”，编译器<strong>不会检查其参数的正确性</strong>等，而使用 inline 定义的函数，可以指定参数类型，则会被编译器校验）。内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</p><ol><li>使用方法：<strong>类内定义成员函数默认是内联函数</strong>，<strong>除了虚函数</strong>以外，因为虚函数是在<strong>运行时</strong>决定的，在<strong>编译时</strong>还无法确定虚函数的实际调用。在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数。</li><li>类外定义成员函数，若想定义为内联函数，需用关键字声明。当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。关键字 <strong>inline 必须与函数定义体放在一起才能使函数成为内联，如果只是 inline 放在函数声明前面不起任何作用</strong>。</li></ol><h2 id="inline-的工作原理"><a href="#inline-的工作原理" class="headerlink" title="inline 的工作原理"></a>inline 的工作原理</h2><ol><li>内联函数的工作原理：</li></ol><p>内联函数<strong>不是在调用时发生控制转移关系</strong>，而是在<strong>编译阶段</strong>将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来<strong>替换</strong>。函数调用时，需要切换栈帧寄存器，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而内联函数则可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点。<br>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要<strong>保护现场</strong>，被调函数执行完后，再恢复现场，该过程需要<strong>较大的资源开销</strong>。<br>虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内联函数也可以有指向它的函数指针。</p><ol start="2"><li>内联函数的优缺点：<ol><li>内联函数具有以下优点：</li></ol></li></ol><p><strong>不会产生函数调用开销</strong>。节省了调用函数时在堆栈上推送&#x2F;弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体<strong>执行上下文特定的优化</strong>，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。</p><ol start="2"><li>内联函数的缺点：<ol><li><strong>从内联函数中添加的变量会消耗额外的寄存器</strong>，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销。在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加。因此，如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销。</li><li>如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的<strong>代码重复</strong>。</li><li>过多的内联也会<strong>降低指令缓存命中率</strong>，从而降低从缓存内存到主内存的指令获取速度。</li><li>如果有人更改内联函数内的代码，<strong>内联函数可能会增加编译时间开销</strong>，那么所有调用位置都必须<strong>重新编译</strong>，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.</li><li>内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。<strong>内存抖动</strong>会导致计算机性能下降。</li></ol></li><li>inline 函数的使用场景：<ol><li>内联函数一般只适用于<strong>比较短小，处理较为简单的函数</strong>。内联只是<strong>对编译器的请求</strong>，而不是命令。编译器可以<strong>忽略内联请求</strong>。编译器可能<strong>不会</strong>在以下情况下执行内联：</li><li>如果函数包含循环（for, while, do-while）；</li><li>如果一个函数包含静态变量；</li><li>如果一个函数是递归的；</li><li>如果函数返回类型不是 void，并且函数体中不存在 return 语句；</li><li>如果函数包含 switch 或 goto 语句；</li></ol></li><li>内联可以去除函数只能定义一次的限制：</li></ol><p>内联函数可以在程序中定义不止一次， 但是 inline 函数的定义在某个源文件中只能出现一次，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 inline 函数，所有 include 该头文件，如果修改了头文件中的 inline 函数时，使用了该头文件的所有源文件都必须重新编译。比如我们可以在定义以下两个文件包含相同的函数。</p><h2 id="define-和-inline-的区别"><a href="#define-和-inline-的区别" class="headerlink" title="define 和 inline 的区别"></a>define 和 inline 的区别</h2><ol><li>内联函数是在<strong>编译时</strong>展开，而宏在<strong>编译预处理时</strong>展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li><li>内联函数是真正的<strong>函数</strong>，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销，在编译后的代码段中可以看到内联函数的定义。宏定义编写较为复杂，常需要增加一些括号来避免歧义。宏定义只进行<strong>文本替换</strong>，不会对参数的类型、语句能否正常编译等进行检查，因此在实际使用宏时非常容易出错。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行<strong>检查</strong>。</li><li>内联函数可以进行<strong>调试</strong>，宏定义的“函数”<strong>无法调试</strong>。</li><li>由于类的成员函数全部为内联函数，通过内联函数，可以访问<strong>类的数据成员</strong>，而<strong>宏不能访问类的数据成员。</strong></li><li>在 inline 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次。（ ？）</li></ol><h2 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h2><ol><li>new 的简介：<ol><li>new 是 C++ 中的关键字，尝试<strong>分配和初始化</strong>指定或占位符类型的<strong>对象</strong>或对象数组，并返回指向对象 (或数组的初始对象) 的指针。</li><li>用 new 创建对象时<ol><li>首先从<strong>堆</strong>中申请相应的内存空间</li><li>然后调用对象的<strong>构造函数</strong></li><li>最后<strong>返回</strong>指向<strong>对象的指针</strong>。</li></ol></li><li>operator new 从自由存储区（free store）上为对象动态分配内存空间，而 malloc 函数从堆上动态分配内存。自由存储区是 C++ 基于 operator new 的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C 语言使用 malloc 从堆上分配内存，使用 free 释放已分配的对应内存。<strong>new 可以指定在内存地址空间创建对象</strong>，但 placement new 需要手动调用析构，不能直接delete（会释放空间）。</li><li>在 cpp 中由于 <strong>new 作为操作符可以进行重载</strong>，所以可以对 new 进行重载，比如可以指定构造函数对对象进行初始化。对 new 操作符可以进行<strong>全局重载</strong>和<strong>局部重载</strong>，全局重载后，所有调用 new 的操作都会被重写；局部重载就是在<strong>类中重写 operator new 函数</strong>，但<strong>只会对该类生效</strong>，即该类执行 new 操作时会生效。</li></ol></li></ol><h2 id="new和delete是如何实现的"><a href="#new和delete是如何实现的" class="headerlink" title="new和delete是如何实现的"></a>new和delete是如何实现的</h2><p>new：</p><ol><li>申请空间</li><li>构造对象</li><li>返回指针</li></ol><p>delete：</p><ol><li>析构对象</li><li>释放空间</li></ol><h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h2><ol><li>malloc 的实现原理：<ol><li>malloc 为 <strong>C 语言的库函数</strong>，主要用来 <strong>从堆中</strong>申请指定大小且连续的内存空间。实际的底层实现可能较为复杂，每个程序都带有自己的动态内存管理子模块，<strong>常见的动态内存分配算法有 best fit 和 first fit 等</strong>。</li><li>malloc 分配内存的方式<ol><li>brk() 和 sbrk() 修改堆顶指针</li><li>mmap() 文件映射区</li></ol></li></ol></li><li>new 与 malloc 的区别：<ol><li>new 在申请内存的同时，会调用对象的<strong>构造函数</strong>，对象会进行初始化，malloc 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。</li><li>new 可以<strong>指定内存空间</strong>初始化对象，而 malloc 只能从<strong>堆中</strong>申请内存。</li><li>new 是 c++ 中的一个<strong>关键字</strong>，而 malloc 是 C 中的一个<strong>函数</strong>。</li><li>new 的返回值为一个<strong>对象的指针类型</strong>，而 malloc 统一返回 <strong>void * 指针</strong>。</li><li>new 内存分配成功，返回该<strong>对象类型的指针</strong>，分配失败，抛出 <strong>bad_alloc 异常</strong>；而 malloc 成功申请到内存，返回指向该<strong>内存的指针</strong>；分配失败，返回 <strong>NULL 指针</strong>。</li><li>new 的空间大小由编译器会<strong>自动计算</strong>，而 malloc 则需要<strong>指定空间</strong>大小。</li><li>new 作为一个运算符可以<strong>进行重载</strong>，而 malloc 作为一个C库函数<strong>不支持重载</strong>。</li><li>malloc 可以更改申请过的空间大小，我们可以<strong>realloc 指定空间大小</strong>，而 new<strong>一旦申请则无法更改。</strong></li></ol></li></ol><h2 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h2><ol><li>free 的简介：</li></ol><p>free 释放 heap 中申请的动态内存空间，只能释放 <strong>malloc，calloc，realloc</strong> 申请的内存。需要注意的是，free 函数只是将参数指针指向的内存<strong>归还给操作系统，并不会把参数指针置 NULL</strong>，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 free 之后，通常需要<strong>手动将指针置 NULL</strong>。内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 free 函数是没有能力去真正的 free 内存的，只是<strong>向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存</strong>。free 后指针仍然指向原来的堆地址，实际还可以使用，但操作系统可能将这块内存已经分配给其他模块使用，一般建议在 free 以后将指针置为空。一个指针经过两次 free，也是比较危险的操作，因为可能该段内存已被别的内存使用申请使用了，free 之后会造成严重后果。</p><ol start="2"><li>delete 的简介：</li></ol><p>delete 是 C++ 中的一个操作符，<strong>如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 operator delete 的标准库函数来释放所占的内存空间</strong>。delete 用来释放单个对象所占的空间，只会<strong>调用一次析构函数</strong>；delete [] 用来释放数组空间，会对数组中的<strong>每个元素都调用一次析构函数</strong>。delete 只能用来释放 new 操作返回的指针，否则会产生不可预知的后果。在单个对象上的删除 使用 delete [] 的数组形式，以及对数组使用非数组形式的删除都会产生不可预知的后果。<strong>如果 new 的对象是指定地址，则不能直接调用 delete。</strong></p><ol start="3"><li><strong>delete 与 free 的区别：</strong><ol><li>delete 是 C++ 中的一个操作符，可以进行<strong>重载</strong>；而 free 是 C 中的一个函数，不能进行重载；</li><li>free 只会释放指向的内存，不会执行对象的<strong>析构</strong>函数；delete 则可以执行对象的析构函数；</li></ol></li></ol><h2 id="new-x2F-delete-和new-x2F-delete-的区别"><a href="#new-x2F-delete-和new-x2F-delete-的区别" class="headerlink" title="new&#x2F;delete 和new[]&#x2F;delete[]的区别"></a>new&#x2F;delete 和new[]&#x2F;delete[]的区别</h2><p>new&#x2F;delete只调用<strong>一次构造&#x2F;析构函数</strong>，new[]&#x2F;delete[] 根据数组大小，<strong>多次调用构造&#x2F;析构函数</strong>，分配&#x2F;释放的空间大小是整个数组的大小。<br>如果析构的对象里面没有指针类型的成员，直接使用delete释放new[]的对象并不会导致内存泄漏。</p><h2 id="C-和-C-中-struct-的区别"><a href="#C-和-C-中-struct-的区别" class="headerlink" title="C 和 C++ 中 struct 的区别"></a>C 和 C++ 中 struct 的区别</h2><ol><li>在 C 语言中 struct 是<strong>用户自定义数据类型</strong>；在 C++ 中 struct 是<strong>抽象数据类型</strong>，支持成员函数的定义。C++ 中的 class 可以实现 struct 的所有功能，<strong>C++ 为了兼容 C 语言保留了 struct 关键字</strong>。</li><li>C 语言中 struct <strong>没有访问权限的设置</strong>，是一些变量的<strong>集合体</strong>，不能定义成员函数；C++ 中 struct 可以和类一样，有<strong>访问权限</strong>，并可以定义成员函数。</li><li>C 语言中 struct 定义的自定义数据类型，<strong>在定义该类型的变量时，需要加上 struct 关键字</strong>，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var。</li><li>C++ 中 struct <strong>可以继承，也可以实现多态</strong>，而 C 语言中<strong>不支持继承和多态</strong>。</li></ol><h2 id="struct-和-union-的区别"><a href="#struct-和-union-的区别" class="headerlink" title="struct 和 union 的区别"></a>struct 和 union 的区别</h2><ol><li>union 是联合体，struct 是结构体。union 中的所有成员变量<strong>共享同一段内存空间</strong>，struct 中的每个成员变量<strong>独占内存空间</strong>。</li><li>联合体和结构体<strong>都是由若干个数据类型不同的数据成员组成</strong>。使用时，联合体<strong>只有一个有效</strong>的成员；而结构体<strong>所有的成员都有效</strong>。</li><li>对联合体的不同成员赋值，将会对<strong>覆盖</strong>其他成员的值，而对于结构体的对不同成员赋值时，<strong>相互不影响</strong>。</li><li>联合体的大小为其内部所有<strong>变量的最大值</strong>，按照<strong>最大类型的倍数进行分配大小</strong>；结构体分配内存的大小遵循<strong>内存对齐原则</strong>。</li><li>struct 可以定义<strong>变长数组成员变量</strong> int a[]，union 中<strong>不能包含有这种不确定长度的变量</strong>。</li></ol><h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h2><p>C++ 中<strong>为了兼容 C 语言而保留了 C 语言的 struct 关键字</strong>，并且加以扩充。在 C 语言中，struct 只能包含成员变量，不能包含成员函数。而在 C++ 中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。<br>C++ 中的 struct 和 class 基本是通用的，唯有几个细节不同：</p><ol><li>class 中类中的成员<strong>默认访问权限</strong>都是 private 属性的；而在 struct 中结构体中的成员默认都是 public 属性的。</li><li>class <strong>默认继承权限</strong>是 private 继承，而 struct 继承默认是 public 继承。</li><li>class 可以用于定义<strong>模板参数</strong>，struct 不能用于定义模板参数。</li></ol><h2 id="volatile-的作用与使用场景"><a href="#volatile-的作用与使用场景" class="headerlink" title="volatile 的作用与使用场景"></a>volatile 的作用与使用场景</h2><ol><li>volatile 的简介：</li></ol><p>当对象的值可能<strong>在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化</strong>。volatile 关键字修饰变量后，提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会<strong>直接从变量地址中读取数据</strong>。如果没有 volatile 关键字，则编译器可能<strong>优化</strong>读取和存储，可能<strong>暂时使用寄存器中的值</strong>，如果这个变量由别的程序更新了的话，将出现不一致的现象。<br>使用 volatile 关键字试图阻止编译器过度优化，volatile 主要作用如下：</p><ol><li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）</li><li>阻止编译器调整操作 volatile 变量的指令排序。</li><li>volatile 的作用：</li></ol><p>读取变量时，阻止编译器对缓存的优化：volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：<strong>操作系统、硬件或者其它线程</strong>等。遇到这个关键字声明的变量，编译器对访问该变量的代码就<strong>不再进行优化</strong>，从而可以提供对特殊地址的稳定访问。比如声明时 volatile 变量，int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是<strong>重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。</p><ol start="3"><li>volatile 的应用场景：</li></ol><p>在实际场景中除了<strong>操纵硬件</strong>需要用到 volatile 以外，更多的可能是多线程并发访问<strong>共享变量</strong>时，一个线程改变了变量的值，怎样让改变后的值对其它线程可见，此时我们就需要使用 volatile 进行修饰。一般说来，volatile 用在如下的几个地方：</p><ol><li><strong>中断服务程序</strong>中修改的供其它程序检测的变量需要加 volatile；</li><li><strong>多任务环境下</strong>各任务间共享的标志应该加 volatile；</li><li>存储器映射的<strong>硬件寄存器</strong>通常也要加 volatile 说明，因为每次对它的读写都可能有不同意义；</li></ol><h2 id="返回函数中的静态变量的地址会发生什么"><a href="#返回函数中的静态变量的地址会发生什么" class="headerlink" title="返回函数中的静态变量的地址会发生什么"></a>返回函数中的静态变量的地址会发生什么</h2><p>前面的章节中讲过，静态局部变量存在<strong>静态区</strong>，程序初始化时则已经创建了改变量，变量的生存周期为<strong>整个程序的生命周期</strong>。在函数中定义静态局部变量 var，使得离开该函数的作用域后，该变量<strong>不会销毁</strong>，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果，该静态局部变量直到程序运行结束后才销毁。<br>需要注意的是，全局静态对象在程序初始化时，则进行了初始化。局部静态对象的初始化在第一次进入函数内部时，才会调用对象的构造函数进行初始化。<strong>程序退出时，先释放静态局部变量，再释放全局静态变量。</strong></p><h2 id="extern-C-的作用"><a href="#extern-C-的作用" class="headerlink" title="extern C 的作用"></a>extern C 的作用</h2><p>C 和 C++ 对同一个函数经过编译后生成的函数名是不同的，由于 <strong>C++ 支持函数重载</strong>，因此编译器编译函数的过程中会将函数的<strong>参数类型也加到编译后的函数名中</strong>，而不仅仅是原始的函数名。<br>由于 C 语言并<strong>不支持函数重载</strong>，在 C 语言中<strong>函数不能重名</strong>，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在 C++ 中调用一个使用 C 语言编写的模块中的某个函数 test，C++ 是根据 C++ 的函数名称修饰方式来查找并链接这个函数，去在生成的符号表查找 _Z4testv 这个函数的代码，此时就<strong>会发生链接错误</strong>。而此时我们用 extern C 声明，那么在<strong>链接时</strong>，C++ 编译器则<strong>按照 C 语言的函数命名规则 test 去符号表中查找对应的函数</strong>。因此当 C++ 程序需要调用 C 语言编写的函数，C++ 使用链接指示，即 extern “C” 指出任意非 C++ 函数所用的语言。</p><h2 id="sizeof-1-x3D-x3D-1-在C和C-中的结果"><a href="#sizeof-1-x3D-x3D-1-在C和C-中的结果" class="headerlink" title="sizeof(1 &#x3D;&#x3D; 1) 在C和C++中的结果"></a>sizeof(1 &#x3D;&#x3D; 1) 在C和C++中的结果</h2><p>sizeof 接受的参数<strong>可以是对象也可以是表达式</strong>，但是 sizeof(expression) 在运行时不会对接受的表达式进行计算，编译器<strong>只会推导表达式的类型</strong>从而计算占用的字节大小；</p><ul><li>由于 C 语言没有 bool 类型，用整形表示布尔型，因此 sizeof(1 &#x3D;&#x3D; 1) 返回 4；</li><li>由于 C++ 语言有 bool 类型，布尔型占 1 个字节，因此 sizeof(1 &#x3D;&#x3D; 1) 返回 1。</li></ul><h2 id="memmove-函数的底层原理"><a href="#memmove-函数的底层原理" class="headerlink" title="memmove 函数的底层原理"></a>memmove 函数的底层原理</h2><p>memmove 用于<strong>拷贝字节</strong>，如果目标区域和源区域有重叠的话，memmove 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 <strong>memcpy 函数功能相同</strong>。面试时会经常要求实现 memmove 函数，在实现的时候需要特殊处理地址重叠的情况。</p><ol><li><p>memcpy实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">my_memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">assert</span>(src != <span class="hljs-literal">nullptr</span>&amp;&amp;dest != <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//判断dest指针和src指针是否为空，若为空抛出异常</span><br><span class="hljs-type">char</span>* tmp_dest = (<span class="hljs-type">char</span>*)dest;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* tmp_src = (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)src;<br><span class="hljs-comment">//将指针dest和指针src由void强转为char，</span><br><span class="hljs-comment">//使得每次均是对内存中的一个字节进行拷贝</span><br><span class="hljs-keyword">while</span> (count--)<br>*tmp_dest++ = *tmp_src++;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>memmove实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">void</span>* src, <span class="hljs-type">size_t</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span>* ret = dest;<br><span class="hljs-built_in">assert</span>(dest);<br><span class="hljs-built_in">assert</span>(src);<br> <br><span class="hljs-keyword">if</span> (dest &lt; src)<span class="hljs-comment">//1 前-&gt;后</span><br>&#123;<br><span class="hljs-keyword">while</span>(num--)<br>&#123;<br>*(<span class="hljs-type">char</span>*)dest = *(<span class="hljs-type">char</span>*)src;<br>dest = (<span class="hljs-type">char</span>*)dest + <span class="hljs-number">1</span>;<br>src = (<span class="hljs-type">char</span>*)src + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 后-&gt;前</span><br>&#123;<br><span class="hljs-keyword">while</span> (num--)<br>&#123;<br>*((<span class="hljs-type">char</span>*)dest + num) = *((<span class="hljs-type">char</span>*)src + num);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="strcpy-函数的缺陷"><a href="#strcpy-函数的缺陷" class="headerlink" title="strcpy 函数的缺陷"></a>strcpy 函数的缺陷</h2><ol><li>strcpy 函数的实现：</li></ol><p>strcpy 是 C++ 语言的一个标准函数 ，strcpy 把含有 ‘\0’ 结束符的字符串复制到另一个地址空间，返回值的类型为 char*，返回值为拷贝后的字符串的首地址。</p><ol start="2"><li>strcpy 函数的缺陷：</li></ol><p>strcpy 函数<strong>不检查目的缓冲区的大小边界</strong>，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，<strong>会导致其他变量被覆盖</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> var = <span class="hljs-number">0x11112222</span>;<br>    <span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : var &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : arr &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;<br>    <span class="hljs-built_in">strcpy</span>(arr, <span class="hljs-string">&quot;hello world!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;var:&quot;</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; <span class="hljs-comment">// 将变量 var 以 16 进制输出</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;arr:&quot;</span> &lt;&lt; arr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Address : var 0x23fe4c</span><br><span class="hljs-comment">Address : arr 0x23fe42</span><br><span class="hljs-comment">var:11002164</span><br><span class="hljs-comment">arr:hello world!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：从上述代码中可以看出，变量 var 的后六位被字符串 “hello world!” 的 “d!\0” 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：\0(0x00)，!(0x21)，d(0x64)。<br>原因：变量 arr 只分配的 10 个内存空间，通过上述程序中的地址可以看出 arr 和 var 在内存中是连续存放的，但是在调用 strcpy 函数进行拷贝时，源字符串 “hello world!” 所占的内存空间为 13，因此在拷贝的过程中会占用 var 的内存空间，导致 var 的后六位被覆盖。由于 strcpy 函数存在一定的安全风险，如果使用不当容易出现安全问题，利用 strcpy 的特性可以编写 shellcode 来进行缓冲区溢出攻击。在大多数工程代码中，<strong>为了保证代码的健壮性和安全性，一般会使用 strncpy 代替 strcpy</strong>。</p><h2 id="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢"><a href="#在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢" class="headerlink" title="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢"></a>在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢</h2><ol><li>需要返回<strong>函数内局部变量的内存</strong>的时候用指针。使用指针传参需要<strong>开辟内存</strong>，用完要记得释放指针，不然会内存泄漏。而<strong>返回局部变量的引用是没有意义的</strong>；</li><li>对栈空间大小比较敏感（比如<strong>递归</strong>）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小；</li><li><strong>类对象</strong>作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li></ol><h2 id="区别以下指针类型"><a href="#区别以下指针类型" class="headerlink" title="区别以下指针类型"></a>区别以下指针类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>]; <span class="hljs-comment">// p是一个大小为10的数组，数组中的每个元素是一个int指针</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>];<span class="hljs-comment">// p是一个指针，指向大小为10的int数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">// p是一个函数名，参数为int，返回值为int*</span><br><span class="hljs-built_in">int</span> (*p)(<span class="hljs-type">int</span>);<span class="hljs-comment">// p是一个函数指针，参数为int，返回值为int</span><br></code></pre></td></tr></table></figure><h2 id="被free回收的内存是立即返还给操作系统吗"><a href="#被free回收的内存是立即返还给操作系统吗" class="headerlink" title="被free回收的内存是立即返还给操作系统吗"></a>被free回收的内存是立即返还给操作系统吗</h2><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就<strong>避免了频繁的系统调用</strong>，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><h2 id="宏定义和函数有何区别"><a href="#宏定义和函数有何区别" class="headerlink" title="宏定义和函数有何区别"></a>宏定义和函数有何区别</h2><ol><li>宏在<strong>预处理阶段</strong>完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更<strong>快</strong>；函数调用在运行时需要<strong>跳转</strong>到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏定义参数没有类型，不进行<strong>类型检查</strong>；函数参数具有类型，需要检查类型。</li><li>宏定义<strong>不要在最后加分号</strong>。</li></ol><h2 id="宏定义和typedef区别"><a href="#宏定义和typedef区别" class="headerlink" title="宏定义和typedef区别"></a>宏定义和typedef区别</h2><ol><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于<strong>定义类型别名</strong>。</li><li>宏替换发生在<strong>预处理</strong>，属于文本插入替换；typedef是<strong>编译</strong>的一部分。</li><li>宏不检查类型；typedef会检查数据类型。</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li><li>注意对指针的操作，typedef char _ p_char和#define p_char char _区别巨大。</li></ol><h2 id="变量声明和定义区别"><a href="#变量声明和定义区别" class="headerlink" title="变量声明和定义区别"></a>变量声明和定义区别</h2><ol><li>声明仅仅是把变量的<strong>声明的位置及类型</strong>提供给编译器，并不分配内存空间；定义要在定义的地方为其<strong>分配存储空间</strong>。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li></ol><h2 id="strlen和sizeof区别"><a href="#strlen和sizeof区别" class="headerlink" title="strlen和sizeof区别"></a>strlen和sizeof区别</h2><ol><li>sizeof是<strong>运算符</strong>，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的<strong>库函数</strong>。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串</li><li>因为<strong>sizeof值在编译时确定</strong>，所以不能用来得到动态分配（运行时分配）存储空间的大小</li></ol><h2 id="a和-amp-a有什么区别"><a href="#a和-amp-a有什么区别" class="headerlink" title="a和&amp;a有什么区别"></a>a和&amp;a有什么区别</h2><p>假设数组int a[10]; int (*p)[10] &#x3D; &amp;a;其中：</p><ol><li>a是数组名，是数组首元素地址，+1表示地址值加上一个<strong>int类型</strong>的大小，如果a的值是0x00000001，<strong>加1</strong>操作后变为0x00000005。*(a + 1) &#x3D; a[1]。 </li><li>&amp;a是数组的指针，其<strong>类型为int (_)[10]（_就是前面提到的数组指针），其</strong>加1**时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。 </li><li>若(int _)p ，此时输出 _p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li></ol><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象及其三大特征"><a href="#面向对象及其三大特征" class="headerlink" title="面向对象及其三大特征"></a>面向对象及其三大特征</h2><ol><li>面向对象：对象是指具体的某一个事物，这些<strong>事物的抽象就是类</strong>，类中包含<strong>数据（成员变量）</strong>和<strong>动作（成员方法）</strong>。</li><li>面向对象的三大特性：<ol><li>封装：将具体的实现过程和数据封装成一个函数，只能通过<strong>接口</strong>进行访问，<strong>降低耦合性</strong>。</li><li>继承：子类<strong>继承父类的特征和行为</strong>，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行<strong>重写</strong>，<strong>增强了类之间的耦合性</strong>，但是当父类中的成员变量、成员函数或者类本身被 <strong>final 关键字</strong>修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li><li>多态：多态就是<strong>不同继承类的对象，对同一消息做出不同的响应</strong>，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在 C++ 中多态一般是使用<strong>虚函数</strong>来实现的，使用基类指针调用函数方法时，如果该指针指向的是一个基类的对象，则调用的是基类的虚函数；如果该指针指向的是一个派生类的对象，则调用的是派生类的虚函数。</li></ol></li></ol><h2 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h2><ol><li>函数重载：<br>重载是指<strong>同一可访问区内</strong>被声明几个具有<strong>不同参数列表</strong>（参数的类型、个数、顺序）的<strong>同名函数</strong>，根据参数列表确定调用哪个函数，重载<strong>不关心函数返回类型</strong>。</li><li>函数隐藏：<br>函数隐藏是指派生类的函数<strong>屏蔽</strong>了与其同名的基类函数，只要是与基类同名的成员函数，不管参数列表是否相同，基类函数都会被隐藏。</li><li>函数重写（覆盖）：</li></ol><p>函数覆盖是指派生类中存在<strong>重新定义</strong>的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p><ol start="4"><li>重写和重载的区别：<ol><li>范围区别：对于类中函数的重载或者重写而言，<strong>重载</strong>发生在<strong>同一个类</strong>的内部，<strong>重写</strong>发生在<strong>不同的类</strong>之间（子类和父类之间）。</li><li>参数区别：重载的函数需要与原函数有<strong>相同的函数名、不同的参数列表，不关注函数的返回值类型</strong>；重写的函数的<strong>函数名、参数列表和返回值类型都需要和原函数相同</strong>，父类中被重写的函数需要<strong>有 virtual 修饰</strong>。</li><li>virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li></ol></li><li>隐藏和重写，重载的区别：<ol><li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li><li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但<strong>函数名</strong>一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</li><li>利用重写可以实现多态，而隐藏不可以。如果使用基类指针 p 指向派生类对象，利用这个指针调用函数时，对于隐藏的函数，会根据<strong>指针的类型</strong>去调用函数（静态绑定）；对于重写的函数，会根据指针所指<strong>对象的类型</strong>去调用函数（动态绑定）。重写必须使用 virtual 关键字，此时会更改派生类虚函数表的表项。</li><li>隐藏是发生在<strong>编译时</strong>，即在编译时由编译器实现隐藏，而重写一般<strong>发生运行</strong>时，即运行时会查找类的虚函数表，决定调用函数接口。</li></ol></li></ol><h2 id="多态及其实现方法"><a href="#多态及其实现方法" class="headerlink" title="多态及其实现方法"></a>多态及其实现方法</h2><p>多态性(polymorphism)可以简单地概括为<strong>“一个接口，多种方法”</strong>，它是面向对象编程领域的核心概念。<br>多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。</p><ol><li>编译时多态性（静态多态）：通过重载函数、类模板实现：先期联编 early binding</li><li>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</li></ol><p><strong>动态多态的实现原理：</strong><br>动态多态是通过<strong>虚函数</strong>实现的，虚函数的地址保存在<strong>虚函数表</strong>中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p><ol><li>在类中用 virtual 关键字声明的函数叫做虚函数；</li><li>存在虚函数的类都有一个<strong>虚函数表</strong>，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li><li>当基类指针指向派生类对象，基类指针调用虚函数时，该基类指针指的虚表指针实际指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数然后调用执行。</li></ol><h2 id="限制对象创建在堆或栈上"><a href="#限制对象创建在堆或栈上" class="headerlink" title="限制对象创建在堆或栈上"></a>限制对象创建在堆或栈上</h2><ol><li>限制对象只能建立在堆上：<ol><li>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。直接<strong>将类的构造函数设为私有</strong>，并提供另外的接口给外部调用。</li><li><strong>将析构函数设置为私有</strong>。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</li><li><strong>构造函数设置为 protected</strong>，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</li></ol></li><li>限制对象只能建立在栈上：</li></ol><p>将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p><h2 id="C-模板编程"><a href="#C-模板编程" class="headerlink" title="C++ 模板编程"></a>C++ 模板编程</h2><p>模板是 C++ 编程语言的一个特性，它允许函数和类使用泛型类型进行操作。这允许一个函数或类在许多不同的数据类型上工作，而无需为每个类型重写。<strong>C++ 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码，C++ 中使用 template 关键字。</strong>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。<br>共有三种模板：函数模板、类模板以及自 C++ 14 以来的变量模板：</p><ol><li>函数模板:<br>函数模板的行为<strong>类似于函数</strong>，只是模板可以有许多<strong>不同类型的参数</strong>。一个函数模板代表一个函数族。使用类型参数声明函数模板的格式是：</li><li>类模板：</li></ol><p>类模板提供了基于参数生成类的规范。类模板通常<strong>用于实现容器</strong>。类模板通过<strong>将一组给定的类型作为模板参数传递给它来实例化</strong>。C++ 标准库包含许多类模板，特别是改编自标准模板库的容器，例如 vector，list。</p><ol start="3"><li>变量模板：<br>在 C++14 以后，变量也可以参数化为特定的类型，这称为变量模板。</li></ol><h2 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h2><ol><li>虚函数：<br>被 virtual 关键字修饰的成员函数，C++ 的虚函数在运行时动态绑定，从而实现多态。</li><li>纯虚函数：<ol><li>纯虚函数在类中声明时，用 virtual 关键字修饰且加上 <strong>&#x3D;0</strong>，且没有函数的具体实现；</li><li>含有纯虚函数的类称为<strong>抽象类</strong>（只要含有纯虚函数这个类就是抽象类），类中只有<strong>接口定义</strong>，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，<strong>不能实例化对象</strong>。</li></ol></li></ol><p>对于抽象类需要说明的是:</p><ol><li>抽象类对象<strong>不能作为函数的参数，不能创建对象，不能作为函数返回类型</strong>；</li><li><strong>可以</strong>声明抽象类<strong>指针</strong>，可以声明抽象类的<strong>引用</strong>；</li><li>抽象类<strong>只能作为基类</strong>来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</li></ol><p>纯虚函数的作用：含有纯虚函数的基类要求<strong>任何派生类都要定义自己的实现方法</strong>，以实现多态性。实现了纯虚函数的子类，该<strong>纯虚函数在子类中就变成了虚函数</strong>。定义纯虚函数是为了<strong>实现统一的接口属性</strong>，用来规范派生类的接口属性，也即强制要求继承这个类的程序员必须实现这个函数。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以要求实现纯虚函数的属性，在面对对象设计中非常有用的一个特性。</p><h2 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h2><ol><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类（含有纯虚函数的类称为抽象基类）。</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上 virtual 关键字还需要加上 &#x3D;0;</li><li>虚函数必须实现，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</li></ol><h2 id="构造函数与析构函数是否可以定义为虚函数"><a href="#构造函数与析构函数是否可以定义为虚函数" class="headerlink" title="构造函数与析构函数是否可以定义为虚函数"></a>构造函数与析构函数是否可以定义为虚函数</h2><ol><li><p>构造函数一般不定义为虚函数:</p><ol><li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li><li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li><li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li><li>从类型上考虑：在创建对象时需要明确其类型。</li></ol></li><li><p>析构函数一般定义成虚函数：</p></li></ol><p>析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</p><h2 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h2><ol><li>空类的大小</li></ol><p>由于在实际程序中，空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以 sizeof(A) 的大小为 1。</p><ol start="2"><li>空类的成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;;                                       <span class="hljs-comment">// 缺省构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;tmp)&#123;&#125;;                           <span class="hljs-comment">// 拷贝构造函数</span><br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;;                                      <span class="hljs-comment">// 析构函数</span><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;tmp)&#123;&#125;;                <span class="hljs-comment">// 赋值运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;;             <span class="hljs-comment">// 取址运算符</span><br>    <span class="hljs-type">const</span> A *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;; <span class="hljs-comment">// 取址运算符（const 版本）</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h2><p>说明：类的大小是指类的<strong>实例化对象的大小</strong>，用 sizeof 对类型名操作时，结果是该类型的对象的大小。计算原则如下：</p><ol><li>遵循结构体的成员变量<strong>对齐</strong>原则。</li><li>与<strong>普通成员变量</strong>有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li><li><strong>虚函数</strong>对类的大小有影响，是因为虚函数表指针的影响。</li><li><strong>虚继承</strong>对类的大小有影响，是因为虚基表指针带来的影响。</li><li><strong>空类</strong>的大小是一个特殊情况，空类的大小为 1，空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以sizeof(A) 的大小为 1。</li></ol><h2 id="为什么拷贝构造必须声明为引用"><a href="#为什么拷贝构造必须声明为引用" class="headerlink" title="为什么拷贝构造必须声明为引用"></a>为什么拷贝构造必须声明为引用</h2><p>避免拷贝构造函数无限制的递归而导致栈溢出。</p><h2 id="成员初始化列表效率高的原因"><a href="#成员初始化列表效率高的原因" class="headerlink" title="成员初始化列表效率高的原因"></a>成员初始化列表效率高的原因</h2><p>对象的成员函数数据类型可分为语言内置类型和用户自定义类，对于用户自定义类型，利用成员初始化列表效率高。用户自定义类型如果使用类初始化列表，<strong>直接调用该成员变量对应的构造函数即完成初始化</strong>；如果在构造函数中初始化，由于 C++ 规定对象的成员变量的初始化动作发生在进入自身的构造函数本体之前，那么在执行构造函数之前<strong>首先调用默认的构造函数为成员变量设初值</strong>，在进入函数体之后，<strong>再显式调用该成员变量对应的构造函数</strong>。因此使用列表初始化会减少调用默认的构造函数的过程，效率更高一些。</p><h2 id="如何让类不被继承"><a href="#如何让类不被继承" class="headerlink" title="如何让类不被继承"></a>如何让类不被继承</h2><ol><li>final</li><li>使用友元、虚继承和私有构造函数来实现</li></ol><p>具体原因：</p><ol><li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li><li>B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，<strong>C 类的构造函数要负责 Base 类的构造</strong>，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li></ol><p>注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</p><h1 id="语言特性相关"><a href="#语言特性相关" class="headerlink" title="语言特性相关"></a>语言特性相关</h1><h2 id="左值与右值：区别、引用及转化"><a href="#左值与右值：区别、引用及转化" class="headerlink" title="左值与右值：区别、引用及转化"></a>左值与右值：区别、引用及转化</h2><ol><li>左值与右值:<ol><li>左值：<strong>指表达式结束后依然存在的持久对象</strong>。可以取地址，可以通过内置（不包含重载） &amp; 来获取地址，我们可以将一个右值赋给左值。</li><li>右值：<strong>表达式结束就不再存在的临时对象</strong>。不可取地址，不可以通过内置（不包含重载） &amp; 来获取地址。由于右值不可取地址，因此我们不能将任何值赋给右值。</li></ol></li><li>左值引用与右值引用<ol><li>左值引用<ol><li>可以区分为常量左值引用和非常量左值引用。<strong>左值引用的底层实现是指针实现</strong>。</li><li><strong>非常量左值引用</strong>只能绑定到非常量左值，不能绑定到常量左值和右值。如果绑定到非常量右值，就有可能指向一个已经被销毁的对象。</li><li><strong>常量左值引用</strong>能绑定到非常量左值，常量左值和右值；</li></ol></li><li>右值引用：<ol><li>右值引用 （Rvalue Referene） 是 C++ 11 中引入的新特性 , 它实现了<strong>转移语义 （Move Sementics）</strong>和<strong>完美转发 （Perfect Forwarding）</strong>，&amp;&amp; 作为右值引用的声明符。右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。<strong>右值引用只能绑定到一个将要销毁的对象上</strong>，因此<strong>可以自由地移动其资源</strong>。</li><li>从实践角度讲，它能够完美解决 C++ 中长久以来为人所诟病的<strong>临时对象效率问题</strong>。从语言本身讲，它健全了 C++ 中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从使用者的角度来看，可以获得效率的提升，避免对象在传递过程中重复创建。</li><li>右值引用两个主要功能：<ol><li><strong>消除</strong>两个对象交互时不必要的对象<strong>拷贝</strong>，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ol></li></ol></li></ol></li><li>左值转为右值</li></ol><p>我们可以通过 std::move 可以将一个<strong>左值强制转化为右值</strong>，继而可以通过右值引用使用该值，以用于移动语义，从而<strong>完成将资源的所有权进行转移</strong>。</p><ol start="4"><li>引用折叠<ol><li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;</li><li>所有的其他引用类型之间的叠加都将变成左值引用。T&amp; &amp;&amp;,T&amp;&amp; &amp;, T&amp;&amp; 折叠成 T&amp;。</li></ol></li><li>万能引用类型：</li></ol><p>在模板中 T&amp;&amp; t 在发生<strong>自动类型推断</strong>的时候，它是未定的引用类型（universal references），它既可以接受一个左值又可以接受一个右值。如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。</p><h2 id="move-的实现原理"><a href="#move-的实现原理" class="headerlink" title="move() 的实现原理"></a>move() 的实现原理</h2><ol><li>首先利用万能模板将传入的参数 t 进行处理，我们知道右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；对参数 t 做一次右值引用，根据引用折叠规则，右值的右值引用是右值引用，而左值的右值引用是普通的左值引用。万能模板既可以接受左值作为实参也可以接受右值作为实参。</li><li>通过 remove_refrence 移除引用，得到参数 t 具体的类型 type；</li><li>最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 type &amp;&amp; 右值引用。</li></ol><p>remove_reference 主要作用是解除类型中引用并返回变量的实际类型。</p><h2 id="完美转发的实现"><a href="#完美转发的实现" class="headerlink" title="完美转发的实现"></a>完美转发的实现</h2><p>forward 保证了在转发时左值右值特性不会被更改，实现完美转发。主要解决<strong>引用函数参数为右值时，传进来之后有了变量名就变成了左值</strong>。</p><p>forward 的实现：<br>forward <strong>利用引用折叠的特性</strong>，对参数 t 做一次右值引用，根据引用折叠规则，右值的右值引用是右值引用，而左值的右值引用是普通的左值引用。forward 的实现有两个函数：<br>第一个，接受的参数是左值引用，只能接受左值。<br>第二个，接受的参数是右值引用，只能接受右值。</p><p><strong>forward 与 move 最大的区别是</strong>，move 在进行类型转换时，利用 remove_reference 将外层的引用全部去掉，这样可以将 t 强制转换为指定类型的右值引用，而 forward 则利用引用折叠的技巧，巧妙的保留了变量原有的属性。</p><h2 id="悬空指针和野指针"><a href="#悬空指针和野指针" class="headerlink" title="悬空指针和野指针"></a>悬空指针和野指针</h2><ol><li>悬空指针</li></ol><p>若指针指向一块内存空间，当这块内存空间<strong>被释放</strong>后，该指针<strong>依然指向这块内存空间</strong>，此时，称该指针为“悬空指针”。如果对悬空指针再次释放可能会出现不可预估的错误，比如可能该段内存被别的程序申请使用了，而此时对该段内存进行释放可能会产生不可预估的后果。</p><ol start="2"><li>野指针</li></ol><p>野指针是指不确定其指向的指针，<strong>未初始化的指针</strong>为“野指针”，未初始化的指针的初始值可能是随机的，如果使用未初始化的指针可能会导致段错误，从而程序会崩溃。</p><ol start="3"><li>如何避免野指针：<br>指针在定义时即初始化，指针在释放完成后，需要将其置为空。</li></ol><h2 id="nullptr-和-NULL-的区别"><a href="#nullptr-和-NULL-的区别" class="headerlink" title="nullptr 和 NULL 的区别"></a>nullptr 和 NULL 的区别</h2><ol><li>NULL：预处理变量，是一个<strong>宏</strong>，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。</li><li>nullptr：C++ 11 中的<strong>关键字</strong>，是一种特殊类型的<strong>字面值</strong>，可以被转换成任意其他类型。</li></ol><p>nullptr 的优势：</p><ol><li>有<strong>类型</strong>，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的<strong>健壮性</strong>。</li><li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。</li></ol><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名；</li><li>指针可以有多级，引用只有一级；</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化；</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变；</li><li>sizeof 指针得到的是本指针的大小，sizeof 引用得到的是引用所指向变量的大小；</li><li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，<strong>但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以</strong>；</li></ol><h2 id="C-的四种强制转换类型"><a href="#C-的四种强制转换类型" class="headerlink" title="C++的四种强制转换类型"></a>C++的四种强制转换类型</h2><ol><li>static_cast：</li></ol><p>static_cast 是“静态转换”的意思，也即在<strong>编译期间</strong>转换，转换失败的话会抛出一个编译错误。一般用于如下:</p><ol><li>用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</li><li>用于基本数据类型的转换。</li><li>用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。</li><li>可以将空指针转化成目标类型的空指针。</li><li>可以将任何类型的表达式转化成 void 类型。</li><li>不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。</li><li>const_cast：</li></ol><p>主要用于 const 与非 const、volatile 与非 volatile 之间的转换。强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p><ol start="3"><li>reinterpret_cast：</li></ol><p>改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。reinterpret_cast 转换时，执行的过程是<strong>逐个比特复制</strong>的操作。</p><ol start="4"><li>dynamic_cast：<ol><li>其他三种都是<strong>编译时</strong>完成的，动态类型转换是在程序<strong>运行时处理</strong>的，运行时会进行类型检查。</li><li>只能用于带有虚函数的<strong>基类或派生类的指针或者引用对象的转换</strong>，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。</li><li>在向上进行转换时，即派生类的指针转换成基类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</li></ol></li></ol><h2 id="结构体相等的判断方式及-memcmp-函数的使用"><a href="#结构体相等的判断方式及-memcmp-函数的使用" class="headerlink" title="结构体相等的判断方式及 memcmp 函数的使用"></a>结构体相等的判断方式及 memcmp 函数的使用</h2><p>符号重载：<br>需要重载操作符 &#x3D;&#x3D; 判断两个结构体是否相等，<strong>不能用函数 memcmp 来判断两个结构体是否相等</strong>，因为 memcmp 函数是<strong>逐个字节</strong>进行比较的，而结构体存在内存空间中保存时存在<strong>字节对齐</strong>，字节对齐时补的字节<strong>内容是随机的</strong>，会产生垃圾值，所以无法比较。</p><h2 id="函数模板与类模板的区别"><a href="#函数模板与类模板的区别" class="headerlink" title="函数模板与类模板的区别"></a>函数模板与类模板的区别</h2><ol><li><strong>实例化方式</strong>不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li><li><strong>实例化的结果</strong>不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li><li><strong>默认参数</strong>：函数模板不允许有默认参数，类模板在模板参数列表中可以有默认参数。</li><li><strong>特化</strong>：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li><li>调用方式不同：函数模板可以进行<strong>类型推导</strong>，可以隐式调用，也可以显式调用；类模板只能<strong>显式</strong>调用。</li></ol><h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><p>所谓特化，就是将泛型的东西搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。</p><ol><li>模板特化的原因：因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。</li><li>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化<ol><li>函数模板特化：将函数模板中的<strong>全部</strong>类型进行特例化，称为函数模板特化。</li><li>类模板特化：将类模板中的<strong>部分</strong>或<strong>全部</strong>类型进行特例化，称为类模板特化。</li></ol></li></ol><p>特化分为全特化和偏特化：</p><ol><li>全特化：模板中的模板参数全部特例化。</li><li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li></ol><p>说明：要区分下函数重载与函数模板特化<br>定义函数模板的特化版本，本质上是<strong>接管了编译器</strong>的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并<strong>不影响函数匹配</strong>。</p><h2 id="switch-的-case-里为何不建议定义变量"><a href="#switch-的-case-里为何不建议定义变量" class="headerlink" title="switch 的 case 里为何不建议定义变量"></a>switch 的 case 里为何不建议定义变量</h2><p>switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的。</p><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即<strong>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式</strong>。迭代器只是一种概念上的抽象，具有迭代器通用功能和方法的对象都可以叫做迭代器。迭代器有很多不同的能力，可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p><ol><li>输入迭代器(Input Iterator)：只能向前单步迭代元素，<strong>不允许修改</strong>由该迭代器所引用的元素；</li><li>输出迭代器(Output Iterator)：只能向前单步迭代元素，对由该迭代器所引用的元素<strong>只有写权限</strong>；</li><li>向前迭代器(Forward Iterator)：该迭代器可以在一个区间中进行读写操作，它拥有输入迭代器的所有特性和输出迭代器的部分特性，以及<strong>向前单步迭代</strong>元素的能力；</li><li>双向迭代器(Bidirectional Iterator)：在向前迭代器的基础上<strong>增加了向后单步迭代</strong>元素的能力；</li><li>随机访问迭代器(Random Access Iterator)：不仅综合以后 4 种迭代器的所有功能，还可以像指针那样进行算术计算；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091923258.png" alt="image.png"></p><h2 id="泛型编程如何实现"><a href="#泛型编程如何实现" class="headerlink" title="泛型编程如何实现"></a>泛型编程如何实现</h2><p>泛型编程实现的基础：<strong>模板</strong>。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会实例化为特定的类或者函数。<br>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p><ol><li>容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。</li><li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li><li>模板：可参考本章节中的模板相关问题。</li></ol><p>泛型编程优缺点：</p><ol><li>通用性强：泛型算法是<strong>建立在语法一致性</strong>上，运用到的<strong>类型集</strong>是无限的&#x2F;非绑定的。</li><li>效率高：<strong>编译期能确定静态类型信息</strong>，其效率与针对某特定数据类型而设计的算法相同。</li><li>类型检查严：静态类型信息被完整的保存在了<strong>编译期</strong>，在编译时可以发现更多潜在的错误。</li><li><strong>二进制复用性差</strong>：泛型算法是建立在语法一致性上，语法是代码层面的，语法上的约定无法体现在机器指令中。泛型算法实现的库，其源代码基本上是必须公开的，引用泛型中库都需要<strong>重新编译生成新的机器指令（实例化）</strong>。而传统的 C 库全是以二进制目标文件形式发布的，需要使用这些库时直接动态链接加载使用即可，不需要进行再次编译。</li></ol><h2 id="什么是类型萃取"><a href="#什么是类型萃取" class="headerlink" title="什么是类型萃取"></a>什么是类型萃取</h2><p>类型萃取（type traits）<strong>使用模板技术来萃取类型</strong>（包含自定义类型和内置类型）的某些特性，<strong>用以判断该类型是否含有某些特性</strong>，从而在泛型算法中来<strong>对该类型进行特殊的处理用来提高效率或者得到其他优化</strong>。简单的来说类型萃取即确定变量去除引用修饰以后的真正的变量类型或者 CV 属性。C++ 关于 type traits 的详细使用技巧可以参考头文件 #include <type_traits>。</p><p>为什么需要 type traits：<br>对于普通的变量来说，确定变量的类型比较容易，比如 int a &#x3D; 10; 可以很容易确定变量的实际类型为 int，但在使用模板时确定变量的类型就比较困难，模板传入的类型为不确定性。为什么需要确定变量的实际类型？因为<strong>模板函数针对传入的对不同的类型可能作出不同的处理</strong>，这就需要我们在<strong>处理函数模板对传入的参数类型和特性进行提取</strong>。比如自定义拷贝函数 copy(T *dest, const T *src) ，如果 T 此时为 int 类型，则此时我们只需要 *dest &#x3D; *src 即可，但是如果我们此时传入的 T 为 char * 字符串类型时，则就不能简单进行指针赋值，<strong>所以函数在实际处理时则需要对传入的类型进行甄别</strong>，从而针对不同的类型给予不同的处理，这样才能使得函数具有通用性。</p><p>C++标准模板库中大量使用了traits<strong>。将因为模板形参（包括类型形参、非类型形参）不同而导致的不同抽取到新的模板（即traits）中去</strong>；然后<strong>通过traits的模板特化来实现针对具体情况的优化实现</strong>。Traits作为模板类，既声明了统一的接口（包括类型、枚举、函数方法等），又可以通过模板特化，针对不同数据类型或其他模板参数，为类、函数或者通用算法在因为使用的数据类型不同而导致处理逻辑不同时，提供了区分不同类型的具体细节，从而把这部分用Traits实现的功能与其它共同的功能区分开来。例如，容器的元素的不同数据类型，或者iostream是使用char还是wchar_t。<strong>一个traits包括了enum、typedef、模板偏特化（template partial specialization）</strong>。</p><ol><li>enum定义了各种类的标识的统一表示；</li><li>typedef定义了各个类的各自不同的类型定义，这对于使用模板元编程（template meta-programming）的灵活性非常重要；</li><li>模板偏特化用于实现各个类的不同功能</li></ol><p>traits技法利用“内嵌型别”的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。<br>iterator_traits被称为特性萃取机，能够方便的让外界获取以下5种型别：</p><ol><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：三两句说不清楚，建议看书</li></ol>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webserver面试题汇总</title>
    <link href="/posts/undefined/"/>
    <url>/posts/undefined/</url>
    
    <content type="html"><![CDATA[<p>项目描述：Linux环境下基于C++的轻量级多线程Web服务器，应用层实现了一个简单的HTTP服务器，支持静态资源访问<br>的功能。<br>工作内容：</p><ol><li>利用IO复用技术Epoll（ET模式）与线程池实现单Reactor多线程<strong>并发模型</strong>；</li><li>利用正则表达式与<strong>状态机</strong>解析HTTP请求报文，实现处理静态资源的请求，利用<strong>分散写和mmap</strong>优化大文件传输；</li><li>利用容器实现动态增长的<strong>用户空间缓冲区</strong>；</li><li>基于小根堆实现的<strong>定时器</strong>，实现应用层的保活机制；</li><li>利用<strong>单例模式</strong>与阻塞队列实现异步的<strong>日志系统</strong>；</li><li>利用Webbench进行<strong>压力测试</strong>。</li></ol><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="为什么要做这样一个项目？"><a href="#为什么要做这样一个项目？" class="headerlink" title="为什么要做这样一个项目？"></a>为什么要做这样一个项目？</h2><p>研究生期间主要学习的是机器学习方向，本科虽然学过C++，但一是时间太久有点忘了，二是对网络编程不了了解，所以在github上找了一个开源的webserver项目，想要复习巩固一下C++相关的知识，学习一下网络编程。</p><h2 id="介绍下你的项目"><a href="#介绍下你的项目" class="headerlink" title="介绍下你的项目"></a>介绍下你的项目</h2><ol><li>本项目主要是对浏览器的HTTP请求进行解析处理，处理完之后返回给客户端一个响应，如图片、文字、视频等；</li><li>服务端使用socket通信，利用IO多路复用，可以同时处理多个请求；</li><li>项目采用Reactor模式，主线程负责监听IO事件，收到事件后，根据事件类型处理，如果是连接建立事件，则主线程将accpet返回的套接字添加到epoll中进行管理，如果不是则根据事件类型将任务添加到任务队列中；</li><li>任务队列里面有了任务之后，线程池中睡眠的工作线程将被唤醒，进行数据读取以及后续的业务处理，利用状态机解析HTTP报文；</li><li>使用基于小根堆的定时器实现应用层保活机制，当客户端和服务端长达一定时间没有进行数据交互时，关闭连接。</li></ol><h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><h2 id="服务器并发量测试过吗？怎么测试的？"><a href="#服务器并发量测试过吗？怎么测试的？" class="headerlink" title="服务器并发量测试过吗？怎么测试的？"></a>服务器并发量测试过吗？怎么测试的？</h2><p>原项目用webbench测试，4核8G的服务器能达到百万级QPS，我在自己的服务器上使用webbench测试过，client数量达到4800是0 failed，但到4900，fork就会失败，提示进程已达上限。这时的QPS只有2500左右。</p><h2 id="webbench是什么？介绍一下原理"><a href="#webbench是什么？介绍一下原理" class="headerlink" title="webbench是什么？介绍一下原理"></a>webbench是什么？介绍一下原理</h2><ol><li>WebBench是一款在Linux下使用非常简单的压力测试工具。</li><li>原理：父进程 fork 若干个子进程，每个子进程在用户要求时间或默认的时间内对目标 web 循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。Webbench最多可以模拟3万个并发连接去测试网站的负载能力。</li></ol><p>-c ：子进程的个数，即并发数<br>-t ：运行webbench的时间</p><h2 id="wrk-工具"><a href="#wrk-工具" class="headerlink" title="wrk 工具"></a>wrk 工具</h2><p>wrk 工具，它是一款简单的 HTTP 压测工具，它能够在单机<strong>多核 CPU</strong>的条件下，使用系统自带的高性能 I&#x2F;O 机制，通过<strong>多线程和事件模式</strong>，对目标机器产生大量的负载。</p><h2 id="测试的时候有没有遇到问题？"><a href="#测试的时候有没有遇到问题？" class="headerlink" title="测试的时候有没有遇到问题？"></a>测试的时候有没有遇到问题？</h2><ol><li>文件描述符的最大数量</li><li>全连接队列的大小（）</li><li>服务端端口数（49152-65535）</li><li>服务器进程上限</li><li>Bug：使用Webbench对服务器进行压力测试，创建1000个客户端，并发访问服务器10s，正常情况下有接近8万个HTTP请求访问服务器。结果显示仅有7个请求被成功处理，0个请求处理失败，服务器也没有返回错误。此时，从浏览器端访问服务器，发现该请求也不能被处理和响应，必须将服务器重启后，浏览器端才能访问正常。</li></ol><p>解决办法：</p><ol><li>排查：通过查询服务器运行日志，对服务器接收HTTP请求连接，HTTP处理逻辑两部分进行排查。日志中显示，7个请求报文为:GET &#x2F; HTTP&#x2F;1.0的HTTP请求被正确处理和响应，排除HTTP处理逻辑错误。重点放在接收HTTP请求连接部分。其中，服务器端接收HTTP请求的连接步骤为socket -&gt; bind -&gt; listen -&gt; accept</li><li>错误原因：错误使用epoll的ET模式。ET边缘触发模式epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件。必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain。当连接较少时，队列不会变满，即使listenfd设置成ET非阻塞，不使用while一次性读取完，也不会出现Bug。若此时1000个客户端同时对服务器发起连接请求，连接过多会造成established 状态的连接队列变满。但accept并没有使用while一次性读取完，只读取一个。因此，连接过多导致TCP就绪队列中剩下的连接都得不到处理，同时新的连接也不会到来。</li><li>解决方案：将listenfd设置ET非阻塞模式下while包裹accept即可解决问题。</li></ol><h2 id="怎样应对服务器的大流量、高并发"><a href="#怎样应对服务器的大流量、高并发" class="headerlink" title="怎样应对服务器的大流量、高并发"></a>怎样应对服务器的大流量、高并发</h2><ol><li>客户端<ol><li>尽量减少请求数：依靠客户端自身的缓存或处理能力</li><li>尽量对减少服务端资源的不必要消耗：重复利用某些资源，如连接池</li></ol></li><li>服务端<ol><li>增大资源供给：更大的网络带宽，使用更高配置的服务器</li><li>请求分流：使用集群，分布式的系统架构</li><li>应用优化：使用更高效的编程语言，优化处理业务逻辑的算法</li></ol></li></ol><h1 id="综合能力"><a href="#综合能力" class="headerlink" title="综合能力"></a>综合能力</h1><h2 id="项目的亮点"><a href="#项目的亮点" class="headerlink" title="项目的亮点"></a>项目的亮点</h2><ol><li>采用Reactor并发模型</li><li>使用Epoll边缘触发+EPOLLONESHOT，非阻塞IO</li><li>为充分利用多核CPU的性能，以多线程的形式实现服务器，并实现线程池避免线程频繁创建销毁造成的系统开销</li><li>实现基于小根堆的定时器，实现应用层保活机制</li><li>实现可以自动增长的缓冲区，作为HTTP连接的输入和输出缓冲区</li></ol><h2 id="你的项目解决了哪些其他同类项目没有解决的问题？"><a href="#你的项目解决了哪些其他同类项目没有解决的问题？" class="headerlink" title="你的项目解决了哪些其他同类项目没有解决的问题？"></a>你的项目解决了哪些其他同类项目没有解决的问题？</h2><p>没有，造轮子😄</p><h2 id="说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？"><a href="#说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？" class="headerlink" title="说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？"></a>说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？</h2><ol><li>浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理</li><li>工作线程取出任务后，调用OnRead_函数，通过主、从状态机对请求报文进行解析</li><li>解析完之后，跳转OnProcess_调用process函数生成响应报文，通过MakeResponse将响应写入buffer，返回给浏览器端。</li></ol><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><ol><li>服务器运行一会之后报段错误，核心已转储，在终端将core文件大小设置为1024后仍然不能生成core文件。ubuntu 的 cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern输出|&#x2F;usr&#x2F;share&#x2F;apport&#x2F;apport %p %s %c %d %P %E，查了之后发现ubuntu预装了apport错误收集系统，sudo service apport stop之后就可以了。</li></ol><p>vec[-1] 不报错</p><ol start="2"><li>写服务器的第一个版本时，使用的是“边沿触发（EPOLLET）+非阻塞IO”模式，但是只调用了一次IO，没有循环遍历直到数据为空。这样就产生了一个问题，如下：如果给了1000个连接请求，在60S时间内，但是实际接收的连接数不到一半。这是因为每次触发只调用一次IO时，一次只能accept一个连接请求，那么需要不断的连接请求触发，才能继续accept连接，效率非常低。但是使用了while循环遍历直至数据为空之后，同样的测试，服务器能接收全部的连接请求，其原因就是一次触发就可以处理该次触发所接收的所有连接请求，大大减少了epoll_wait系统调用，减小了内核资源消耗。</li></ol><h2 id="有待改进的地方"><a href="#有待改进的地方" class="headerlink" title="有待改进的地方"></a>有待改进的地方</h2><p>「单 Reactor」的模式存在一个问题，因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。这个也是WebServer这个项目存在的瓶颈之一。</p><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h2 id="简单说一下服务器使用的并发模型？"><a href="#简单说一下服务器使用的并发模型？" class="headerlink" title="简单说一下服务器使用的并发模型？"></a>简单说一下服务器使用的并发模型？</h2><ol><li>项目采用Reactor模式，主线程负责监听IO事件，收到事件后，根据事件类型处理，如果是连接建立事件，则主线程将accpet返回的套接字添加到epoll中进行管理，如果不是则根据事件类型将任务添加到任务队列中；</li><li>任务队列里面有了任务之后，线程池中睡眠的工作线程将被唤醒，进行数据读取以及后续的业务处理，利用状态机解析HTTP报文；</li></ol><p><strong>主线程：</strong></p><ol><li>主线程中，epoll监听套接字，处理就绪套接字上的IO事件，包括已连接的客户请求（发送报文）或者新的客户连接请求；</li><li>如果是新的客户连接请求则创建一个连接套接字fd，并创建一个HttpConn对象与对应，为该Http连接添加定时器，设置超时时间，当超过一段时间没有请求时关闭该http连接，并将fd添加到epoll中进行管理；</li><li>如果是已连接的客户请求，则延长这个http连接的定时器有效期，并向线程池的任务队列中添加任务，epollin事件添加read任务，epollout事件添加write任务；</li><li>同时主线程还维护一个小顶堆实现的定时器，删除超时节点，实现应用层的保活机制。</li></ol><p><strong>子线程：</strong></p><ol><li>线程池中的工作线程等待任务队列不为空，拿到锁后从任务队列中取出任务，再释放锁，如果是read任务，则读取客户端发送过来的数据（ET模式），再进行后续业务逻辑的处理（如：解析请求、初始化响应）；如果是write任务，则将生成的响应写入（分散写）socket中；</li><li>task()结束前需要使用epoll_ctl设置fd的状态，决定是否关闭连接（Keep-Alive），是否继续监听套接字socketfd，监听什么事件：请求数据（EPOLLOUT），不请求数据（EPOLLIN）。</li></ol><blockquote><p>线程池的线程数量最直接的限制因素是CPU处理器的个数。<br>如果CPU是四核的，那么对于CPU密集的任务，线程池的线程数量最好也为4，或者+1防止其他因素导致阻塞。<br>如果是<strong>IO密集的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU资源而是IO</strong>，IO的处理一般比较慢，多于核数的线程将为CPU争取更多的任务，不至于在县城处理IO的时候造成CPU空闲导致资源浪费。</p></blockquote><h2 id="reactor、proactor、主从reactor模型的区别？"><a href="#reactor、proactor、主从reactor模型的区别？" class="headerlink" title="reactor、proactor、主从reactor模型的区别？"></a>reactor、proactor、主从reactor模型的区别？</h2><ol><li>Reactor模式</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091927536.png" alt="image.png"></p><ol><li>Reactor 对象通过 epoll （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li><li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li><li>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</li><li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</li><li>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</li><li>主从Reactor模式</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091927034.png" alt="image.png"></p><ol><li>主线程中的 MainReactor 对象通过 epoll 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；</li><li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 epoll 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。</li><li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li><li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ol><p>多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：</p><ul><li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。</li><li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li></ul><ol start="3"><li>Proactor模式</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091927357.png" alt="image.png"></p><ol><li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；</li><li>Asynchronous Operation Processor 负责处理注册请求，并处理 I&#x2F;O 操作；</li><li>Asynchronous Operation Processor 完成 I&#x2F;O 操作后通知 Proactor；</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li><li>Handler 完成业务处理；</li></ol><p><strong>Reactor 和 Proactor 的区别：</strong></p><ul><li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul><h2 id="你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"><a href="#你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？" class="headerlink" title="你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"></a>你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</h2><ol><li>select&#x2F;poll</li></ol><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后<strong>调用 select 函数</strong>将文件描述符集合<strong>拷贝</strong>到内核里，让内核来<strong>检查</strong>是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket <strong>标记</strong>为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。<br>存在的问题：</p><ol><li>对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</li><li>select 使用<strong>固定长度的 BitsMap</strong>表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 <strong>FD_SETSIZE</strong> 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。</li></ol><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用<strong>动态数组</strong>，以<strong>链表形式</strong>来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。<br>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，</strong>因此都需要<strong>遍历</strong>文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间<strong>拷贝</strong>文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><ol start="2"><li>epoll</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091927001.png" alt="image.png"></p><ol><li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select&#x2F;poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select&#x2F;poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li></ol><p><strong>补充：</strong></p><ul><li>select和poll都只能工作在<strong>相对低效的LT模式下</strong>，而epoll同时支持LT和ET模式。</li><li>综上，<strong>当监测的fd数量较小</strong>，且各个fd都很活跃的情况下，建议使用select和poll；<strong>当监听的fd数量较多</strong>，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。</li></ul><h2 id="epoll为什么要使用红黑树"><a href="#epoll为什么要使用红黑树" class="headerlink" title="epoll为什么要使用红黑树"></a>epoll为什么要使用红黑树</h2><p>epoll 内核中维护了一个内核事件表，它是<strong>将所有的文件描述符全部都存放在内核</strong>中，系统去检测有事件发生的时候<strong>触发回调</strong>，当你要添加新的文件描述符的时候也是调用<strong>epoll_ctl</strong> 函数使用EPOLL_CTL_ADD 宏来<strong>插入</strong>，epoll_wait 也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。<strong>当要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生</strong>，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。</p><h2 id="epoll边缘触发如何判断数据已经读取完成"><a href="#epoll边缘触发如何判断数据已经读取完成" class="headerlink" title="epoll边缘触发如何判断数据已经读取完成"></a>epoll边缘触发如何判断数据已经读取完成</h2><p>两种做法：</p><ol><li>针对TCP，调用recv方法，根据recv的返回值。如果返回值小于我们设定的 recv buff 的大小，那么就认为接收完毕。</li><li>TCP、UDP都适用，将 socket 设为 NOBLOCK 状态（使用fcntl函数），然后 select该socket可读的时候，使用 read&#x2F;recv 函数读取数据。当返回值为 -1，并且 errno 是 EAGAIN 或EWOULDBLOCK 的时候，表示数据读取完毕。</li></ol><h2 id="客户端断开连接，服务端epoll监听到什么事件？"><a href="#客户端断开连接，服务端epoll监听到什么事件？" class="headerlink" title="客户端断开连接，服务端epoll监听到什么事件？"></a>客户端断开连接，服务端epoll监听到什么事件？</h2><p>在使用 epoll 时，客户端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件。<br>在<strong>早期</strong>的内核中，这个 epoll 事件一般是 EPOLLIN，即 0x1，代表连接可读。<br>连接池检测到某个连接发生 EPOLLIN 事件且没有错误后，会认为有请求到来，将连接交给上层进行处理。这样一来，上层尝试在对端已经 close() 的连接上读取请求，只能读到<strong>EOF（文件末尾）</strong>，会认为发生异常，报告一个错误。<br>后期的内核中增加了 <strong>EPOLLRDHUP</strong> 事件，代表对端断开连接。对端连接断开触发的 epoll 事件会包含 EPOLLIN | EPOLLRDHUP，即 0x2001。有了这个事件，对端断开连接的异常就可以在<strong>底层进行处理</strong>了，不用再移交到上层。</p><h2 id="epoll的线程安全问题"><a href="#epoll的线程安全问题" class="headerlink" title="epoll的线程安全问题"></a>epoll的线程安全问题</h2><p>简要结论就是<strong>epoll是通过锁来保证线程安全的</strong>，epoll中粒度最小的<strong>自旋锁ep-&gt;lock(spinlock)<strong>用来保护就绪的队列， <strong>互斥锁ep-&gt;mtx</strong>用来保护epoll的重要数据结构红黑树<br>主要的两个函数：<br>epoll_ctl()：当需要根据不同的operation通过</strong>ep_insert() 或者ep_remove()<strong>等接口对epoll自身的数据结构进行操作时都提前获得了</strong>ep-&gt;mtx锁</strong><br>epll_wait()：获得<strong>自旋锁 ep-&gt;lock</strong>来保护就绪队列</p><h2 id="SO-REUSEDADDR和SO-REUSEDPORT"><a href="#SO-REUSEDADDR和SO-REUSEDPORT" class="headerlink" title="SO_REUSEDADDR和SO_REUSEDPORT"></a>SO_REUSEDADDR和SO_REUSEDPORT</h2><p>在TCP连接下，如果服务器主动关闭连接（比如ctrl+c结束服务器进程），那么由于服务器这边会出现time_wait状态，所以不能立即重新启动服务器进程。在标准文档中，2MSL时间为两分钟。<br>一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。<br>如果不进行端口重用的话，客户端可能不受什么影响，因为在客户端主动关闭后，客户端可以使用另一个端口与服务端再次建立连接；但是服务端主动关闭连接后，其周知端口在两分钟内不能再次使用，就很麻烦</p><h2 id="epoll的水平触发和边缘触发"><a href="#epoll的水平触发和边缘触发" class="headerlink" title="epoll的水平触发和边缘触发"></a>epoll的水平触发和边缘触发</h2><ol><li>水平触发<ol><li>只要socket缓冲区有数据，epoll_wait就会一直触发，直到缓冲区为空；</li><li>LT是epoll默认的工作模式</li><li>优缺点<ol><li>优点：保证数据的完全读取</li><li>缺点：当数据量较大时，需要不断从用户态到内核态的切换，消耗了大量的服务器资源，影响服务器性能</li></ol></li><li>应用场景：应用较少，一般用于<strong>连接请求数较少，且客户端发送数据量较少的服务器</strong>，可一次性接收所有的数据。此时若使用边缘触发，会多调用一次accept&#x2F;read等来判断数据是否为空。</li></ol></li><li>边缘触发<ol><li>只有所监听的套接字事件状态改变或者有事件发生时，epoll_wait才会触发</li><li>边缘触发通常与非阻塞IO一起使用，其工作模式为：epoll_wait每触发一次，在while循环里非阻塞的读取数据，直到缓冲区为空</li><li>优缺点<ol><li>优点：每次epoll_wait只触发一次就可以读取缓冲区内的所有数据，工作效率高，大大提高的服务器的性能</li><li>缺点：当数据量很小时，至少需要调用两次非阻塞IO函数，而水平触发只调用一次</li></ol></li></ol></li><li>什么时候用边缘触发，什么时候用水平触发</li></ol><p>我的答案是：任何情况都应该优先选择“边沿触发（EPOLLET）+非阻塞IO”模式。<br>理由如下：根据以上水平触发和边沿触发的分析，毋庸置疑，当服务端连接请求多且数据量大的时候，应该选择“边沿触发+非阻塞IO”模式，因为<strong>只用触发一次epoll_wait，就可以读取缓冲区的所有数据</strong>。那么连接请求少而且数据量也小的时候偶，为什么也优先选择边沿触发+非阻塞IO呢？在我看来，既然数据量小，那么服务端性能要求自然也不高，即使非阻塞IO读取数据多了一次判断数据为空的情况，但是其影响也不大，而且<strong>边沿触发也能满足接收大量数据</strong>的情况。</p><ol start="4"><li>水平触发是否需要非阻塞IO</li></ol><p>答案是：不管水平触发还是边沿触发，都要使用<strong>非阻塞IO</strong>。<br>理由如下：假设水平触发使用阻塞read读取数据，且设定一次性读取20字节，现在假设客户端只发送了10个字节，那么服务端内核就会阻塞在read调用中，等待客户端再发送至少10个字节的数据，才能返回继续执行程序。但是服务端已经阻塞在系统调用read中了，无法再调用epoll_wait来监听该客户端的下一次就绪事件，也就无法接受数据，read也不可能再达到20字节了，从而就形成死锁，因此水平触发也要使用非阻塞IO。</p><h2 id="为什么ET模式一定要设置非阻塞"><a href="#为什么ET模式一定要设置非阻塞" class="headerlink" title="为什么ET模式一定要设置非阻塞"></a>为什么ET模式一定要设置非阻塞</h2><p>因为ET模式下是<strong>无限循环读</strong>，直到出现错误为<strong>EAGAIN</strong> 或者 <strong>EWOULDBLOCK</strong>，这两个错误表示socket 为空，然后就停止循环。如果是阻塞，<strong>循环读在 socket 为空的时候就会阻塞</strong>到那里，主线程的 read()函数一旦阻塞住，当再有其他监听事件过来就没办法读了，给其他事情造成了影响，所以必须要设置为非阻塞。</p><h2 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h2><p>即使可以使用边缘触发模式，一个socket上的某个时间还是可能被触发多次。比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中，socket上又有了新数据可以读（EPOLLIN再次被触发），此时另外一个线程被唤醒来读取这些新的数据。就会出现两个线程同时操作一个socket的局面。一个socket连接在任意时刻都应该只被一个线程处理，可以使用epoll EPOLLONESHOT实现。<br>对于注册了EPOLLONESHOT事件的文件描述符有，操作系统最多出发其注册的一个可读、可写或异常事件，且只触发一次。除非我们<strong>使用epoll_ctl函数重置</strong>该文件描述符上注册的EPOLLONESHOT事件。<br>这样一个线程在处理某个socket时，其他线程是不可能有机会操作该socket，但反过来要注意，<strong>注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而可以让其他线程有机会处理这个socket。</strong></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>每个请求对应一个线程方法的不足之一是：为每个请求创建新线程的服务器在<strong>创建和销毁线程</strong>上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。<br>线程池的目的：</p><ol><li>创建和销毁线程所产生的开销；</li><li>提高响应速度，任务到达时，无需等待线程即可立即执行；</li><li>提高线程的可管理性：线程的不合理分布会导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li></ol><h2 id="线程池与多线程的设计思路"><a href="#线程池与多线程的设计思路" class="headerlink" title="线程池与多线程的设计思路"></a>线程池与多线程的设计思路</h2><ol><li>整体思路：生产者-消费者 模型<ol><li>任务队列（临界区）：线程同步互斥锁</li><li>队列为不为空&#x2F;满：信号量、条件变量</li><li>生产者：主线程，产生任务放入工作队列</li><li>消费者：子线程，从工作队列取出任务处理</li></ol></li><li>工作流程<ol><li>设计一个任务队列，作为临界区资源</li><li>初始化n个线程，开始运行，对任务队列加锁，取出任务执行</li><li>当任务队列为空时，所有工作线程阻塞（pool-&gt;cond.wait(locker)）</li><li>当主线程监听的fd上有IO事件时，将任务添加到任务队列中，并唤醒一个等待的工作线程（pool_-&gt;cond.notify_one()）</li><li>线程池关闭时，唤醒所有线程（pool_-&gt;cond.notify_all()），工作线程退出while循环</li></ol></li></ol><h2 id="介绍生产者消费者模型"><a href="#介绍生产者消费者模型" class="headerlink" title="介绍生产者消费者模型"></a>介绍生产者消费者模型</h2><p>生产者和消费者主要用于<strong>对于数据的同步使用</strong>，生产者生产数据，然后放到共享缓冲区中，消费者在缓冲区没有数据之前会阻塞等待，当生产者生产数据之后，会唤醒阻塞的消费者线程，开始消费数据，而当数据生产充满缓冲区之后，生产者就会阻塞等待。其中的阻塞都使用条件变量。</p><h2 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> THREADPOOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREADPOOL_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span> <span class="hljs-comment">// C++ 11 标准库函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    生产者-消费者 模型</span><br><span class="hljs-comment">    生产者：主线程产生任务放入工作队列</span><br><span class="hljs-comment">    消费者：子线程从工作队列取出任务处理</span><br><span class="hljs-comment">    任务队列（临界区）：线程同步互斥锁</span><br><span class="hljs-comment">    队列为不为空/满：信号量、条件变量</span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-comment">// 线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 类嵌套类型</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pool</span> &#123;<br>        std::mutex mtx;                 <span class="hljs-comment">// 互斥锁</span><br>        std::condition_variable cond;   <span class="hljs-comment">// 条件变量</span><br>        <span class="hljs-type">bool</span> isClosed;                  <span class="hljs-comment">// 是否关闭</span><br>        std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;    <span class="hljs-comment">// 线程队列（保存的是任务）</span><br>    &#125;;<br>    std::shared_ptr&lt;Pool&gt; pool_;  <span class="hljs-comment">//  智能指针，指向该线程池，自动释放</span><br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 显式构造函数，线程池大小默认为 8， pool_使用std::make_shared&lt;Pool&gt;()初始化，智能指针初始化最好使用make_shared</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">size_t</span> threadCount = <span class="hljs-number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span><br>            <span class="hljs-built_in">assert</span>(threadCount &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// 断言</span><br><br>            <span class="hljs-comment">// 创建threadCount个子线程</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>                std::<span class="hljs-built_in">thread</span>([pool = pool_] &#123; <span class="hljs-comment">// 匿名函数，值传递，该匿名函数为子线程的主体函数</span><br>                    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">locker</span>(pool-&gt;mtx); <span class="hljs-comment">// 声明独占锁，并上锁</span><br>                    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-keyword">if</span>(!pool-&gt;tasks.<span class="hljs-built_in">empty</span>()) &#123;<br>                            <span class="hljs-keyword">auto</span> task = std::<span class="hljs-built_in">move</span>(pool-&gt;tasks.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 从任务队列中取第一个任务</span><br>                            pool-&gt;tasks.<span class="hljs-built_in">pop</span>();<br>                            locker.<span class="hljs-built_in">unlock</span>();<br>                            <span class="hljs-built_in">task</span>();  <span class="hljs-comment">// std::function&lt;void()&gt; 对象，任务主体</span><br>                            locker.<span class="hljs-built_in">lock</span>();<br>                        &#125; <br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pool-&gt;isClosed) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 线程池关闭，break while 线程结束</span><br>                        <span class="hljs-keyword">else</span> pool-&gt;cond.<span class="hljs-built_in">wait</span>(locker);   <span class="hljs-comment">// 如果队列为空</span><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                        The execution of the current thread (which shall have locked lck&#x27;s mutex) is blocked until notified.</span><br><span class="hljs-comment">                        At the moment of blocking the thread, the function automatically calls lck.unlock(), allowing other locked threads to continue.</span><br><span class="hljs-comment">                        */</span><br>                    &#125;<br>                &#125;).<span class="hljs-built_in">detach</span>();<span class="hljs-comment">// 线程分离，自动回收</span><br>            &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">ThreadPool</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    <br>    ~<span class="hljs-built_in">ThreadPool</span>() &#123; <span class="hljs-comment">// 析构函数</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(pool_)) &#123; <span class="hljs-comment">// 如果pool_不为nullptr，关闭线程池</span><br>            &#123;<br><br>                <span class="hljs-comment">// 声明一个 lock_gurad 类型的局部变量保证在销毁或者异常的时候释放锁</span><br>                <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(pool_-&gt;mtx)</span></span>;<br>                <span class="hljs-comment">/*using a local lock_guard to lock mtx guarantees unlocking on destruction / exception*/</span><br>                pool_-&gt;isClosed = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 释放锁</span><br>            &#125;<br>            pool_-&gt;cond.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 唤醒所有线程</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AddTask</span><span class="hljs-params">(F&amp;&amp; task)</span> </span>&#123; <span class="hljs-comment">// 添加任务，右值引用</span><br>        &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(pool_-&gt;mtx)</span></span>;<br>            pool_-&gt;tasks.<span class="hljs-built_in">emplace</span>(std::forward&lt;F&gt;(task)); <span class="hljs-comment">// 就地、移动构造</span><br>        &#125;<br>        pool_-&gt;cond.<span class="hljs-built_in">notify_one</span>();   <span class="hljs-comment">// 唤醒一个等待的线程</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Unblocks one of the threads currently waiting for this condition.</span><br><span class="hljs-comment">        If no threads are waiting, the function does nothing.</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//THREADPOOL_H</span></span><br></code></pre></td></tr></table></figure><h2 id="线程的同步机制有哪些？"><a href="#线程的同步机制有哪些？" class="headerlink" title="线程的同步机制有哪些？"></a>线程的同步机制有哪些？</h2><ol><li>锁，通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码；</li><li>信号量，信号量是一个计数器，用于控制访问有限共享资源的线程数；</li><li>条件变量，条件变量可以让调用线程在满足特定条件的情况下暂停。</li></ol><h2 id="线程池中的工作线程是一直等待吗？"><a href="#线程池中的工作线程是一直等待吗？" class="headerlink" title="线程池中的工作线程是一直等待吗？"></a>线程池中的工作线程是一直等待吗？</h2><p>我们为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于<strong>一直阻塞等待</strong>的模式下的。 </p><h2 id="你的线程池工作线程处理完一个任务后的状态是什么？"><a href="#你的线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="你的线程池工作线程处理完一个任务后的状态是什么？"></a>你的线程池工作线程处理完一个任务后的状态是什么？</h2><ol><li>当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</li><li>当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格。</li></ol><h2 id="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h2><p>该项目是基于IO复用的并发模式。<strong>需要注意的是，不是一个客户连接就对应一个线程</strong>，本项目通过<strong>对子线程循环调用</strong>来解决高并发的问题的。<br>首先在创建线程的同时就调用了detach将线程进行分离，不用单独对工作线程进行回收，资源自动回收。<br>我们通过在子线程中进行while循环，让每一个线程池中的线程永远都不会停止，主线程监听到IO事件后将任务添加到任务队列中，如果没有任务，线程就一直阻塞等待，有任务线程就抢占式进行处理，直到请求队列为空，表示任务全部处理完成。<br><strong>如果速度还是慢，那就只能够增大线程池容量</strong>，或者考虑集群分布式的做法。</p><h2 id="如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢"><a href="#如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢" class="headerlink" title="如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?"></a>如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</h2><p>会，因为线程池内<strong>线程的数量时有限</strong>的，如果客户请求占用线程时间过久的话会影响到处理请求的效率，当请求处理过慢时会造成后续接受的请求只能在请求队列中等待被处理，从而影响接下来的客户请求。<br>应对策略：</p><ol><li>可以为线程处理请求对象<strong>设置处理超时时间</strong>， 超过时间先发送信号告知线程处理超时，然后设定一个时间间隔再次检测，若此时这个请求还占用线程则直接将其断开连接；</li><li>给每一个线程处理任务设定一个时间阈值，当某一个客户请求时间过长，则将其<strong>置于任务请求最后</strong>，或断开连接。</li></ol><h2 id="什么是虚假唤醒"><a href="#什么是虚假唤醒" class="headerlink" title="什么是虚假唤醒"></a>什么是虚假唤醒</h2><p>举个例子，我们现在有一个生产者-消费者队列和三个线程。</p><ol><li>1号线程从队列中获取了一个元素，此时队列变为空。</li><li>2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空。</li><li>这时，3号线程将一个元素入队，并调用cond.notify()唤醒条件变量。</li><li>处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(获取队列中的元素)。</li><li>然而可能出现这样的情况：当2号线程准备获得队列的锁，去获取队列中的元素时，此时1号线程刚好执行完之前的元素操作，返回再去请求队列中的元素，1号线程便获得队列的锁，检查到队列非空，就获取到了3号线程刚刚入队的元素，然后释放队列锁。</li><li>等到2号线程获得队列锁，判断发现队列仍为空，1号线程“偷走了”这个元素，所以对于2号线程而言，这次唤醒就是“虚假”的，它需要再次等待队列非空。</li></ol><h2 id="有哪些典型的锁机制"><a href="#有哪些典型的锁机制" class="headerlink" title="有哪些典型的锁机制"></a>有哪些典型的锁机制</h2><ol><li>互斥锁与自旋锁<ol><li>互斥锁加锁失败后，线程会<strong>释放CPU</strong>，给其他线程</li></ol></li></ol><p>互斥锁加锁失败时，会从用户态陷入内核态，让内核帮我们切换线程，存在<strong>两次线程上下文切换的成本。</strong>线程上下文切换的时间大概在几十纳秒到几微秒之间，如果锁住的代码执行事件比较短，可能切换上下文的时间比执行时间还长，这时应该选用自旋锁而不是互斥锁。</p><ol start="2"><li>自旋锁加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁</li></ol><p>自旋锁在用户态完成加锁和解锁的操作，开销比互斥锁小，但是在单核CPU上需要抢占式调度器。</p><ol start="2"><li>读写锁</li></ol><p>读写锁适用于能明确区分读写操作的场景</p><ol><li>当写锁没有被线程持有时，多个线程能并发地持有读锁，这大大提高了共享资源的访问效率</li><li>一旦写锁被线程持有后，读线程的获取读锁操作就会被阻塞，而且其他写线程的获取写锁操作也会被阻塞</li><li>写锁是一种独占锁，而读锁是一种共享锁</li><li>乐观锁与悲观锁<ol><li>悲观锁访问资源前，要先上锁</li><li>乐观锁先修改完共享资源，再验证这段时间内是否发生冲突，如果没有其它线程在修改资源，则操作完成，否则放弃本次操作（例子：在线文档；方案：版本号）</li><li>只有在冲突概率非常低，且加锁成本非常高的场景时，才采用乐观锁，因为一旦发生冲突，重试的成本非常高</li></ol></li></ol><h2 id="线程池中有多少个线程，线程池的数量如何设定"><a href="#线程池中有多少个线程，线程池的数量如何设定" class="headerlink" title="线程池中有多少个线程，线程池的数量如何设定"></a>线程池中有多少个线程，线程池的数量如何设定</h2><p>默认8个<br>调整线程池中的<strong>线程数量的最主要的目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能</strong>。<br>Ncpu 表示 CPU的数量。</p><ol><li>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 Ncpu+1能够实现最优的CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证CPU 时钟周期不被浪费</li><li>如果是IO密集型任务，参考值可以设置为 2 * Ncpu。因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于CPU数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费</li></ol><p>最佳线程数量 &#x3D; ((线程等待时间+线程CPU时间)／ 线程CPU时间)* CPU个数。<br>由公式可得，<strong>线程等待时间（如I&#x2F;O操作）所占比例越高，需要越多的线程，线程CPU时间所占比例越高，所需的线程数越少</strong>。</p><h2 id="线程数是越多越好吗"><a href="#线程数是越多越好吗" class="headerlink" title="线程数是越多越好吗"></a>线程数是越多越好吗</h2><p>不是</p><ol><li>假设现有8个CPU、8个线程，每个线程占用一个CPU，同一时间段内，若8个线程都运行往前跑，相比较5&#x2F;6&#x2F;7个线程，8个线程的效率高。</li><li>但若此时有9个线程，只有8个CPU，9个线程同时运行，则此时牵扯到线程切换，而线程切换是需要消耗时间的。</li><li>所以随着线程数越多，效率越来越高，但到一个峰值，再增加线程数量时，就会出现问题。线程太多要来回的切换，最终可能线程切换所用时间比执行时间业务所用时间还大。</li><li>随着线程数越多，由于线程执行的时序的问题，程序可能会崩溃或产生二义性</li></ol><h2 id="服务器如何进行断点传输"><a href="#服务器如何进行断点传输" class="headerlink" title="服务器如何进行断点传输"></a>服务器如何进行断点传输</h2><p>解决方案：</p><ol><li>分片传输<ol><li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li><li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li><li>按照一定的策略（串行或并行）发送各个分片数据块；</li><li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。</li></ol></li><li>断点续传<ol><li>在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要<strong>记录上传的进度</strong>。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。</li><li>为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，<strong>服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询</strong>，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。</li></ol></li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="什么是数据库连接池，为什么要创建连接池？"><a href="#什么是数据库连接池，为什么要创建连接池？" class="headerlink" title="什么是数据库连接池，为什么要创建连接池？"></a>什么是数据库连接池，为什么要创建连接池？</h2><ol><li>池是资源的容器，这组资源在服务器启动之初就被完全创建好并初始化，本质上是对资源的复用。</li></ol><p>当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配；当服务器处理完一个客户连接后,可以把相关的资源放回池中，无需执行系统调用释放资源。</p><ol start="2"><li>若系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。</li></ol><p>在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。</p><ol start="3"><li>使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。</li></ol><p>连接池的功能主要有：初始化，获取连接、释放连接，销毁连接池<br>连接池中的多线程使用信号量进行通信，使用互斥锁进行同步。</p><p>数据库连接的获取与释放通过RAII机制封装，避免手动释放。</p><blockquote><p>RAII机制<br>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.<br>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子<br>具体来说：<strong>构造函数的时候初始化获取资源，析构函数释放资源</strong></p></blockquote><h2 id="获取释放连接，销毁连接池"><a href="#获取释放连接，销毁连接池" class="headerlink" title="获取释放连接，销毁连接池"></a>获取释放连接，销毁连接池</h2><ol><li>获取链接<ul><li>容器有空闲连接，直接用</li><li>容器无空闲<ul><li>未达上限，自己创建</li><li>达上限，报错打回等待</li></ul></li></ul></li><li>释放连接<ul><li>放回容器</li><li>目前暂无较好的销毁连接策略</li></ul></li><li>销毁对象池<ul><li>关闭销毁池中连接</li><li>释放连接池对象</li><li>完成释放</li></ul></li></ol><h2 id="登录说一下？"><a href="#登录说一下？" class="headerlink" title="登录说一下？"></a>登录说一下？</h2><p>将数据库中的用户名和密码载入到服务器的map中来，map中的key为用户名，value为密码<br>服务器端解析浏览器的请求报文，当解析为POST请求时，提取出请求报文的消息体的用户名和密码。<br>POST请求中最后是用户名和密码，用&amp;隔开。分隔符&amp;，前是用户名，后是密码。<br>登录：将浏览器输入的用户名和密码在数据库中查找，直接判断。<br>注册：往数据库中插入数据，<strong>需要判断是否有重复的用户名</strong>。<br>最后进行页面跳转<br>通过m_url定位&#x2F;所在位置，根据&#x2F;后的第一个字符，使用分支语句实现页面跳转。具体的，</p><ul><li>0 — 跳转注册页面，GET</li><li>1 — 跳转登录页面，GET</li><li>5 — 显示图片页面，POST</li><li>6 — 显示视频页面，POST</li><li>7 — 显示关注页面，POST</li></ul><h2 id="登录与注册，服务器如何校验"><a href="#登录与注册，服务器如何校验" class="headerlink" title="登录与注册，服务器如何校验"></a>登录与注册，服务器如何校验</h2><p>CGI校验（通用网关接口），它是一个运行在Web服务器上的程序，在编译的时候将相应的.cpp文件编程成.cgi文件并在主程序中调用即可。这些CGI程序通常通过客户在其浏览器上点击一个button时运行。这些程序通常用来执行一些信息搜索、存储等任务，而且通常会生成一个动态的HTML网页来响应客户的HTTP请求。<br>CGI程序，将用户请求中的用户名和密码保存在一个id_passwd.txt文件中，通过将数据库中的用户名和密码存到一个map中用于校验。在主程序中通过execl(m_real_file, &amp;flag, name, password, NULL);这句命令来执行这个CGI文件，这里CGI程序仅用于校验，并未直接返回给用户响应。这个CGI程序的运行通过多进程来实现，根据其返回结果判断校验结果（使用pipe进行父子进程的通信，子进程将校验结果写到pipe的写端，父进程在读端读取）。</p><h2 id="你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）"><a href="#你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）" class="headerlink" title="你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）"></a>你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）</h2><p>可以利用session或者cookie的方式进行状态的保存。<br>cookie其实就是服务器给客户分配了一串“身份标识”，比如“123456789happy”这么一串字符串。每次客户发送数据时，都在HTTP报文附带上这个字符串，服务器就知道你是谁了；<br>session是保存在服务器端的状态，每当一个客户发送HTTP报文过来的时候，服务器会在自己记录的用户数据中去找，类似于核对名单；</p><h2 id="登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？"><a href="#登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？" class="headerlink" title="登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？"></a>登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</h2><p>这个问题的关键在于大数据量情况下的用户登录验证怎么进行？将所有的用户信息加载到内存中耗时耗利，对于大数据最便利的方法就是<strong>进行hash，利用hash建立多级索引的方式来加快用户验证</strong>。具体操作如下：</p><ol><li>首先，将10亿的用户信息，利用大致缩小1000倍的hash算法进行hash，这时就获得了100万的hash数据，每一个hash数据代表着一个用户信息块（一级）；</li><li>而后，再分别对这100万的hash数据再进行hash，例如最终剩下1000个hash数据（二级）。</li><li>在这种方式下，服务器只需要保存1000个二级hash数据，当用户请求登录的时候，先对用户信息进行一次hash，找到对应信息块（二级），在读取其对应的一级信息块，最终找到对应的用户数据。</li></ol><h2 id="用的mysql啊，redis了解吗？用过吗？"><a href="#用的mysql啊，redis了解吗？用过吗？" class="headerlink" title="用的mysql啊，redis了解吗？用过吗？"></a>用的mysql啊，redis了解吗？用过吗？</h2><p>不了解，没用过🤭</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="为什么要用定时器？"><a href="#为什么要用定时器？" class="headerlink" title="为什么要用定时器？"></a>为什么要用定时器？</h2><p>由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。</p><h2 id="说一下定时器的工作原理"><a href="#说一下定时器的工作原理" class="headerlink" title="说一下定时器的工作原理"></a>说一下定时器的工作原理</h2><p>由于定时器的触发是由于时间到了，因此只有时间最短的定时器会首先被触发，通过这个原理，我们可以采用最小堆，将按时间顺序排序，堆顶元素是时间最短的定时器，因此只要判断堆顶元素是否被触发即可。只有堆顶定时器的时间到了，才会到其他时间较晚的定时器的时间。<br>定时器利用结构体将Http连接对应的fd、有效期、回调函数等封装起来。<br>服务器主循环每建立一个连接则为该连接创建一个定时器节点，插入到最小堆中，主循环通过GetNextTick()清除超时的节点，关闭对应连接，释放连接资源，然后获取最先要超时的连接的<strong>超时的时间</strong>，并设置下一次epoll_wait()的超时时间为该时间。当已建立的连接有IO事件时，延长这个连接的超时时间，调整最小堆。</p><h2 id="最小堆？说一下时间复杂度和工作原理"><a href="#最小堆？说一下时间复杂度和工作原理" class="headerlink" title="最小堆？说一下时间复杂度和工作原理"></a>最小堆？说一下时间复杂度和工作原理</h2><p>时间复杂度：添加：O(logn)， 删除：O(1)<br>工作原理：<br>将所有定时器中超时时间最小的一个定时器的超时值，作为定时任务处理函数的定时值。这样，一旦定时任务处理函数被调用，超时时间最小的定时器必然到期，我们就可以在定时任务处理函数中处理该定时器。<br>然后，再次从剩余的定时器中找出超时时间最小的一个（堆），并将这段最小时间设置为下一次定时任务处理函数的定时值。如此反复，就实现了较为精确的定时。</p><h1 id="HTTP报文解析"><a href="#HTTP报文解析" class="headerlink" title="HTTP报文解析"></a>HTTP报文解析</h1><h2 id="用了状态机啊，为什么要用状态机？"><a href="#用了状态机啊，为什么要用状态机？" class="headerlink" title="用了状态机啊，为什么要用状态机？"></a>用了状态机啊，为什么要用状态机？</h2><p>在逻辑处理模块中，响应HTTP请求采用主从状态机来完成<br>传统的控制流程都是按照顺序执行的，状态机能处理任意顺序的事件，并能提供有意义的响应——即使这些事件发生的顺序和预计的不同。<br>项目中使用主从状态机的模式进行解析，<strong>从状态机（parse_line）负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机</strong>。<br>每解析一部分都会将整个请求的<strong>check_state状态</strong>改变，状态机也就是根据这个状态来进行不同部分的解析跳转的。</p><h2 id="状态机的转移图画一下"><a href="#状态机的转移图画一下" class="headerlink" title="状态机的转移图画一下"></a>状态机的转移图画一下</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091928130.png" alt="image.png"></p><ol><li>主状态机的三种状态，标志解析位置<ol><li>CHECK_STATE_REQUESTLINE，解析请求行</li><li>CHECK_STATE_HEADER，解析请求头</li><li>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</li></ol></li><li>从状态机的状态，标识解析一行的读取状态<ol><li>LINE_OK，完整读取一行，该条件涉及解析请求行和请求头部</li><li>LINE_BAD，报文语法有误</li><li>LINE_OPEN，读取的行不完整</li></ol></li><li>处理结果<ol><li>NO_REQUEST：请求不完整，需要继续读取请求报文数据</li><li>GET_REQUEST获得了完整的HTTP请求</li><li>BAD_REQUESTHTTP请求报文有语法错误</li><li>INTERNAL_ERROR服务器内部错误</li></ol></li></ol><h2 id="报文解析的整体流程"><a href="#报文解析的整体流程" class="headerlink" title="报文解析的整体流程"></a>报文解析的整体流程</h2><p>process_read通过while循环，将主从状态机进行封装，对报文的每一行进行循环处理。</p><ol><li>判断条件<ol><li>主状态机转移到CHECK_STATE_CONTENT，该条件涉及解析消息体</li><li>从状态机转移到LINE_OK，该条件涉及解析请求行和请求头部</li><li>两者为或关系，当条件为真则继续循环，否则退出</li></ol></li><li>循环体<ol><li>从状态机读取数据</li><li>调用get_line函数，通过m_start_line将从状态机读取数据间接赋给text</li><li>主状态机解析text</li></ol></li></ol><p>在HTTP报文中，每一行的数据由\r\n作为结束字符，空行则是仅仅是字符\r\n。因此，可以通过查找\r\n将报文拆解成单独的行进行解析，项目中便是利用了这一点。</p><p>从状态机负责读取buffer中的数据，将每行数据末尾的\r\n置为\0\0，并更新从状态机在buffer中读取的位置m_checked_idx，以此来驱动主状态机解析。</p><ol><li>从状态机从m_read_buf中逐字节读取，判断当前字节是否为\r<ol><li>接下来的字符是\n，将\r\n修改成\0\0，将m_checked_idx指向下一行的开头，则返回LINE_OK</li><li>接下来达到了buffer末尾，表示buffer还需要继续接收，返回LINE_OPEN</li><li>否则，表示语法错误，返回LINE_BAD</li></ol></li><li>当前字节不是\r，判断是否是\n（一般是上次读取到\r就到了buffer末尾，没有接收完整，再次接收时会出现这种情况）<ol><li>如果前一个字符是\r，则将\r\n修改成\0\0，将m_checked_idx指向下一行的开头，则返回LINE_OK</li></ol></li><li>当前字节既不是\r，也不是\n<ol><li>表示接收不完整，需要继续接收，返回LINE_OPEN</li></ol></li></ol><h2 id="主状态机的逻辑"><a href="#主状态机的逻辑" class="headerlink" title="主状态机的逻辑"></a>主状态机的逻辑</h2><p>主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行的末尾\r\n符号改为\0\0，以便于主状态机直接取出对应字符串进行处理。</p><ol><li>CHECK_STATE_REQUESTLINE<ol><li>主状态机的初始状态，调用parse_request_line函数解析请求行</li><li>解析函数从m_read_buf中解析HTTP请求行，获得请求方法、目标URL及HTTP版本号</li><li>解析完成后主状态机的状态变为CHECK_STATE_HEADER</li></ol></li></ol><p>解析完请求行后，主状态机继续分析请求头。在报文中，请求头和空行的处理使用的同一个函数，这里通过判断当前的text首位是不是\0字符，若是，则表示当前处理的是空行，若不是，则表示当前处理的是请求头。</p><ol><li>CHECK_STATE_HEADER<ol><li>调用parse_headers函数解析请求头部信息</li><li>判断是空行还是请求头，若是空行，进而判断content-length是否为0，如果不是0，表明是POST请求，则状态转移到CHECK_STATE_CONTENT，否则说明是GET请求，则报文解析结束。</li><li>若解析的是请求头部字段，则主要分析connection字段，content-length字段，其他字段可以直接跳过，各位也可以根据需求继续分析。</li><li>connection字段判断是keep-alive还是close，决定是长连接还是短连接</li><li>content-length字段，这里用于读取post请求的消息体长度</li></ol></li></ol><p>在完成消息体解析后，将line_status变量更改为LINE_OPEN，此时可以跳出循环，完成报文解析任务。</p><ol><li>CHECK_STATE_CONTENT<ol><li>仅用于解析POST请求，调用parse_content函数解析消息体</li><li>用于保存post请求消息体，为后面的登录和注册做准备</li></ol></li></ol><h2 id="状态机的缺点"><a href="#状态机的缺点" class="headerlink" title="状态机的缺点"></a>状态机的缺点</h2><p>状态机的缺点就是<strong>性能比较低</strong>，一般一个状态做一个事情，性能比较差，在追求高性能的场景下一般不用，高性能场景一般使用<strong>流水线设计。</strong></p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><ol><li>get主要用来<strong>获取数据</strong>，而post是<strong>提交或修改数据</strong>；</li><li>get有<strong>长度限制</strong>（2048字节）而post没有；</li><li>get的参数是<strong>显式</strong>的，get的参数会附加在url之 中，以 “ ？ “分割url和传输数据，多个参数用 “&amp;”连接；而post是<strong>隐式</strong>的，post是放在请求体中；</li><li>get请求会<strong>保存</strong>在浏览器历史记录中，也可以保存在web服务器日志中； </li><li>get在浏览器回退时是<strong>无害</strong>的，而post会<strong>再次提交</strong>请求；</li><li>get请求只能进行url编码，而post支持多种编码方式；</li><li>get请求的参数数据类型只接受ASCII字符，而post没有限制。</li></ol><h2 id="HTTP请求怎么拆包"><a href="#HTTP请求怎么拆包" class="headerlink" title="HTTP请求怎么拆包"></a>HTTP请求怎么拆包</h2><p>HTTP请求内容：请求行，请求头，空行，请求体</p><p>一个有报文的请求到服务器时，请求头里都会有content_length，这个指定了报文的大小。报文如果很大的时候，会通过一部分一部分的发送请求，直到结束。当这个过程中，出现多个请求，第一个请求会带有请求头信息，前面一个请求的发送的报文如果没有满时，会把后面一个请求的内容填上，这个操作就叫粘包。这样粘包后，它会<strong>通过content_length字段</strong>的大小，来做拆包。</p><p>在post发送大数据量时会分段发，接收端一次接收的只是部分post，源代码读到len&#x3D;-1直接开始处理了，但实际上还有数据没发过来，在process内判断buffer收到的len和header中的content-length是否匹配，如果不匹配直接返回false，下一个post包发过来接着用buffer收，最后收完了再开始request处理。</p><h2 id="HTTP怎么接受图片和视频流"><a href="#HTTP怎么接受图片和视频流" class="headerlink" title="HTTP怎么接受图片和视频流"></a>HTTP怎么接受图片和视频流</h2><p>使用Content-Type字段，说明响应头中的媒体数据类型。</p><h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><h2 id="用户空间缓冲区怎么实现的"><a href="#用户空间缓冲区怎么实现的" class="headerlink" title="用户空间缓冲区怎么实现的"></a>用户空间缓冲区怎么实现的</h2><p>在有IO事件发生时，要先把数据读取到缓冲区中，再从缓冲区读取出来进行处理。</p><p>首先我们在内存中创建一个缓冲区，缓冲区的大小为1024字节，同时定义两个指针，一个读指针，表示的是可以读取的数据的开始位置，一个写指针表示的是可以写入数据的起始位置，开始的时候两根指针都是指向内存开始的地方。<br>因为缓冲区的大小是固定的大小，<strong>但ET模式需要一次性将数据全部读取到缓冲区</strong>，那么就有可能装不下数据，所以需要临时创建一个缓冲区来缓解，将存不下的放到临时缓冲区，这样就可以一次性将所有的数据读入，这里利用临时缓冲区的技术是一个分散读的技术，即将数据<strong>分散读</strong>取到内存中不同的位置，再使用Append将两块内存中的数据拼接到一起。<br>Append在缓冲区空间不足时会发生扩容，<strong>扩容原则</strong>：</p><ol><li>WritableBytes() &gt;&#x3D; len，无需扩容</li><li>WritableBytes() &lt; len<ol><li>已读+可写 &gt;&#x3D; len，覆盖掉已读内容</li><li>已读+可写 &lt; len，resize数组</li></ol></li></ol><h2 id="分散读和分散写"><a href="#分散读和分散写" class="headerlink" title="分散读和分散写"></a>分散读和分散写</h2><ol><li>分散读发生在从socket缓冲区读取数据的阶段，第一块内存是用户缓冲区readBuff_，第二块内存是一块临时缓冲区，目的是为了保证将socket缓冲区的数据读完。</li><li>分散写发生在将响应写入socket阶段，第一块内存是writeBuff_，保存着响应的一些信息，组成响应头部；第二块内存使用mmap将被请求的文件映射到共享内存，调用writev将两块内存分散写入socket缓冲区。</li></ol><h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><ol><li>mmap+write</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091929438.png" alt="image.png"></p><p>这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 <strong>4 次上下文切换</strong>，因为系统调用还是 2 次。<br>文件映射相关的系统调用接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span></span>;<br>    - 功能：将一个文件或者设备的数据映射到内存中<br>    - 参数：<br>        - <span class="hljs-type">void</span> *addr: <span class="hljs-literal">NULL</span>, 由内核指定<br>        - length : 要映射的数据的长度，这个值不能为<span class="hljs-number">0</span>。建议使用文件的长度。<br>                获取文件的长度：stat lseek<br>        - prot : 对申请的内存映射区的操作权限<br>            -PROT_EXEC ：可执行的权限<br>            -PROT_READ ：读权限<br>            -PROT_WRITE ：写权限<br>            -PROT_NONE ：没有权限<br>            要操作映射内存，必须要有读的权限。<br>            PROT_READ、PROT_READ|PROT_WRITE<br>        - flags :<br>            - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项<br>            - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）<br>        - fd: 需要映射的那个文件的文件描述符<br>            - 通过open得到，open的是一个磁盘文件<br>            - 注意：文件的大小不能为<span class="hljs-number">0</span>，open指定的权限不能和prot参数有冲突。<br>                prot: PROT_READ                open:只读/读写 <br>                prot: PROT_READ | PROT_WRITE   open:读写<br>        - offset：偏移量，一般不用。必须指定的是<span class="hljs-number">4</span>k的整数倍，<span class="hljs-number">0</span>表示不偏移。<br>    - 返回值：返回创建的内存的首地址<br>        失败返回MAP_FAILED，(<span class="hljs-type">void</span> *) <span class="hljs-number">-1</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span></span>;<br>    - 功能：释放内存映射<br>    - 参数：<br>        - addr : 要释放的内存的首地址<br>        - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。<br></code></pre></td></tr></table></figure><ol start="2"><li>sendfile</li></ol><p>它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。<br>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091929969.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（_The Scatter-Gather Direct Memory Access_）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。这就是所谓的<strong>零拷贝（_Zero-copy_）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>如下图：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091929795.png" alt="image.png"></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="说下你的日志系统的运行机制？"><a href="#说下你的日志系统的运行机制？" class="headerlink" title="说下你的日志系统的运行机制？"></a>说下你的日志系统的运行机制？</h2><p>使用<strong>单例模式</strong>创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。<br>其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，<strong>写线程从队列中取出内容，写入日志文件</strong>。</p><h2 id="为什么要异步？和同步的区别是什么？"><a href="#为什么要异步？和同步的区别是什么？" class="headerlink" title="为什么要异步？和同步的区别是什么？"></a>为什么要异步？和同步的区别是什么？</h2><p><strong>写入日志时会产生比较多的系统调用，若是某条日志信息过大，会阻塞日志系统，造成系统瓶颈</strong>。异步方式采用<strong>生产者-消费者模型</strong>，具有较高的并发能力。<br>生产者-消费者模型，并发编程中的经典模型。<br>以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程<strong>共享一个缓冲区</strong>，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。<br>阻塞队列，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。</p><ol><li>异步日志，<strong>将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志</strong>。可以提高系统的并发性能。</li><li>同步日志，日志写入函数与工作线程串行执行，由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</li></ol><p>写入方式通过初始化时<strong>是否设置队列大小</strong>（表示在队列中可以放几条数据）来判断，若队列大小为0，则为同步，否则为异步。<br>若异步，则将日志信息加入阻塞队列，同步则加锁向文件中写。<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091929276.png" alt="image.png"><br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091929183.png" alt="image.png"><br>补充一下他的异步日志缓冲区刷新有滞后性。直接fputs就不管了。然后等着下一次的write_log之后的flush刷到文件里。但是不应该这样，应该异步fputs之后也刷一下。</p><h2 id="现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）"><a href="#现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）" class="headerlink" title="现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）"></a>现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）</h2><p>消息队列使用发布-订阅模式工作</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客在线编程大厂笔试模考</title>
    <link href="/posts/817d159f/"/>
    <url>/posts/817d159f/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>更新中……</p>          </div><h2 id="知识点-动态规划"><a href="#知识点-动态规划" class="headerlink" title="知识点-动态规划"></a>知识点-动态规划</h2><h3 id="VC1-牛牛吃草"><a href="#VC1-牛牛吃草" class="headerlink" title="VC1 牛牛吃草"></a>VC1 牛牛吃草</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209121720227.png" alt=" 牛牛吃草"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">3 5 20 7 5</span><br><span class="hljs-comment">1 2 5 1 3</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">23</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">W</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(n)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; W[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; A[i];<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>    dp[n<span class="hljs-number">-1</span>] = W[n<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-type">int</span> res = dp[n<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + A[i]; j &lt; n; j += A[i]) &#123;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, dp[j]);<br>        &#125;<br>        dp[i] = W[i] + maxn;<br>        res = <span class="hljs-built_in">max</span>(dp[i], res);<br>    &#125;<br>    <br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="知识点-记忆化搜索"><a href="#知识点-记忆化搜索" class="headerlink" title="知识点-记忆化搜索"></a>知识点-记忆化搜索</h2><h3 id="VC2-棋盘"><a href="#VC2-棋盘" class="headerlink" title="VC2 棋盘"></a>VC2 棋盘</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209121723378.png" alt="棋盘"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>思路：逆向思维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">1 2 3</span><br><span class="hljs-comment">4 5 6</span><br><span class="hljs-comment">7 8 9</span><br><span class="hljs-comment">1 1 1</span><br><span class="hljs-comment">1 1 1</span><br><span class="hljs-comment">1 1 1</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">2 2</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">19</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">100007</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">int</span> n, m, q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;A, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;B, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;record, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(record[x][y])&#123;<br>        <span class="hljs-keyword">return</span> record[x][y];<br>    &#125;<br>    record[x][y] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> pre_x = x + direction[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> pre_y = y + direction[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(pre_x &gt;= <span class="hljs-number">0</span> &amp;&amp; pre_x &lt; n &amp;&amp; pre_y &gt;= <span class="hljs-number">0</span> &amp;&amp; pre_y &lt; m &amp;&amp; A[pre_x][pre_y] + B[pre_x][pre_y] &lt;= A[x][y]) &#123;<br>            record[x][y] += <span class="hljs-built_in">dfs</span>(A, B, record, pre_x, pre_y); <span class="hljs-comment">// 前一步能到达该点的路径数</span><br>        &#125;<br>    &#125;<br>    record[x][y] % MOD;<br>    <span class="hljs-keyword">return</span> record[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//     freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin);</span><br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">A</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">B</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            cin &gt;&gt; A[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            cin &gt;&gt; B[i][j];<br>        &#125;<br>    &#125;<br>    <br>    cin &gt;&gt; q;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">record</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)); <span class="hljs-comment">// record[i][j] 存储能到达该点的点的路径数</span><br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        <span class="hljs-comment">// code</span><br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y; <span class="hljs-comment">// 注意 x y 下标从 1 开始</span><br>        --x;<br>        --y;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(A, B, record, x, y) &lt;&lt; endl;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="知识点-差分"><a href="#知识点-差分" class="headerlink" title="知识点-差分"></a>知识点-差分</h2><h3 id="VC3-涂颜料"><a href="#VC3-涂颜料" class="headerlink" title="VC3 涂颜料"></a>VC3 涂颜料</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209121725547.png" alt="涂颜料"></p><p>LeetCode 类似的题： <a href="https://leetcode.cn/problems/range-addition/">370. 区间加法 - 力扣（LeetCode）</a></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">1 3</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">BGRO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> color[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-type">int</span> n, q;<br>    cin &gt;&gt; n &gt;&gt; q;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (q--)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        --l; <span class="hljs-comment">// 牛客的题每次都是下标从1开始，我是真的会谢</span><br>        --r;<br>        vec[l] += <span class="hljs-number">1</span>;<br>        vec[r + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) &#123;<br>            vec[i] += vec[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(vec[i] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;O&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, color[(vec[i]<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="知识点-拓扑排序"><a href="#知识点-拓扑排序" class="headerlink" title="知识点-拓扑排序"></a>知识点-拓扑排序</h2><h3 id="VC4-相遇"><a href="#VC4-相遇" class="headerlink" title="VC4 相遇"></a>VC4 相遇</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209121801510.png" alt="image-20220912180129449"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209121802383.png" alt="image-20220912180206318"></p><p><strong>拓扑排序：</strong></p><p>有向图的拓扑排序（Topological Sort）是其顶点的线性排序，使得对于从顶点 <code>u</code> 到顶点 <code>v</code> 的每个有向边 <code>uv</code>，<code>u</code> 在排序中都在 <code>v</code> 之前。</p><p>例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。</p><p>如果且仅当图形没有定向循环，即如果它是有向无环图（DAG），则拓扑排序是可能的。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209122049169.png" alt="DAG"></p><p>任何 DAG 具有至少一个拓扑排序，存在算法用于在线性时间内构建任何 DAG 的拓扑排序。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>dfs超时了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">100007</span>;<br><span class="hljs-type">int</span> n, m, t, q;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; record;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(record.<span class="hljs-built_in">find</span>(v) != record.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">return</span> record[v];<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[v].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt += <span class="hljs-built_in">dfs</span>(graph[v][i]);<br>    &#125;<br><br>    record[v] = cnt % MOD;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<br>    record[t] = <span class="hljs-number">1</span>;<br>    graph.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        graph[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    &#125;<br><br>    cin &gt;&gt; q;<br><br>    <span class="hljs-keyword">while</span> (q--)<br>    &#123;<br>        <span class="hljs-type">int</span> s;<br>        cin &gt;&gt; s;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(s) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>bfs：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">100007</span>;<br><span class="hljs-type">int</span> n, m, t, q;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>vector&lt;<span class="hljs-type">int</span>&gt; ind;<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<br>    graph.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    ind.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        graph[u].<span class="hljs-built_in">emplace_back</span>(v);<br>        ++ind[v]; <span class="hljs-comment">// 统计入度</span><br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    stack&lt;<span class="hljs-type">int</span>&gt; sorted;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ind[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">// 入度为0的点加入队列</span><br>            que.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        sorted.<span class="hljs-built_in">emplace</span>(u); <span class="hljs-comment">// 已排序的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(--ind[v] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// u的下一跳入度减一，入度为0的点加入队列</span><br>                que.<span class="hljs-built_in">emplace</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    dp[t] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!sorted.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = sorted.<span class="hljs-built_in">top</span>();<br>        sorted.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123; <span class="hljs-comment">// 能到达该点的个数为 能达到上一跳点的个数之和</span><br>            dp[u] = (dp[u] + dp[v]) % MOD;<br>        &#125;<br>    &#125;<br><br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q--)<br>    &#123;<br>        <span class="hljs-type">int</span> s;<br>        cin &gt;&gt; s;<br>        cout &lt;&lt; dp[s] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="知识点-并查集"><a href="#知识点-并查集" class="headerlink" title="知识点-并查集"></a>知识点-并查集</h2><h3 id="VC5-信号覆盖"><a href="#VC5-信号覆盖" class="headerlink" title="VC5 信号覆盖"></a>VC5 信号覆盖</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209131156520.png" alt="image-20220913115608396"></p><p><strong>并查集：</strong></p><p>并查集（Union-find Data Structure）是一种树型的数据结构。它的特点是由子结点找到父亲结点，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">输入：</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">0 1</span><br><span class="hljs-comment">0 3</span><br><span class="hljs-comment">0 4</span><br><span class="hljs-comment">0 10</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; father;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> father[x] == x ? x : father[x] = <span class="hljs-built_in">find</span>(father[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br><br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// k = 1 时，w = 0. 基站自己与自己通信</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">points</span>(n);<br>    father.<span class="hljs-built_in">resize</span>(n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; points[i].first &gt;&gt; points[i].second;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-type">int</span> dis = (points[i].first - points[j].first) * (points[i].first - points[j].first) + (points[i].second - points[j].second) * (points[i].second - points[j].second);<br>            edges.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;i, j, dis&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123; <br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] &lt; b[<span class="hljs-number">2</span>]; <br>    &#125;);<br><br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        father[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : edges)<br>    &#123;<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">find</span>(e[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> q = <span class="hljs-built_in">find</span>(e[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span>(p ^ q) &#123; <span class="hljs-comment">// p != q // 合并两个集合</span><br>            father[p] = q; <span class="hljs-comment">// p 的 根节点改为 q</span><br>            sz[q] += sz[p]; <br>            <span class="hljs-keyword">if</span>(sz[q] &gt;= k) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, e[<span class="hljs-number">2</span>]);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="知识点-单调栈"><a href="#知识点-单调栈" class="headerlink" title="知识点-单调栈"></a>知识点-单调栈</h2><h3 id="VC6-愤怒的小鸟"><a href="#VC6-愤怒的小鸟" class="headerlink" title="VC6 愤怒的小鸟"></a>VC6 愤怒的小鸟</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209131416631.png" alt="image-20220913141657553"></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">height</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; height[i];<br>    &#125;<br><br>    stack&lt;<span class="hljs-type">int</span>&gt; stk; <span class="hljs-comment">// 单调栈，递减栈，表示可达到该点的山的个数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">R</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &lt; height[i])<br>        &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        L[i] = stk.<span class="hljs-built_in">size</span>();<br>        stk.<span class="hljs-built_in">emplace</span>(height[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;().<span class="hljs-built_in">swap</span>(stk);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &lt; height[i])<br>        &#123;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        R[i] = stk.<span class="hljs-built_in">size</span>();<br>        stk.<span class="hljs-built_in">emplace</span>(height[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (n - <span class="hljs-number">1</span> - L[i] - R[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="知识点-模拟"><a href="#知识点-模拟" class="headerlink" title="知识点-模拟"></a>知识点-模拟</h2><h3 id="VC7-彩虹涂鸦"><a href="#VC7-彩虹涂鸦" class="headerlink" title="VC7 彩虹涂鸦"></a>VC7 彩虹涂鸦</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209131542703.png" alt="image-20220913154213619"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202209131542482.png" alt="image-20220913154244431"></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC"><a href="#VC" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-1"><a href="#VC-1" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-2"><a href="#VC-2" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-3"><a href="#VC-3" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-4"><a href="#VC-4" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-5"><a href="#VC-5" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-6"><a href="#VC-6" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-7"><a href="#VC-7" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-8"><a href="#VC-8" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-9"><a href="#VC-9" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-10"><a href="#知识点-10" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-10"><a href="#VC-10" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-11"><a href="#知识点-11" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-11"><a href="#VC-11" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-12"><a href="#知识点-12" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-12"><a href="#VC-12" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-13"><a href="#知识点-13" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-13"><a href="#VC-13" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-14"><a href="#知识点-14" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-14"><a href="#VC-14" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-15"><a href="#知识点-15" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-15"><a href="#VC-15" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-16"><a href="#知识点-16" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-16"><a href="#VC-16" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-17"><a href="#知识点-17" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-17"><a href="#VC-17" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-18"><a href="#知识点-18" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-18"><a href="#VC-18" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-19"><a href="#知识点-19" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-19"><a href="#VC-19" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-20"><a href="#知识点-20" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-20"><a href="#VC-20" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-21"><a href="#知识点-21" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-21"><a href="#VC-21" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-22"><a href="#知识点-22" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-22"><a href="#VC-22" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-23"><a href="#知识点-23" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-23"><a href="#VC-23" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-24"><a href="#知识点-24" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-24"><a href="#VC-24" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-25"><a href="#知识点-25" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-25"><a href="#VC-25" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-26"><a href="#知识点-26" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-26"><a href="#VC-26" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-27"><a href="#知识点-27" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-27"><a href="#VC-27" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-28"><a href="#知识点-28" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-28"><a href="#VC-28" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-29"><a href="#知识点-29" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-29"><a href="#VC-29" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-30"><a href="#知识点-30" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-30"><a href="#VC-30" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-31"><a href="#知识点-31" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-31"><a href="#VC-31" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-32"><a href="#知识点-32" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-32"><a href="#VC-32" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-33"><a href="#知识点-33" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-33"><a href="#VC-33" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h3><h2 id="知识点-34"><a href="#知识点-34" class="headerlink" title="知识点"></a>知识点</h2><h3 id="VC-34"><a href="#VC-34" class="headerlink" title="VC"></a>VC</h3><h3 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h3>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSever 环境配置</title>
    <link href="/posts/cbaa05f8/"/>
    <url>/posts/cbaa05f8/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器-WebSever-环境配置问题记录"><a href="#Linux服务器-WebSever-环境配置问题记录" class="headerlink" title="Linux服务器 WebSever 环境配置问题记录"></a>Linux服务器 WebSever 环境配置问题记录</h1><h2 id="vscode-连接远程服务器"><a href="#vscode-连接远程服务器" class="headerlink" title="vscode 连接远程服务器"></a>vscode 连接远程服务器</h2><p>下载 Remote-SSH 插件配置连接。</p><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>本地电脑cmd输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br></code></pre></td></tr></table></figure><p>将生成的公钥复制到云服务器的<code>~/.ssh/authorized_keys</code> 里</p><h2 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h2><p>sudo apt-get install mysql-server<br>apt-get isntall mysql-client<br>sudo apt-get install libmysqlclient-dev</p><p>sudo mysql -u root -p</p><p>修改密码</p><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’</p><p>flush privileges;</p><h2 id="解决-github-Permission-denied-publickey"><a href="#解决-github-Permission-denied-publickey" class="headerlink" title="解决 github Permission denied (publickey)"></a>解决 github Permission denied (publickey)</h2><ol><li>如果没有ssh key 的话，输入命令：ssh-keygen -t <a href="https://so.csdn.net/so/search?q=rsa&spm=1001.2101.3001.7020">rsa</a> -C “<a href="mailto:&#x78;&#120;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;">&#x78;&#120;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;</a>“</li><li>打开刚刚生成的id_rsa.pub，将里面的内容复制，进入github在settings下，SSH and GPG keys下new SSH key，title随便取一个名字，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 多进程开发（2）</title>
    <link href="/posts/d87f7e0c/"/>
    <url>/posts/d87f7e0c/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-多进程开发（2）——-进程间通信"><a href="#Linux-多进程开发（2）——-进程间通信" class="headerlink" title="Linux 多进程开发（2）—— 进程间通信"></a>Linux 多进程开发（2）—— 进程间通信</h1><h2 id="进程间通信简介"><a href="#进程间通信简介" class="headerlink" title="进程间通信简介"></a>进程间通信简介</h2><p><strong>进程是一个独立的资源分配单元</strong>，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(IPC: Inter Processes Communication )。</p><p>进程间通信的目的：</p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程。</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li><li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供<strong>互斥和同步</strong>机制。</li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840928.png" alt="Linux 进程间通信的方式"></p><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。<br>统计一个目录中文件的数目命令：ls | wc -l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。<code>|</code> 就是一个匿名管道</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840845.png" alt="管道"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840865.png" alt="使用管道进行进程间通信"></p><p>管道的特点：</p><ul><li>管道其实是一个在<strong>内核内存中维护的缓冲器</strong>，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</li><li>管道拥有文件的特质：读操作、写操作，<strong>匿名管道没有文件实体</strong>，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</li><li>一个管道是一个<strong>字节流</strong>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</li><li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</li><li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，<strong>管道是半双工的</strong>。</li><li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。</li><li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li></ul><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840924.png" alt="管道缓冲区"></p><p>管道的数据结构：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840036.png" alt="管道的数据结构：环形队列"></p><h3 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int pipe(int pipefd[2]);</span><br><span class="hljs-comment">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="hljs-comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="hljs-comment">            pipefd[0] 对应的是管道的读端</span><br><span class="hljs-comment">            pipefd[1] 对应的是管道的写端</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    查看管道缓冲大小的函数：</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">long size = fpathconf(pipefd[0], _PC_PIPE_BUF);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 子进程发送数据给父进程，父进程读取到数据输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <br>        <span class="hljs-comment">// 从管道的读取端读取数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());<br>            <br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-comment">//char * str = &quot;hello,i am parent&quot;;</span><br>            <span class="hljs-comment">//write(pipefd[1], str, strlen(str));</span><br>            <span class="hljs-comment">//sleep(1);</span><br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>            <span class="hljs-comment">//sleep(1);</span><br><br>            <span class="hljs-comment">// int len = read(pipefd[0], buf, sizeof(buf));</span><br>            <span class="hljs-comment">// printf(&quot;child recv : %s, pid : %d\n&quot;, buf, getpid());</span><br>            <span class="hljs-comment">// bzero(buf, 1024);</span><br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管道的读写特点"><a href="#管道的读写特点" class="headerlink" title="管道的读写特点"></a>管道的读写特点</h3><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I&#x2F;O操作）</p><ol><li><p>所有的指向管道写端的文件描述符都关闭了（管道<strong>写端引用计数为0</strong>），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次<strong>read会返回0</strong>，就像读到文件末尾一样。</p></li><li><p>如果有指向管道写端的文件描述符没有关闭（管道的<strong>写端引用计数大于0</strong>），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次<strong>read会阻塞</strong>，直到管道中有数据可以读了才读取数据并返回。</p></li><li><p>如果所有指向管道读端的文件描述符都关闭了（管道的<strong>读端引用计数为0</strong>），这个时候有进程向管道中写数据，那么该进程会收到一个信号 <strong>SIGPIPE</strong> ，通常会导致进程异常终止。</p></li><li><p>如果有指向管道读端的文件描述符没有关闭（管道的<strong>读端引用计数大于0</strong>），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次<strong>write会阻塞</strong>，直到管道中有空位置才能再次写入数据并返回。</p></li></ol><p>总结：</p><ul><li><p>读管道：</p><ul><li>管道中有数据，read返回实际读到的字节数。</li><li>管道中无数据：<ul><li>写端被全部关闭，read返回0（相当于读到文件的末尾）</li><li>写端没有完全关闭，read阻塞等待</li></ul></li></ul></li><li><p>写管道：</p><ul><li>管道读端全部被关闭，进程异常终止（进程收到 SIGPIPE 信号）</li><li>管道读端没有全部关闭：<ul><li>管道已满，write阻塞</li><li>管道没有满，write将数据写入，并返回实际写入的字节数</li></ul></li></ul></li></ul><h3 id="设置管道非阻塞"><a href="#设置管道非阻塞" class="headerlink" title="设置管道非阻塞"></a>设置管道非阻塞</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改文件属性</span><br>        <span class="hljs-type">int</span> flags = fcntl(pipefd[<span class="hljs-number">0</span>], F_GETFL);  <span class="hljs-comment">// 获取原来的flag</span><br>        flags |= O_NONBLOCK;            <span class="hljs-comment">// 修改flag的值</span><br>        fcntl(pipefd[<span class="hljs-number">0</span>], F_SETFL, flags);   <span class="hljs-comment">// 设置新的flag</span><br></code></pre></td></tr></table></figure><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><ol><li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。</li><li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</li><li>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</li><li>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li></ol><h3 id="有名管道（FIFO）-vs-匿名管道（PIPE"><a href="#有名管道（FIFO）-vs-匿名管道（PIPE" class="headerlink" title="有名管道（FIFO） vs. 匿名管道（PIPE)"></a>有名管道（FIFO） vs. 匿名管道（PIPE)</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840941.png" alt="有名管道（FIFO） vs. 匿名管道（PIPE)"></p><h3 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h3><div class="note note-warning">            <p>有名管道的注意事项：</p><pre><code class="hljs">1. 一个以只读方式打开管道的进程会阻塞，直到另外一个进程以可写方式打开该管道；2. 一个以只写方式打开管道的进程会阻塞，直到另外一个进程以可读方式打开该管道。</code></pre>          </div><ol><li>写进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建fifo文件</span><br><span class="hljs-comment">    1.通过命令： mkfifo 名字</span><br><span class="hljs-comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 管道名称的路径</span><br><span class="hljs-comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="hljs-comment">                    是一个八进制的数</span><br><span class="hljs-comment">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 向管道中写数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2.创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;       <br><br>    &#125;<br><br>    <span class="hljs-comment">// 3.以只写的方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    读管道：</span><br><span class="hljs-comment">        管道中有数据，read返回实际读到的字节数</span><br><span class="hljs-comment">        管道中无数据：</span><br><span class="hljs-comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="hljs-comment">            写端没有全部被关闭，read阻塞等待</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    写管道：</span><br><span class="hljs-comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="hljs-comment">        管道读端没有全部关闭：</span><br><span class="hljs-comment">            管道已经满了，write会阻塞</span><br><span class="hljs-comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol start="2"><li>读进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 读数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接了...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用有名管道完成简单的聊天功能"><a href="#使用有名管道完成简单的聊天功能" class="headerlink" title="使用有名管道完成简单的聊天功能"></a>使用有名管道完成简单的聊天功能</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840338.png" alt="使用有名管道完成简单的聊天功能"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// client1.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br><br>    <span class="hljs-comment">// 1. 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125;<br><br>    ret = access(<span class="hljs-string">&quot;fifo2&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        ret = mkfifo(<span class="hljs-string">&quot;fifo2&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 2 .以只写的方式打开管道fifo1</span><br>    <span class="hljs-type">int</span> fdw = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fdw == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开 fifo1 成功，准备写入...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 3 .以只读的方式打开管道fifo2，非阻塞</span><br>    <span class="hljs-type">int</span> fdr = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fdr == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开 fifo2 成功，等待写入...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 4. 创建子进程，父进程写，子进程读，循环写读数据</span><br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>            <span class="hljs-comment">// 获取标准输入的数据</span><br>            fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>            <span class="hljs-comment">// 写数据</span><br>            ret = write(fdw, buf, <span class="hljs-built_in">strlen</span>(buf));<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>                perror(<span class="hljs-string">&quot;write&quot;</span>);<br>                close(fdw);<br>                close(fdr);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>            <span class="hljs-comment">// 读数据</span><br>            ret = read(fdr, buf, <span class="hljs-number">128</span>);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>) &#123;<br>                perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                close(fdw);<br>                close(fdr);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv: %s&quot;</span>, buf);<br>        &#125;<br>        <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        close(fdw);<br>        close(fdr);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    close(fdw);<br>    close(fdr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>client2.c</code> 代码与<code>client1.c</code>基本一致，读写的<code>fifo</code>不同。</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840340.png" alt="内存映射"></p><h3 id="内存映射的系统调用"><a href="#内存映射的系统调用" class="headerlink" title="内存映射的系统调用"></a>内存映射的系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="hljs-comment">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - void *addr: NULL, 由内核指定</span><br><span class="hljs-comment">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="hljs-comment">                    获取文件的长度：stat lseek</span><br><span class="hljs-comment">            - prot : 对申请的内存映射区的操作权限</span><br><span class="hljs-comment">                -PROT_EXEC ：可执行的权限</span><br><span class="hljs-comment">                -PROT_READ ：读权限</span><br><span class="hljs-comment">                -PROT_WRITE ：写权限</span><br><span class="hljs-comment">                -PROT_NONE ：没有权限</span><br><span class="hljs-comment">                要操作映射内存，必须要有读的权限。</span><br><span class="hljs-comment">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="hljs-comment">            - flags :</span><br><span class="hljs-comment">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="hljs-comment">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="hljs-comment">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="hljs-comment">                - 通过open得到，open的是一个磁盘文件</span><br><span class="hljs-comment">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="hljs-comment">                    prot: PROT_READ                open:只读/读写 </span><br><span class="hljs-comment">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="hljs-comment">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。</span><br><span class="hljs-comment">        - 返回值：返回创建的内存的首地址</span><br><span class="hljs-comment">            失败返回MAP_FAILED，(void *) -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int munmap(void *addr, size_t length);</span><br><span class="hljs-comment">        - 功能：释放内存映射</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - addr : 要释放的内存的首地址</span><br><span class="hljs-comment">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用内存映射实现进程间通信：</span><br><span class="hljs-comment">    1.有关系的进程（父子进程）</span><br><span class="hljs-comment">        - 还没有子进程的时候</span><br><span class="hljs-comment">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="hljs-comment">        - 有了内存映射区以后，创建子进程</span><br><span class="hljs-comment">        - 父子进程共享创建的内存映射区</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    2.没有关系的进程间通信</span><br><span class="hljs-comment">        - 准备一个大小不是0的磁盘文件</span><br><span class="hljs-comment">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 使用内存映射区通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：内存映射区通信，是非阻塞。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);  <span class="hljs-comment">// 获取文件的大小</span><br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data : %s\n&quot;</span>, buf);<br>       <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭内存映射区</span><br>    munmap(ptr, size);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h3><ol><li><p>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<br>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p></li><li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<br>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的<strong>权限保持一致</strong>。</p></li><li><p>如果文件偏移量为1000会怎样?<br>偏移量必须是4K的整数倍，返回MAP_FAILED</p></li><li><p>mmap什么情况下会调用失败?</p><ul><li>第二个参数：length &#x3D; 0</li></ul><pre><code class="hljs">- 第三个参数：prot      - 只指定了写权限        - prot PROT_READ | PROT_WRITE          第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY</code></pre></li><li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p><ul><li>可以的，但是创建的文件的大小如果为0的话，肯定不行<br>- 可以对新的文件进行扩展<ul><li>lseek()</li><li>truncate()</li></ul></li></ul></li><li><p>mmap后关闭文件描述符，对mmap映射有没有影响？<br>int fd &#x3D; open(“XXX”);<br>mmap(,,,,fd,0);<br>close(fd);<br>映射区还存在，创建映射区的fd被关闭，没有任何影响。</p></li><li><p>对ptr越界操作会怎样？<br>&#96;void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p></li></ol><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul><li><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为<strong>软件中断</strong>，它是在<strong>软件层次上对中断机制的一种模拟</strong>，是一种<strong>异步通信</strong>的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p></li><li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p><ul><li><p>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。</p></li><li><p>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</p></li><li><p>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</p></li><li><p>运行 kill 命令或调用 kill 函数。</p></li></ul></li></ul><p>使用信号的两个主要目的是：</p><ul><li>让进程知道已经发生了一个特定的事情。</li><li>强迫进程执行它自己代码中的信号处理程序。</li></ul><p>信号的特点：</p><ul><li><p>简单</p></li><li><p>不能携带大量信息</p></li><li><p>满足某个特定条件才发送</p></li><li><p>优先级比较高</p></li></ul><p>查看系统定义的信号列表：kill –l </p><p>前 31 个信号为常规信号，其余为实时信号。</p><h3 id="linux-常见信号"><a href="#linux-常见信号" class="headerlink" title="linux 常见信号"></a>linux 常见信号</h3><table><thead><tr><th>编号</th><th>信号</th><th>对应事件</th><th>默认动作</th></tr></thead><tbody><tr><td>2</td><td>SIGINT</td><td>当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td>终止进程</td></tr><tr><td>3</td><td>SIGQUIT</td><td>用户按下&lt;Ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td><td>终止进程</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程。该信号不能被忽略，处理和阻塞</td><td>终止进程，可以杀死任何正常的进程</td></tr><tr><td>11</td><td>SIGSEGV</td><td>指示进程进行了无效内存访问(段错误)</td><td>终止进程并产生core文件</td></tr><tr><td>13</td><td>SIGPIPE</td><td>Broken pipe向一个没有读端的管道写数据</td><td>终止进程</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程结束时，父进程会收到这个信号</td><td>忽略这个信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>如果进程已停止，则使其继续运行</td><td>继续&#x2F;忽略</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程的执行。信号不能被忽略，处理和阻塞</td><td></td></tr></tbody></table><h3 id="信号的-5-种默认处理动作"><a href="#信号的-5-种默认处理动作" class="headerlink" title="信号的 5 种默认处理动作"></a>信号的 5 种默认处理动作</h3><p>查看信号的详细信息：<code>man 7 signal</code></p><ul><li><p>信号的 5 中默认处理动作：</p><ul><li><p>Term 终止进程</p></li><li><p>Ign 当前进程忽略掉这个信号</p></li><li><p>Core 终止进程，并生成一个Core文件</p></li><li><p>Stop 暂停当前进程</p></li><li><p>Cont 继续执行当前被暂停的进程</p></li></ul></li><li><p>信号的几种状态：产生、未决、递达</p></li><li><p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p></li></ul><h3 id="信号相关的函数"><a href="#信号相关的函数" class="headerlink" title="信号相关的函数"></a>信号相关的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>; <span class="hljs-comment">// linux 系统调用 </span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int kill(pid_t pid, int sig);</span><br><span class="hljs-comment">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - pid ：</span><br><span class="hljs-comment">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="hljs-comment">                = 0 : 将信号发送给当前的进程组</span><br><span class="hljs-comment">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="hljs-comment">                &lt; -1 : 将信号发送给进程组ID为-pid的所有进程</span><br><span class="hljs-comment">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        kill(getppid(), 9);</span><br><span class="hljs-comment">        kill(getpid(), 9);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>; <span class="hljs-comment">// 标准 C 库函数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int raise(int sig);</span><br><span class="hljs-comment">        - 功能：给当前进程发送信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - sig : 要发送的信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 成功 0</span><br><span class="hljs-comment">            - 失败 非0</span><br><span class="hljs-comment">        kill(getpid(), sig);   </span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// 标准 C 库函数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    void abort(void);</span><br><span class="hljs-comment">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="hljs-comment">        kill(getpid(), SIGABRT);</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    unsigned int alarm(unsigned int seconds);</span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="hljs-comment">                函数会给当前的进程发送一个信号：SIGALARM</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="hljs-comment">                    取消一个定时器，通过alarm(0)。</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 之前没有定时器，返回0</span><br><span class="hljs-comment">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="hljs-comment">        alarm(10);  -&gt; 返回0</span><br><span class="hljs-comment">        过了1秒</span><br><span class="hljs-comment">        alarm(5);   -&gt; 返回9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    实际的时间 = 内核时间 + 用户时间 + 消耗的时间</span><br><span class="hljs-comment">    进行文件IO操作的时候比较浪费时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_val, <span class="hljs-keyword">struct</span> itimerval *old_value)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/time.h&gt;</span><br><span class="hljs-comment">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="hljs-comment">                        struct itimerval *old_value);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - which : 定时器以什么时间计时</span><br><span class="hljs-comment">              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="hljs-comment">              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="hljs-comment">              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - new_value: 设置定时器的属性</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">                struct itimerval &#123;      // 定时器的结构体</span><br><span class="hljs-comment">                    struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="hljs-comment">                    struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                struct timeval &#123;        // 时间的结构体</span><br><span class="hljs-comment">                    time_t      tv_sec;     //  秒数     </span><br><span class="hljs-comment">                    suseconds_t tv_usec;    //  微秒    </span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1 并设置错误号</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="信号捕捉函数signal"><a href="#信号捕捉函数signal" class="headerlink" title="信号捕捉函数signal"></a>信号捕捉函数signal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    typedef void (*sighandler_t)(int);</span><br><span class="hljs-comment">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="hljs-comment">        - 功能：设置某个信号的捕捉行为</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum: 要捕捉的信号</span><br><span class="hljs-comment">            - handler: 捕捉到信号要如何处理</span><br><span class="hljs-comment">                - SIG_IGN ： 忽略信号</span><br><span class="hljs-comment">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="hljs-comment">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="hljs-comment">                回调函数：</span><br><span class="hljs-comment">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="hljs-comment">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="hljs-comment">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="hljs-comment">            失败，返回SIG_ERR，设置错误号</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><ul><li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</li><li>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为 “未决信号集” 。这两个信号集都是内核使用<strong>位图机制</strong>来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改（信号的状态：阻塞、未决、抵达）。</li><li>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li><li>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li><li>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li></ul><p>阻塞信号集和未决信号集例子：</p><ol><li><p>用户通过键盘  Ctrl + C， 产生2号信号SIGINT （信号被创建）</p></li><li><p>信号产生但是没有被处理 （未决）</p><ul><li>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</li><li>SIGINT信号状态被存储在第二个标志位上<ul><li>这个标志位的值为0， 说明信号不是未决状态</li><li>这个标志位的值为1， 说明信号处于未决状态</li></ul></li></ul></li><li><p>这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</p><ul><li>阻塞信号集默认不阻塞任何的信号</li><li>如果想要阻塞某些信号需要用户调用系统的API</li></ul></li><li><p>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</p><ul><li>如果没有阻塞，这个信号就被处理</li><li>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</li></ul></li></ol><h3 id="自定义信号集操作相关函数"><a href="#自定义信号集操作相关函数" class="headerlink" title="自定义信号集操作相关函数"></a>自定义信号集操作相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int sigemptyset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigfillset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigaddset(sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置不阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        - 功能：判断某个信号是否阻塞</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要判断的那个信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            1 ： signum被阻塞</span><br><span class="hljs-comment">            0 ： signum不阻塞</span><br><span class="hljs-comment">            -1 ： 失败</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h3 id="内核中的信号集的相关操作"><a href="#内核中的信号集的相关操作" class="headerlink" title="内核中的信号集的相关操作"></a>内核中的信号集的相关操作</h3><p>未决信号集只能获取不能设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="hljs-comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - how : 如何对内核阻塞信号集进行处理</span><br><span class="hljs-comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="hljs-comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="hljs-comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="hljs-comment">                    mask &amp;= ~set</span><br><span class="hljs-comment">                SIG_SETMASK:覆盖内核中原来的值</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            - set ：已经初始化好的用户自定义的信号集</span><br><span class="hljs-comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">                设置错误号：EFAULT、EINVAL</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigpending(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：获取内核中的未决信号集</span><br><span class="hljs-comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="信号捕捉函数sigaction"><a href="#信号捕捉函数sigaction" class="headerlink" title="信号捕捉函数sigaction"></a>信号捕捉函数sigaction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    int sigaction(int signum, const struct sigaction *act,</span><br><span class="hljs-comment">                            struct sigaction *oldact);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="hljs-comment">            - act ：捕捉到信号之后的处理动作</span><br><span class="hljs-comment">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     struct sigaction &#123;</span><br><span class="hljs-comment">        // 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="hljs-comment">        void     (*sa_handler)(int);</span><br><span class="hljs-comment">        // 不常用</span><br><span class="hljs-comment">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="hljs-comment">        // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span><br><span class="hljs-comment">        sigset_t   sa_mask;</span><br><span class="hljs-comment">        // 使用哪一个信号处理对捕捉到的信号进行处理</span><br><span class="hljs-comment">        // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span><br><span class="hljs-comment">        int        sa_flags;</span><br><span class="hljs-comment">        // 被废弃掉了</span><br><span class="hljs-comment">        void     (*sa_restorer)(void);</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="内核实现信号捕捉的过程"><a href="#内核实现信号捕捉的过程" class="headerlink" title="内核实现信号捕捉的过程"></a>内核实现信号捕捉的过程</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840429.png" alt="信号捕捉"></p><h3 id="SIGCHILD-信号"><a href="#SIGCHILD-信号" class="headerlink" title="SIGCHILD 信号"></a>SIGCHILD 信号</h3><ul><li>SIGCHLD信号产生的条件<ul><li>子进程终止时</li><li>子进程接收到 SIGSTOP 信号停止时</li><li>子进程处在停止态，接受到SIGCONT后唤醒时</li></ul></li></ul><p>以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SIGCHLD信号产生的3个条件：</span><br><span class="hljs-comment">        1.子进程结束</span><br><span class="hljs-comment">        2.子进程暂停了</span><br><span class="hljs-comment">        3.子进程继续运行</span><br><span class="hljs-comment">        都会给父进程发送该信号，父进程默认忽略该信号。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    使用SIGCHLD信号解决僵尸进程的问题。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myFun</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号 ：%d\n&quot;</span>, num);<br><br>    <span class="hljs-comment">// 回收子进程PCB的资源</span><br>    <span class="hljs-comment">// while(1) &#123;</span><br>    <span class="hljs-comment">//     wait(NULL); </span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>       <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die , pid = %d\n&quot;</span>, ret);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 说明还有子进程或者</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>           <span class="hljs-comment">// 没有子进程</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 将 信号集 set 添加到内核阻塞信号集中</span><br><br>    <span class="hljs-comment">// 创建一些子进程</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br><br>        <span class="hljs-comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>        act.sa_flags = <span class="hljs-number">0</span>;<br>        act.sa_handler = myFun;<br>        sigemptyset(&amp;act.sa_mask);<br>        sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-comment">// 注册完信号捕捉以后，解除阻塞</span><br>        sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process pid : %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid : %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    来自评论区的大佬：https://www.nowcoder.com/study/live/504/2/27</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # 1</span><br><span class="hljs-comment">    视频中出现段错误的原因在于在信号处理函数中调用了不可重入的函数：</span><br><span class="hljs-comment">    使用gdb调试跟踪函数调用栈   // 学起来！</span><br><span class="hljs-comment">    最下层f 23可以看到是在main函数中，再往上f 22是在父进程中调用了printf</span><br><span class="hljs-comment">    再往上f 10可以看到调用了信号处理函数，这里是我们在main函数中调用printf但是printf还没有调用完成，直接转到了信号处理函数，我这里的信号处理函数为handler，见f 9，再往上f 8调用printf，可以看到f 8 和f 22是一样的</span><br><span class="hljs-comment">    SIGSEGV是因为printf会分配临时空间，在主函数调用printf至malloc时，中断处理函数调用，在其中也调用了printf至malloc时就出现了错误。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # 2</span><br><span class="hljs-comment">    1.为什么加了while可以回收之前被忽略掉SIGCHLD的僵尸进程。</span><br><span class="hljs-comment">    小伙伴们不要有这样的误解：A子进程产生信号，调用了myfun函数，waitpid（wait函数同理）就只会去回收A进程（x）。waitpid函数是个劳模，它只要见到僵尸进程就忍不住要回收，但能力有限，一次只能回收一次。只要给它机会，它可以把所有的僵尸进程一网打尽。所以只要有while循环，就可以不断执行waitpid函数，直到break。</span><br><span class="hljs-comment">    // wait 函数只负责回收僵尸进程，和 SIGCHLD 没有关系</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2.如果信号阻塞以后不能被捕获，那么是如何做到 “先阻塞SIGCHLD信号，当注册完信号捕捉以后，再解除阻塞，这样就会继续执行回调函数回收资源”？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    要弄懂这个问题，我们需要理清内核是如何处理信号的。信号的产生是异步的，A子进程产生SIGCHLD信号，不意味着父进程要立刻捕捉然后去做一些反应。当信号产生时，内核中未决信号集第17位会置1，它会等待父进程拥有cpu权限再去执行捕获信号处理函数，在去处理的瞬间17号位就会由1变为0，代表该信号有去处理了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    当我们提前设置了堵塞SIGCHLD信号，那未决集中就会一直保持1，不会调用捕获信号处理函数（也可以说信号不能被捕获），等待堵塞解除。所以并不是说，我们把信号堵塞了，然后解除堵塞，这个信号就消失了，它还是在未决集中的，值为1。捕捉函数捕获的其实就是这个1。信号捕捉不是钓鱼，钓鱼的话如果不及时处理，鱼就会跑掉。更像是网鱼，只要信号入网了，就跑不掉了。等我们准备好工具去捕获，会看到网上的鱼还是在的。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    高老师最后为什么要提前堵塞SIGCHLD信号？加了阻塞之后是什么情况？假设极端情况，20个子进程老早就终止了，内核收到SIGCHLD信号，会将未决信号集中的17号位置为1，就算他们是接连终止，该信号位也不会计数，只有保持1 。但同时该信号被提前阻塞，所以该17号位置保持1（阻塞是保持1，不是变回0），等待处理。当注册完信号捕捉函数以后，再解除阻塞。内核发现此时第17号位居然是1，那就去执行对应的捕获处理函数。在处理函数中，waitpid函数发现：“哎呦，这怎么躺着20具僵尸呀”，然后它就先回收一具僵尸，返回子进程id，循环第二次，继续回收第2具僵尸，直到所以僵尸被回收，此时已经没有子进程了，waitpid函数返回-1，break跳出循环。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    while循环中，返回值0对应的是没有僵尸但有正常的儿子，返回值-1代表压根没有儿子。所以只要子进程中存在僵尸，这个while就不会break，waitpid就可以悠哉悠哉地一次回收一具。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    《Linux/UNIX系统编程手册》指出为了保障可移植性，应用应在创建任何子进程之前就设置信号捕捉函数。【牛客789400243号】提出了这个观点，应该在fork之前就注册信号捕捉的。其实就是对应了书上这句话。</span><br><span class="hljs-comment">    // 如果没有阻塞 SIGCHLD，当所有子进程结束时信号捕捉函数还没有完成注册，内核收到 SIGCHLD 会默认忽略，等到信号捕捉函数还完成注册时，所有 SIGCHLD 信号都已近被处理了，不会调用myfun，从而产生僵尸进程。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    3. 【去冰加芝士】小伙伴的问题：为什么捕捉到了信号后没有进行处理就直接继续执行父进程后面的程序了呢？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    信号产生，内核中未决信号集SIGCHLD信号置1，内核调用信号捕捉函数myfun的同时把该信号置0，也就是说进入myfun函数后，内核依然是可以接收到SIGCHLD信号的。但是Linux为了防止某一个信号重复产生，在myfun函数进行多次递归导致堆栈空间爆了，它在调用myfhun函数会自动（内核自己完成）堵塞同类型信号。当然也可以用参数，自己指定要堵塞其他类型的信号。要注意的是，这里堵塞不是不接收信号，而是接收了不处理。当myfun函数结束，堵塞就会自动解除，该信号会传递给父进程。想象一个场景，20个子进程，先瞬间终止10个，父进程捕获到信号，进入myfun函数wait回收。这里有个点就是，父进程在执行myfun函数的时候，其他子进程不是挂起的，也是会运行的，至于怎么调度，那就看神秘莫测的调度算法了。在回收过程中，其余10个子进程也终止了，发出呼喊：“爹，快来回收我！”。父进程：“我没空，我还在myfun函数中干活”。于是内核将未决集中SIGCHLD信号置1等待处理，父进程在myfun函数中使用waitpid函数回收僵尸,”怎么越回收越多呀”，在while函数的加持下，他成功回收了20个僵尸。当它回到主函数打算休息下，内核叮的一声，有你的SIGCHLD信号，父进程以为有僵尸再次进入myfun函数，执行waipid函数，发现压根没有僵尸（上一次都回收完了），甚至儿子都没了（返回-1，break），骂骂咧咧返回了主函数。这就是为什么父进程捕获到了信号，进入了myfun函数，一个僵尸都没回收的真相。</span><br><span class="hljs-comment">    // 父进程收到 SIGCHLD 时，到调用 myfun 这段时间里，可能有新的子进程结束，这时产生的 SIGCHLD 信号会自动被系统阻塞，但是 while 循环里的 wait 会回收掉所有已经结束的子进程，包括执行循环时产生的僵尸进程等到回收完所有的僵尸进程后，之前阻塞的 SIGCHLD 信号被处理，但是这时已经没有僵尸进程了，所以直接 break。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    4.段错误究竟是怎么发生的？段错误的复现为什么这么难？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    段错误是个迷，有的人碰到过几次，有的人怎么也碰不到，这是由于神秘莫测的调度算法导致的。【潇潇_暮雨】小伙伴提出了，这是调用了不可重入的函数。《Linux/UNIX系统编程手册》第21.1.2节 对可重入函数进行了详细的解释，有兴趣的可以去翻一下。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    可重入函数的意思是：函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。通俗点讲，就是存在一个函数，A线程执行一半，B线程抢过CPU又来调用该函数，执行到1/4倍A线程抢回执行权。在这样不断来回执行中，不出问题的，就是可重入函数。多线程中每个线程都有自己的堆栈，所以如果函数中只用到局部变量肯定是可重入的，没问题的。但是更新了全局变量或静态数据结构的函数可能是不可重入的。假设某线程正在为一个链表结构添加一个新的链表项，而另外一个线程也视图更新同一链表。由于中间涉及多个指针，一旦另一线程中断这些步骤并修改了相同指针，结果就会产生混乱。但是并不是一定会出现，一定是A线程刚好在修改指针，另外一线程又去修改才会出现。这就是为什么该问题复现难度较高的原因。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    作者在文中指出，将静态数据结构用于内部记账的函数也是不可重入的。其中最明显的例子就是stdio函数库成员（printf()、scanf()等），它们会为缓冲区I/O更新内部数据结构。所以，如果在捕捉信号处理函数中调用了printf()，而主程序又在调用printf()或其他stdio函数期间遭到了捕捉信号处理函数的中断，那么有时就会看到奇怪的输出，设置导致程序崩溃。虽然printf()不是异步信号安全函数，但却频频出现在各种示例中，是因为在展示对捕捉信号处理函数的调用，以及显示函数中相关变量的内容时，printf()都不失为一种简单而又便捷的方式。真正的应用程序应当避免使用该类函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    printf函数会使用到一块缓冲区，这块缓冲区是使用malloc或类似函数分配的一块静态内存。所以它是不可重入函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul><li>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制<strong>无需内核介入</strong>。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li><li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的<strong>速度更快</strong>。</li></ul><p>使用步骤：</p><ul><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li><li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。<br>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li><li>调用 shmctl() 来删除共享内存段。<strong>只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁</strong>。只有一个进程需要执行这一步。</li></ul><p>共享内存操作命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ipcs 用法</span><br>ipcs -a    # 打印当前系统中所有的进程间通信方式的信息<br>ipcs -m   # 打印出使用共享内存进行进程间通信的信息<br>ipcs -q    # 打印出使用消息队列进行进程间通信的信息<br>ipcs -s    # 打印出使用信号进行进程间通信的信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ipcrm 用法</span><br>ipcrm -M shmkey    # 移除用shmkey创建的共享内存段<br>ipcrm -m shmid   # 移除用shmid标识的共享内存段<br>ipcrm -Q msgkey   # 移除用msqkey创建的消息队列<br>ipcrm -q msqid   # 移除用msqid标识的消息队列<br>ipcrm -S semkey   # 移除用semkey创建的信号<br>ipcrm -s semid   # 移除用semid标识的信号<br></code></pre></td></tr></table></figure><h3 id="共享内存相关的函数"><a href="#共享内存相关的函数" class="headerlink" title="共享内存相关的函数"></a>共享内存相关的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="hljs-comment">     新创建的内存段中的数据都会被初始化为0</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">     - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="hljs-comment">           一般使用16进制表示，非0值</span><br><span class="hljs-comment">     - size: 共享内存的大小</span><br><span class="hljs-comment">     - shmflg: 属性</span><br><span class="hljs-comment">       - 访问权限</span><br><span class="hljs-comment">       - 附加属性：创建/判断共享内存是不是存在</span><br><span class="hljs-comment">         - 创建：IPC_CREAT</span><br><span class="hljs-comment">         - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">           IPC_CREAT | IPC_EXCL | 0664</span><br><span class="hljs-comment">     - 返回值：</span><br><span class="hljs-comment">       失败：-1 并设置错误号</span><br><span class="hljs-comment">       成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：和当前的进程进行关联</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="hljs-comment">        - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定</span><br><span class="hljs-comment">        - shmflg : 对共享内存的操作</span><br><span class="hljs-comment">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="hljs-comment">            - 读写： 0</span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">        成功：返回共享内存的首（起始）地址。  失败(void *) -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：解除当前进程和共享内存的关联</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        shmaddr：共享内存的首地址</span><br><span class="hljs-comment">    - 返回值：成功 0， 失败 -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - shmid: 共享内存的ID</span><br><span class="hljs-comment">        - cmd : 要做的操作</span><br><span class="hljs-comment">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="hljs-comment">            - IPC_SET : 设置共享内存的状态</span><br><span class="hljs-comment">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="hljs-comment">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="hljs-comment">            - IPC_STAT : buf存储数据</span><br><span class="hljs-comment">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="hljs-comment">            - IPC_RMID : 没有用，NULL</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>; <span class="hljs-comment">// C 库函数 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：根据指定的路径名，和int值，生成一个共享内存的key</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - pathname:指定一个存在的路径</span><br><span class="hljs-comment">            /home/nowcoder/Linux/a.txt</span><br><span class="hljs-comment">            / </span><br><span class="hljs-comment">        - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节</span><br><span class="hljs-comment">                   范围 ： 0-255  一般指定一个字符 &#x27;a&#x27;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>问题1：操作系统如何知道一块共享内存被多少个进程关联？</strong></p><ul><li>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</li><li>shm_nattach 记录了关联的进程个数</li></ul><p><strong>问题2：可不可以对共享内存进行多次删除 shmctl</strong></p><pre><code class="hljs">- 可以的    - 因为shmctl 标记删除共享内存，不是直接删除    - 什么时候真正删除呢?        当和共享内存关联的进程数为0的时候，就真正被删除    - 当共享内存的key为0的时候，表示共享内存被标记删除了        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</code></pre><p><strong>共享内存和内存映射的区别：</strong></p><ol><li><p>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</p></li><li><p>共享内存效率更高</p></li><li><p>内存</p><ul><li>所有的进程操作的是同一块共享内存。</li><li>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li></ul></li><li><p>数据安全</p><ul><li>进程突然退出<ul><li>共享内存还存在</li><li>内存映射区消失</li></ul></li><li>运行进程的电脑死机，宕机了<ul><li>数据存在在共享内存中，没有了</li><li>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li></ul></li></ul></li><li><p>生命周期</p><ul><li>内存映射区：进程退出，内存映射区销毁</li><li>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0）<br>  如果一个进程退出，会自动和共享内存进行取消关联。</li></ul></li></ol><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840440.png" alt="终端"></p><p>控制终端的信息保存在PCB中。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840551.png" alt="进程组"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840643.png" alt="会话"></p><p>一个控制终端对应一个会话，会话中的唯一前台进程组才能从控制终端中读取输入。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840745.png" alt="进程组、会话、控制终端的关系"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840860.png" alt="相关函数"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840888.png" alt="守护进程"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840864.png" alt="创建守护进程"></p><p>其他笔记：</p><blockquote><p> 原文链接：<a href="https://www.cnblogs.com/DianaCody/p/5425641.html">linux创建守护进程</a></p></blockquote><ol><li><p>创建子进程，父进程退出: (假象–父进程已完成，可退出终端)<br> 这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成一程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在<strong>形式上做到了与控制终端的脱离</strong>。<br> 在Linux中父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程是，就会自动由1号进程（init）收养它，这样，原先的子进程就会变成init进程的子进程。</p></li><li><p>在子进程中创建新会话: 使用系统函数setid()–进程组、会话期<br>  这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用的是系统函数setsid，在具体介绍setsid之前，首先要了解两个概念：进程组和会话期</p><p>  进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程组ID不会因组长进程的退出而受到影响。</p><p>  会话周期：会话期是一个或多个进程组的集合。通常，一个会话开始与用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期。<br>  接下来就可以具体介绍setsid的相关内容：<br>  setsid函数作用：setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid有下面的3个作用：</p><ul><li><p>让进程摆脱原会话的控制</p></li><li><p>让进程摆脱原进程组的控制</p></li><li><p>让进程摆脱原控制终端的控制</p></li></ul><p> 那么，在创建守护进程时为什么要调用setsid函数呢？由于创建守护进程的第一步调用了fork函数来创建子进程，再将父进程退出。由于在调用了fork函数时，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，还还不是真正意义上的独立开来，而<strong>setsid函数能够使进程完全独立出来，从而摆脱其他进程的控制</strong>。</p></li><li><p>改变当前目录为根目录<br>  使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“&#x2F;mnt&#x2F;usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入但用户模式）。因此，通常的做法是让”&#x2F;“作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如&#x2F;tmp。改变工作目录的常见函数式chdir。</p></li><li><p>重设文件权限掩码: umask(0)<br>  文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。</p></li><li><p>关闭文件描述符<br>  同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。</p><p>  在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，<strong>文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭</strong>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 多进程开发（1）</title>
    <link href="/posts/b76a0a04/"/>
    <url>/posts/b76a0a04/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-多进程开发（1）"><a href="#Linux-多进程开发（1）" class="headerlink" title="Linux 多进程开发（1）"></a>Linux 多进程开发（1）</h1><h3 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">man ps <span class="hljs-comment"># 查看手册</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ps - report a snapshot of the current processes.</span><br>ps [-option] # aux/ajx<br>a: all<br>u:<br>j: job<br>x: <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2</span><br>tty # 查看当前终端信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 实时查看进行信息</span><br>top [-option]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 向进程发送信号</span><br>kill <br>kill -l # 查看所有信号<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台运行</span><br>[命令] &amp;<br></code></pre></td></tr></table></figure><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>fork函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    pid_t fork(void);</span><br><span class="hljs-comment">        函数的作用：用于创建子进程。</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="hljs-comment">            在父进程中返回创建的子进程的ID,</span><br><span class="hljs-comment">            在子进程中返回0</span><br><span class="hljs-comment">            如何区分父进程和子进程：通过fork的返回值。</span><br><span class="hljs-comment">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        父子进程之间的关系：</span><br><span class="hljs-comment">        区别：</span><br><span class="hljs-comment">            1.fork()函数的返回值不同</span><br><span class="hljs-comment">                父进程中: &gt;0 返回的子进程的ID</span><br><span class="hljs-comment">                子进程中: =0</span><br><span class="hljs-comment">            2.pcb中的一些数据</span><br><span class="hljs-comment">                当前的进程的id pid</span><br><span class="hljs-comment">                当前的进程的父进程的id ppid</span><br><span class="hljs-comment">                信号集</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        共同点：</span><br><span class="hljs-comment">            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="hljs-comment">                - 用户区的数据</span><br><span class="hljs-comment">                - 文件描述符表</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        父子进程对变量是不是共享的？</span><br><span class="hljs-comment">            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="hljs-comment">            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 判断是父进程还是子进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// printf(&quot;pid : %d\n&quot;, pid);</span><br>        <span class="hljs-comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent num : %d\n&quot;</span>, num);<br>        num += <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent num += 10 : %d\n&quot;</span>, num);<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前是子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());<br>       <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child num : %d\n&quot;</span>, num);<br>        num += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child num += 100 : %d\n&quot;</span>, num);<br>    &#125;<br><br>    <span class="hljs-comment">// for循环, 父子进程交替执行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy-on-write) 实现。</span><br><span class="hljs-comment">    写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span><br><span class="hljs-comment">    内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span><br><span class="hljs-comment">    只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span><br><span class="hljs-comment">    也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span><br><span class="hljs-comment">    注意：fork之后父子进程共享文件，</span><br><span class="hljs-comment">    fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="GDB-多进程调试"><a href="#GDB-多进程调试" class="headerlink" title="GDB 多进程调试"></a>GDB 多进程调试</h3><p>gdb默认只跟踪一个进程，默认调试父进程，子进程代码直接运行。设置调试默认调试的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set follow-fork-mode [parent (default) | child]<br></code></pre></td></tr></table></figure><p>设置调试的模式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set detach-on-fork [on (default) | off]<br></code></pre></td></tr></table></figure><p>on：调试时其他进程继续运行；</p><p>off：调试时其他进程被 gdb 挂起。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看调试的进程</span><br>info inferiors<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换当前调试的进程</span><br>inferior id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使进程脱离 gdb 调试</span><br>detach inferiors id<br></code></pre></td></tr></table></figure><h3 id="exce-函数族"><a href="#exce-函数族" class="headerlink" title="exce 函数族"></a>exce 函数族</h3><p>函数名称不同，功能相似的函数叫函数族。</p><ul><li>exec 函数族的作用是<strong>根据指定的文件名找到可执行文件，并用它来取代调用进程的内容</strong>，换句话说，就是在调用进程内部执行一个可执行文件。</li><li>exec 函数族的函数执行成功后<strong>不会返回</strong>，因为调用进程的实体，包括代码段，数据段和堆栈等都已经<strong>被新的内容取代</strong>，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回 -1，从<strong>原程序的调用点</strong>接着往下执行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 标准 C 库函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/* (char  *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... <span class="hljs-comment">/* (char  *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><br><span class="hljs-comment">// linux 系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br></code></pre></td></tr></table></figure><ul><li>l(list)：参数地址列表，以空指针结尾</li><li>v(vector) ：存有各参数地址的指针数组的地址</li><li>p(path) ：按 PATH 环境变量指定的目录搜索可执行文件</li><li>e(environment) ：存有环境变量字符串地址的指针数组的地址</li></ul><ol><li><code>int execl(const char *path, const char *arg, .../* (char  *) NULL */);</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int execl(const char *path, const char *arg, ...);</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - path:需要指定的执行的文件的路径或者名称</span><br><span class="hljs-comment">                a.out /workspace/cpp_test/a.out 推荐使用绝对路径</span><br><span class="hljs-comment">                ./a.out hello world</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="hljs-comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="hljs-comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="hljs-comment">                参数最后需要以NULL结束（哨兵）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="hljs-comment">            如果调用成功，没有返回值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">1</span>); <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        execl(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span><br>        perror(<span class="hljs-string">&quot;execl&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid()); <span class="hljs-comment">// 不执行</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果：</span><br><span class="hljs-comment">i am parent process, pid : 9175</span><br><span class="hljs-comment">hello, world</span><br><span class="hljs-comment">i = 0, pid = 9175</span><br><span class="hljs-comment">i = 1, pid = 9175</span><br><span class="hljs-comment">i = 2, pid = 9175</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int execlp(const char *file, const char *arg, ... );</span><br><span class="hljs-comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - file:需要执行的可执行文件的文件名</span><br><span class="hljs-comment">                a.out</span><br><span class="hljs-comment">                ps</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="hljs-comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="hljs-comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="hljs-comment">                参数最后需要以NULL结束（哨兵）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="hljs-comment">            如果调用成功，没有返回值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        int execv(const char *path, char *const argv[]);</span><br><span class="hljs-comment">        argv是需要的参数的一个字符串数组</span><br><span class="hljs-comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span><br><span class="hljs-comment">        execv(&quot;/bin/ps&quot;, argv);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br>        perror(<span class="hljs-string">&quot;execl&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果：</span><br><span class="hljs-comment">i am parent process, pid : 11115</span><br><span class="hljs-comment"> PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND</span><br><span class="hljs-comment"> 2578  2579  2579  2579 pts/0    11115 Ss     500   0:00 -bash</span><br><span class="hljs-comment"> 2579 11115 11115  2579 pts/0    11115 S+     500   0:00 ./execlp.out</span><br><span class="hljs-comment">11115 11116 11115  2579 pts/0    11115 R+     500   0:00 ps j</span><br><span class="hljs-comment">i = 0, pid = 11115</span><br><span class="hljs-comment">i = 1, pid = 11115</span><br><span class="hljs-comment">i = 2, pid = 11115</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 标准库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br><br><span class="hljs-comment">// Liunx 系统调用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151700198.png" alt="进程退出"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">    void exit(int status);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    void _exit(int status);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 相当于 return 0;</span><br>    <span class="hljs-comment">// _exit(0);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>exit(0) 执行的结果（会刷新缓冲区）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151711526.png" alt="exit(0)"></p><p>_exit(0) 执行的结果（不会刷新缓冲区）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151711601.png" alt="_exit(0)"></p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan<br>Process）。<br>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而 init 进程会循环地 wait() 它<br>的已经退出的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 判断是父进程还是子进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 当前是子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());<br>       <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p>子进程的文件描述符表里的012复制于父进程，所以输出到同一个终端。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151715269.png" alt="孤儿进程"></p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul><li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</li><li>子进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</li><li>僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</li></ul><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">i am parent process, pid : 17195, ppid : 13038<br>i am child process, pid : 17196, ppid : 17195<br>i : 0 , pid : 17196<br>i : 1 , pid : 17196<br>i : 2 , pid : 17196<br>i am parent process, pid : 17195, ppid : 13038<br>i am parent process, pid : 17195, ppid : 13038<br>i am parent process, pid : 17195, ppid : 13038<br>...<br></code></pre></td></tr></table></figure><p>新建终端使用 ps命令查看，子进程变为僵尸进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">PPID   PID  PGID   SID  TTY      TPGID STAT   UID   TIME COMMAND<br>13038 17195 17195 13038 pts/0    17195 S+     500   0:00 ./zombie<br>17195 17196 17195 13038 pts/0    17195 Z+     500   0:00 [zombie] &lt;defunct&gt;<br></code></pre></td></tr></table></figure><h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。<br>父进程可以通过调用 wait 或 waitpid 得到它的退出状态同时彻底清除掉这个进程。<br>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，<br>waitpid() 还可以指定等待哪个子进程结束。<br>注意：一次 wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</p><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait() 函数"></a>wait() 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">    pid_t wait(int *wstatus);</span><br><span class="hljs-comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span><br><span class="hljs-comment">        参数：int *wstatus</span><br><span class="hljs-comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            - 成功：返回被回收的子进程的id</span><br><span class="hljs-comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="hljs-comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 有一个父进程，创建5个子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent, pid = %d\n&quot;</span>, getpid());<br>            <br>            <span class="hljs-comment">// int ret = wait(NULL);</span><br>            <br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//所有的子进程都结束</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFEXITED(st)) &#123;<br>                <span class="hljs-comment">// 是不是正常退出</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFSIGNALED(st)) &#123;<br>                <span class="hljs-comment">// 是不是异常终止</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-comment">// kill 信号</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>,getpid());    <br>           sleep(<span class="hljs-number">1</span>);       <br>        &#125;<br>        <br>        <span class="hljs-comment">// 正常退出</span><br>        <span class="hljs-comment">// printf(&quot;child, pid = %d\n&quot;,getpid());</span><br><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// exit(0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>退出信息相关宏函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">WIFEXITED(status)     <span class="hljs-comment">// 非0，进程正常退出</span><br>WEXITSTATUS(status)   <span class="hljs-comment">// 如果上宏为真，获取进程退出的状态（exit的参数）</span><br>WIFSIGNALED(status)   <span class="hljs-comment">// 非0，进程异常终止</span><br>WTERMSIG(status)      <span class="hljs-comment">// 如果上宏为真，获取使进程终止的信号编号</span><br>WIFSTOPPED(status)    <span class="hljs-comment">// 非0，进程处于暂停状态</span><br>WSTOPSIG(status)      <span class="hljs-comment">// 如果上宏为真，获取使进程暂停的信号的编号</span><br>WIFCONTINUED(status)  <span class="hljs-comment">// 非0，进程暂停后已经继续运行</span><br></code></pre></td></tr></table></figure><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid() 函数"></a>waitpid() 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="hljs-comment">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pid:</span><br><span class="hljs-comment">                pid &gt; 0 : 某个子进程的pid</span><br><span class="hljs-comment">                pid = 0 : 回收当前进程组的任一子进程    </span><br><span class="hljs-comment">                pid = -1 : 回收任一的子进程，相当于 wait()  （最常用）</span><br><span class="hljs-comment">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="hljs-comment">            - options：设置阻塞或者非阻塞</span><br><span class="hljs-comment">                0 : 阻塞</span><br><span class="hljs-comment">                WNOHANG : 非阻塞</span><br><span class="hljs-comment">            - 返回值：</span><br><span class="hljs-comment">                &gt; 0 : 返回子进程的id</span><br><span class="hljs-comment">                = 0 : options=WNOHANG, 表示还有子进程活着</span><br><span class="hljs-comment">                = -1 ：错误，或者没有子进程了</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    getpgrp函数可获取当前进程的进程组ID。</span><br><span class="hljs-comment">    getpgid函数可获取指定进程的进程组ID。</span><br><span class="hljs-comment">    setpgid函数可改变进程默认的进程组，可加入另一个进程组或创建进程组。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 有一个父进程，创建5个子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent, pid = %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-comment">// int ret = waitpid(-1, &amp;st, 0);  // 相当于 wait(&amp;st);</span><br>            <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, &amp;st, WNOHANG);<br><br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 说明还有子进程存在</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br><br>                <span class="hljs-keyword">if</span>(WIFEXITED(st)) &#123;<br>                    <span class="hljs-comment">// 是不是正常退出</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(WIFSIGNALED(st)) &#123;<br>                    <span class="hljs-comment">// 是不是异常终止</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            &#125;<br>           <br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>         <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>,getpid());    <br>            sleep(<span class="hljs-number">1</span>);       <br>         &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统编程入门</title>
    <link href="/posts/bb4cd573/"/>
    <url>/posts/bb4cd573/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-系统编程入门"><a href="#Linux-系统编程入门" class="headerlink" title="Linux 系统编程入门"></a>Linux 系统编程入门</h1><h2 id="gcc-编译命令"><a href="#gcc-编译命令" class="headerlink" title="gcc 编译命令"></a>gcc 编译命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc [FileName] [-o ProgramName]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用编译选项</span><br>[-o] 目标文件名<br>[-E] 预处理，生成预处理后的代码，不编译<br>[-S] 编译，生成汇编代码，不汇编<br>[-c] 汇编，生成目标代码，但是不进行链接<br>[-I directory] 指定 include 包含文件的搜索目录<br>[-g] 在编译的时候，生成调试信息，该程序可以被调试器调试<br>[-D] 编译的时候定义一个宏<br>[-l] 链接的库<br></code></pre></td></tr></table></figure><p>g++ 在编译的阶段调用 gcc，但是 gcc 不能自动和 c++ 程序使用的库链接，除非添加编译选项 <code>gcc -lstdc++</code>。</p><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><ol><li><p>命名规则：</p><ol><li>Linux：libxxx.a</li><li>Windows：libxxx.lib</li></ol></li><li><p>静态库的制作</p><ol><li><p>gcc 编译生成 -o 汇编文件</p><p> <code>gcc -c a.c b.c</code></p></li><li><p>对汇编文件打包，创建静态库</p><p> <code>ar rcs libxxx.a a.o b.o</code></p></li></ol></li></ol><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc FileName -l xxx<br></code></pre></td></tr></table></figure><p><code>xxx</code> 为 库名称，而非库文件名称</p><h3 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h3><ol><li><p>命名规则：</p><ol><li>Linux：libxxx.so</li><li>Windows：libxxx.dll</li></ol></li><li><p>动态库的制作</p><ol><li><p>gcc 编译生成 -o 汇编文件</p><p> <code>gcc -c -fpic/-fPIC a.c b.c</code></p></li><li><p>gcc 制作动态库</p><p> <code>gcc -shared *.o -o libxxx.so</code></p></li></ol></li></ol><h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><ol><li><p>程序运行时动态库加载失败的原因：</p><p> 系统加载可执行代码的时候，除了需要知道所依赖的动态库的名称，还需要知到其绝对路径，此时需要系统的动态载入器来获取其绝对路径。</p></li><li><p>解决方法：</p><ol><li><p>添加环境变量，只在当前终端生效（临时）</p><p> <code>export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:libso_path</code></p></li><li><p>添加环境变量，在<code>~/.bashrc</code>中添加（用户级别）</p><p> <code>export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:libso_path</code></p><p> 使环境变量生效</p><p> <code>source ~/.bashrc</code> 或者 <code>，~/.bashrc</code></p></li><li><p>添加环境变量，在<code>/etc/profile</code>中添加（系统级别）</p><p> <code>export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:libso_path</code></p><p> 使环境变量生效</p><p> <code>source /etc/profile</code> 或者 <code>，/etc/profile</code></p></li><li><p>修改 <code>/etc/ld.so.cache</code>，二进制文件，不能直接修改，通过 <code>/etc/ld.so.conf</code> 修改，直接添加<code>libso_path</code>，<code>ldconfig</code> 使修改生效。</p></li><li><p>将动态库文件放在 <code>/lib/</code> 或者 <code>/usr/lib/</code> 目录下（不建议），可能会替换同名的系统库文件。</p></li></ol></li></ol><h3 id="静态库-vs-动态库"><a href="#静态库-vs-动态库" class="headerlink" title="静态库 vs. 动态库"></a>静态库 vs. 动态库</h3><ol><li><p>静态库</p><ul><li><p>优点：</p><p> a. 加载速度快</p><p> b. 发布程序无需提供静态库，移植方便</p></li><li><p>缺点：</p><p> a. 消耗系统资源，浪费内存</p><p> b. 更新、部署、发布麻烦</p></li></ul></li><li><p>动态库</p><ul><li><p>优点：</p><p> a. 可以实现进程间的资源共享</p><p> b. 更新、部署、发布简单</p><p> c. 可以控制核实加载动态库</p></li><li><p>缺点：</p><p> a. 加载速度比静态库慢</p><p> b. 发布程序是需要提供依赖的动态库</p></li></ul></li></ol><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="什么是-Makefile"><a href="#什么是-Makefile" class="headerlink" title="什么是 Makefile"></a>什么是 Makefile</h3><ul><li>工程的源文件根据类型、功能、模块分别放在不同的目录中，Makefile 文件定义了以系列规则来指定哪些文件先编译，哪些文件后编译，哪些文件需要重新编译，甚至更复杂的功能。</li><li>Makefile 带来的好处：“自动化编译”，make 是解释 Makefile 的命令工具。</li></ul><h3 id="Makefile-文件命名和规则"><a href="#Makefile-文件命名和规则" class="headerlink" title="Makefile 文件命名和规则"></a>Makefile 文件命名和规则</h3><ol><li><p>文件命名：</p><p> Makefile 或者 makefile</p></li><li><p>规则：</p></li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">目标 ... : 依赖...<br>    命令 (shell 命令)<br>    ...<br><br><span class="hljs-section">目标: 最终要生成的文件 (伪目标除外)</span><br><span class="hljs-section">依赖: 生成目标所需要的文件或是目标</span><br><span class="hljs-section">命令: 通过执行命令对依赖操作生成目标 (前有缩进)</span><br><br>Makefile 文件里的其他规则一般是为第一条规则服务的. <br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1</span><br><span class="hljs-section">app:sub.c add.c mult.c div.c main.c</span><br>    gcc sub.c add.c mult.c div.c main.c -o app<br>    <br><span class="hljs-comment"># 2</span><br><span class="hljs-section">app:sub.o add.o mult.o div.o main.o</span><br>    gcc sub.o add.o mult.o div.o main.o -o app<br><br><span class="hljs-section">sub.o:sub.c</span><br>    gcc -c sub.c -o sub.o<br><br><span class="hljs-section">add.o:add.c</span><br>    gcc -c add.c -o add.o<br><br><span class="hljs-section">mult.o:mult.c</span><br>    gcc -c mult.c -o mult.o<br><br><span class="hljs-section">div.o:div.c</span><br>    gcc -c div.c -o div.o<br><br><span class="hljs-section">main.o:main.c</span><br>    gcc -c main.c -o main.o<br>    <br><span class="hljs-comment"># 3</span><br><span class="hljs-comment">#定义变量</span><br>src=sub.o add.o mult.o div.o main.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(src)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(src)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">sub.o:sub.c</span><br>    gcc -c sub.c -o sub.o<br><br><span class="hljs-section">add.o:add.c</span><br>    gcc -c add.c -o add.o<br><br><span class="hljs-section">mult.o:mult.c</span><br>    gcc -c mult.c -o mult.o<br><br><span class="hljs-section">div.o:div.c</span><br>    gcc -c div.c -o div.o<br><br><span class="hljs-section">main.o:main.c</span><br>    gcc -c main.c -o main.o<br>    <br><span class="hljs-comment"># 4</span><br><span class="hljs-comment">#定义变量</span><br>src=sub.o add.o mult.o div.o main.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(src)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(src)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br>    <br><span class="hljs-comment"># 5</span><br><span class="hljs-comment">#定义变量</span><br><span class="hljs-comment"># add.c sub.c main.c mult.c div.c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objs=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(objs)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(objs)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br><span class="hljs-section">clean:</span><br>    rm <span class="hljs-variable">$(objs)</span> -f<br></code></pre></td></tr></table></figure><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p>命令:</p><p>向可执行程序中加入调试信息. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g test.c -o test<br></code></pre></td></tr></table></figure><p>启动&#x2F;退出 gdb:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb [可执行文件] # 启动<br><br>(gdb) q/quit # 退出 gdb<br></code></pre></td></tr></table></figure><p>gdb 常用命令: </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 给程序设置参数/获取设置参数</span><br>(gdb) set args 10 20    <span class="hljs-comment"># 设置函数参数</span><br>(gdb) show args         <span class="hljs-comment"># 获取函数参数</span><br><br>(gdb) help [command] <span class="hljs-comment"># 查看帮助文档</span><br><br><span class="hljs-comment"># 查看当前文件代码</span><br>(gdb) list/l        <span class="hljs-comment"># 从默认位置显, 默认10行</span><br>(gdb) list/l line   <span class="hljs-comment"># 从指定的行显示, 行号上下文</span><br>(gdb) list/l func   <span class="hljs-comment"># 从指定的函数显示, func上下文</span><br><br><span class="hljs-comment"># 查看非当前文件代码</span><br>(gdb) list/l filename : line<br>(gdb) list/l filename : func<br><br><span class="hljs-comment"># 设置显示的行数</span><br>(gdb) show list/listsize<br>(gdb) set list/listsize line<br><br><span class="hljs-comment"># 设置断点</span><br>(gdb) b/break line<br>(gdb) b/break func<br>(gdb) b/break filename : line<br>(gdb) b/break filename : func<br><br><span class="hljs-comment"># 查看断点</span><br>(gdb) i/info b/break<br><br><span class="hljs-comment"># 删除断点</span><br>(gdb) d/del/delete brk_num<br><br><span class="hljs-comment"># 设置断点无效</span><br>(gdb) dis/disable brk_num<br><br><span class="hljs-comment"># 设置断点生效</span><br>(gdb) en/enable brk_num<br><br><span class="hljs-comment"># 设置条件断点 (一般用在循环位置)</span><br>(gdb) b/break 10 if i==5<br><br><span class="hljs-comment"># 运行GDB程序</span><br>(gdb) start     <span class="hljs-comment"># 停在main第一行</span><br>(gdb) run       <span class="hljs-comment"># 停在第一个断点</span><br><br><span class="hljs-comment"># 继续运行</span><br>(gdb) c/continue    <span class="hljs-comment"># 下一个断点</span><br>(gdb) n/next        <span class="hljs-comment"># 下一行, 不会进入函数体</span><br>(gdb) s/step        <span class="hljs-comment"># 单步调试, 会进入函数体</span><br>(gdb) finish        <span class="hljs-comment"># 跳出函数体</span><br><br><span class="hljs-comment"># 变量操作</span><br>(gdb) p/print variable      <span class="hljs-comment"># 打印变量值</span><br>(gdb) ptype   variable      <span class="hljs-comment"># 打印变量类型</span><br><br><span class="hljs-comment"># 自动变量操作</span><br>(gdb) display variable <span class="hljs-comment"># 自动打印指定变量</span><br>(gdb) i/info display<br>(gdb) undisplay no.<br><br><span class="hljs-comment"># 其他操作</span><br>(gdb) set var variable = value  <span class="hljs-comment"># 设置变量的值</span><br>(gdb) until                     <span class="hljs-comment"># 跳出循环</span><br></code></pre></td></tr></table></figure><p>gdb 不输入命名按回车默认执行上一条命令。</p><h2 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h2><h3 id="标准-C-库-IO-函数"><a href="#标准-C-库-IO-函数" class="headerlink" title="标准 C 库 IO 函数"></a>标准 C 库 IO 函数</h3><p>标准 C 库中的IO函数 调用操作系统的 API，可以跨平台。<br>标准 C 库的IO函数带有缓冲区，效率较高。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120301129.png" alt="![](https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120301129.png)"></p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>32位操作系统的虚拟地址空间：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120308467.png" alt="虚拟地址空间"></p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件描述符</span><br>0 -&gt; STDIN_FILENO# 标准输入<br>1 -&gt; STDOUT_FILENO# 标准输出<br>2 -&gt; STDERR_FILENO# 标准错误<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120322763.png" alt="文件描述符"></p><p>文件描述符表是一个数组，默认大小为1024。前三个元素被占用，默认打开，指向当前终端。</p><h3 id="Linux-系统-IO-函数"><a href="#Linux-系统-IO-函数" class="headerlink" title="Linux 系统 IO 函数"></a>Linux 系统 IO 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>; <span class="hljs-comment">// 关闭文件描述符，fd 不再指向任何文件，并可以被再次使用</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span>;<br></code></pre></td></tr></table></figure><p>可使用<code>man</code> 命令查看说明文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man 2 open<br></code></pre></td></tr></table></figure><h4 id="open-系统调用"><a href="#open-系统调用" class="headerlink" title="open 系统调用"></a>open 系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 所需头文件: </span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      <span class="hljs-comment">// flags : 权限标记, Linux 里定义为宏, 在前两个头文件里</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>       <span class="hljs-comment">//</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>          <span class="hljs-comment">// open 的函数声明</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>; <span class="hljs-comment">// 打开一个已存在文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>; <span class="hljs-comment">// 创建一个新的文件</span><br></code></pre></td></tr></table></figure><p>C 没有函数重载, 两个 open 通过可变参数实现: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, ...)</span>;<br></code></pre></td></tr></table></figure><p>打开一个已存在文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 打开一个已存在文件</span><br><span class="hljs-comment">    int open(const char *pathname, int flags);</span><br><span class="hljs-comment">        parameters:</span><br><span class="hljs-comment">            pathname : 要打开的文件路径</span><br><span class="hljs-comment">            flags    : 对文件的操作权限设置和其他设置</span><br><span class="hljs-comment">                必选 : O_RDONLY, O_WRONLY, or O_RDWR. 这三个互斥</span><br><span class="hljs-comment">                可选 : O_APPEND, O_CREAT, O_TRUNC 等 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        return value :</span><br><span class="hljs-comment">            成功返回新的文件描述符, 失败返回 -1 </span><br><span class="hljs-comment">        errno : </span><br><span class="hljs-comment">            属于 Linux 系统函数库, 库里面的全局变量, 记录的是最近的错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    perror函数</span><br><span class="hljs-comment">    # include &lt;stdio.h&gt;</span><br><span class="hljs-comment">    // 打印对应 errno 对应的错误描述</span><br><span class="hljs-comment">    void perror(const char *s);</span><br><span class="hljs-comment">    输出: s: system error message</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      <span class="hljs-comment">// flag : 权限标记, Linux 里定义为宏, 在前两个头文件里</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>       <span class="hljs-comment">//</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>          <span class="hljs-comment">// open 的函数声明</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDONLY); <span class="hljs-comment">// 当前目录不存在 a.txt</span><br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>); <span class="hljs-comment">// 输出 : open: No such file or directory</span><br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件描述符</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个新的文件：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"># include &lt;sys/types.h&gt;      // flags : 权限标记, Linux 里定义为宏, 在前两个头文件里</span><br><span class="hljs-comment"># include &lt;sys/stat.h&gt;       //</span><br><span class="hljs-comment"># include &lt;fcntl.h&gt;          // open 的函数声明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-comment">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="hljs-comment">    parameters:</span><br><span class="hljs-comment">        pathname : 要打开的文件路径</span><br><span class="hljs-comment">        flags    : 对文件的操作权限设置和其他设置</span><br><span class="hljs-comment">            必选 : O_RDONLY, O_WRONLY, or O_RDWR. 这三个互斥</span><br><span class="hljs-comment">            可选 :  O_APPEND, O_CREAT, O_TRUNC 等 </span><br><span class="hljs-comment">        mode: 八进制数, 表示创建出的文件操作权限, 比如 0775, 0 表示八进制</span><br><span class="hljs-comment">            最终的权限是 mode &amp; ~umask</span><br><span class="hljs-comment">                </span><br><span class="hljs-comment">    return value :</span><br><span class="hljs-comment">        成功返回新的文件描述符, 失败返回 -1 </span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      <span class="hljs-comment">// flag : 权限标记, Linux 里定义为宏, 在前两个头文件里</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>       <span class="hljs-comment">//</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>          <span class="hljs-comment">// open 的函数声明</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0777</span>); <span class="hljs-comment">// 创建 create.txt</span><br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>); <br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件描述符</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    ssize_t read(int fd, void *buf, size_t count);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="hljs-comment">            - buf：需要读取数据存放的地方，数组的地址（传出参数）</span><br><span class="hljs-comment">            - count：指定的数组的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            - 成功：</span><br><span class="hljs-comment">                &gt;0: 返回实际的读取到的字节数</span><br><span class="hljs-comment">                =0：文件已经读取完了</span><br><span class="hljs-comment">            - 失败：-1 ，并且设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="hljs-comment">            - buf：要往磁盘写入的数据，数据</span><br><span class="hljs-comment">            - count：要写的数据的实际的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功：实际写入的字节数</span><br><span class="hljs-comment">            失败：返回-1，并设置errno</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.通过open打开english.txt文件</span><br>    <span class="hljs-type">int</span> srcfd = open(<span class="hljs-string">&quot;english.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(srcfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.创建一个新的文件（拷贝文件）</span><br>    <span class="hljs-type">int</span> destfd = open(<span class="hljs-string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(destfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.频繁的读写操作</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = read(srcfd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>) &#123;<br>        write(destfd, buf, len);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.关闭文件</span><br>    close(destfd);<br>    close(srcfd);<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    标准C库的函数</span><br><span class="hljs-comment">    #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">    int fseek(FILE *stream, long offset, int whence);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Linux系统函数，重置文件指针偏移量</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    off_t lseek(int fd, off_t offset, int whence);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span><br><span class="hljs-comment">            - offset：偏移量，偏移量一旦超出了文件的长度，下一次进行文件IO写入操作文件的时候便会延续偏移量的位置继续写入，进而在文件中间产生了空洞的部分，这部分会以”\0”填充，而从原来的文件结尾到新写入数据间的这段空间就被称为“文件空洞”。</span><br><span class="hljs-comment">            - whence:</span><br><span class="hljs-comment">                SEEK_SET</span><br><span class="hljs-comment">                    设置文件指针的偏移量</span><br><span class="hljs-comment">                SEEK_CUR</span><br><span class="hljs-comment">                    设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="hljs-comment">                SEEK_END</span><br><span class="hljs-comment">                    设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="hljs-comment">        返回值：返回当前位置到文件开始位置以字节为单位的偏移量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    作用：</span><br><span class="hljs-comment">        1.移动文件指针到文件头</span><br><span class="hljs-comment">        lseek(fd, 0, SEEK_SET);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        2.获取当前文件指针的位置</span><br><span class="hljs-comment">        lseek(fd, 0, SEEK_CUR);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        3.获取文件长度</span><br><span class="hljs-comment">        lseek(fd, 0, SEEK_END);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">//原始文件内容: hello,world</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;hello.txt&quot;</span>, O_RDWR);<br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 扩展文件的长度</span><br>    <span class="hljs-type">int</span> ret = lseek(fd, <span class="hljs-number">10000000</span>, SEEK_END);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;lseek&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在offset = 10000011处写入一个数据</span><br>    write(fd, <span class="hljs-string">&quot;.&quot;</span>, SEEK_CUR);<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>什么是空洞文件(hole file)？在Linux中，lseek的系统调用是可以改变在文件上面的偏移量的，而且还允许其超出文件的长度。偏移量一旦超出了文件的长度，下一次进行文件IO写入操作文件的时候便会延续偏移量的位置继续写入，进而在文件中间产生了空洞的部分，这部分会以”\0”填充，而从原来的文件结尾到新写入数据间的这段空间就被称为“<strong>文件空洞</strong>”。</p><p>在Linux中，EOF（文件结束符）并不是一个字符，而是在读取到文件末尾的时候返回的一个信号值，也就是-1。</p><p>文件空洞部分实际上是不会占用任何的物理空间的，直到在某个时刻对空洞部分进行写入文件内容的时候才会为它分配对应的空间。但是在空洞文件形成的时候，逻辑上面的文件大小是分配了空洞部分的大小的。</p></blockquote><p>生成元素文件 hello.txt 的拷贝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp hello.txt hello.prev<br></code></pre></td></tr></table></figure><p>编译上述代码后运行。</p><p>使用od命令来查看<code>hello.txt</code>文件的二进制内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">od -c hello.txt<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121756971.png" alt="od -c hello.txt"></p><p>使用ls查看文件的逻辑大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">ls -lh hello.*<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121800438.png" alt="逻辑大小"></p><p>逻辑大小：</p><p>hello.prev: 11 Bytes</p><p>hello.txt: 10000012 Bytes &#x3D; 10000012 &#x2F; 1024 &#x2F; 1024 M &#x3D; 9.6 M</p><p>使用du查看文件实际占用物理块的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -h hello.*<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121800966.png" alt="实际占用物理块"></p><p>文件系统的基本操作单位是数据块，Linux 中的逻辑块大小为 <code>4KB</code>，所以 hello.prev 实际占用的空间为 4k，由于 <code>&quot;hello,world&quot;</code>  和 <code>&quot;.&quot;</code> 在逻辑上不在一个块内，所以 hello.txt 实际占用的空间为 8k，远小于 9.6 M，所以文件空洞部分实际上是不会占用任何的物理空间的。</p><h4 id="stat、lstat"><a href="#stat、lstat" class="headerlink" title="stat、lstat"></a>stat、lstat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int stat(const char *pathname, struct stat *statbuf);</span><br><span class="hljs-comment">        作用：获取一个文件相关的一些信息</span><br><span class="hljs-comment">        参数:</span><br><span class="hljs-comment">            - pathname：操作的文件的路径</span><br><span class="hljs-comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功：返回0</span><br><span class="hljs-comment">            失败：返回-1 设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int lstat(const char *pathname, struct stat *statbuf);</span><br><span class="hljs-comment">        参数:</span><br><span class="hljs-comment">            - pathname：操作的文件的路径</span><br><span class="hljs-comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功：返回0</span><br><span class="hljs-comment">            失败：返回-1 设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>stat</code>和<code>lstat</code>的区别：当文件是一个符号链接时，<code>lstat</code>返回的是该符号链接本身的信息；而<code>stat</code>返回的是该链接指向的文件的信息。</p><p>stat 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-type">dev_t</span>st_dev;<span class="hljs-comment">// 文件的设备编号</span><br>    <span class="hljs-type">ino_t</span>st_ino;<span class="hljs-comment">// 节点</span><br>    <span class="hljs-type">mode_t</span>st_mode;<span class="hljs-comment">// 文件的类型和存取的权限</span><br>    <span class="hljs-type">nlink_t</span>st_nlink;<span class="hljs-comment">// 连到该文件的硬连接数目</span><br>    <span class="hljs-type">uid_t</span>st_uid;<span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-type">gid_t</span> st_gid;<span class="hljs-comment">// 组ID</span><br>    <span class="hljs-type">dev_t</span>st_rdev;<span class="hljs-comment">// 设备文件的设备编号</span><br>    <span class="hljs-type">off_t</span>st_size;      <span class="hljs-comment">// 文件字节数(文件大小)</span><br>    <span class="hljs-type">blksize_t</span>st_blksize;   <span class="hljs-comment">// 最优的 IO 块大小，Linux 为 4096B</span><br>    <span class="hljs-type">blkcnt_t</span>st_blocks;    <span class="hljs-comment">// 块数（以 512B 为单位，而不是 4096B，实际的物理意义应该是磁盘扇区数）</span><br>    <br>    <span class="hljs-type">time_t</span>st_atime;     <span class="hljs-comment">// 最后一次访问时间</span><br>    <span class="hljs-type">time_t</span>st_mtime;     <span class="hljs-comment">// 最后一次修改时间</span><br>    <span class="hljs-type">time_t</span>st_ctime;     <span class="hljs-comment">// 最后一次改变时间(指属性)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用stat命令查看文件的stat结构体（没有lstat命令）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121836144.png" alt="stat 命令"></p><p>hello.txt : Blocks &#x3D; 8K &#x2F; 512B &#x3D; 16</p><p>hello.prev: Blocks &#x3D; 4K &#x2F; 512B &#x3D; 8</p><p>st_mode 变量（16位）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121841823.png" alt="st_mode 变量"></p><h4 id="文件属性的操作函数"><a href="#文件属性的操作函数" class="headerlink" title="文件属性的操作函数"></a>文件属性的操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>; <span class="hljs-comment">// 判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> mode)</span>; <span class="hljs-comment">// 修改文件的权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<span class="hljs-comment">// 修改文件所有者或者所在组</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>; <span class="hljs-comment">// 缩减或者扩展文件的尺寸至指定的大小，不会占用实际的物理内存，多余的部分实际上是一个文件空洞</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int access(const char *pathname, int mode);</span><br><span class="hljs-comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 判断的文件路径</span><br><span class="hljs-comment">            - mode:</span><br><span class="hljs-comment">                R_OK: 判断是否有读权限</span><br><span class="hljs-comment">                W_OK: 判断是否有写权限</span><br><span class="hljs-comment">                X_OK: 判断是否有执行权限</span><br><span class="hljs-comment">                F_OK: 判断文件是否存在</span><br><span class="hljs-comment">        返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    int chmod(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        修改文件的权限</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 需要修改的文件的路径</span><br><span class="hljs-comment">            - mode:需要修改的权限值，八进制的数</span><br><span class="hljs-comment">        返回值：成功返回0，失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    int truncate(const char *path, off_t length);</span><br><span class="hljs-comment">        作用：缩减或者扩展文件的尺寸至指定的大小，不会占用实际的物理内存，多余的部分实际上是一个文件空洞</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - path: 需要修改的文件的路径</span><br><span class="hljs-comment">            - length: 需要最终文件变成的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>lseek 和 truncate 的区别</strong></p><p>lseek 修改的是文件偏移量（读写位置），truncate修改的是文件的文件长度（逻辑大小），如果 lseek 文件偏移量大于文件之后不在该位置进行写入，则无法扩展文件长度（逻辑大小）。</p><p>lseek 和 truncate 产生的文件空洞都不会占用实际物理磁盘空间。</p><p>lseek 不进行写入：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208161819566.png" alt="lseek"></p><p>truncate：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208161820442.png" alt="truncate"></p><h4 id="目录的操作函数"><a href="#目录的操作函数" class="headerlink" title="目录的操作函数"></a>目录的操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    int mkdir(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        作用：创建一个目录</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            pathname: 创建的目录的路径</span><br><span class="hljs-comment">            mode: 权限，八进制的数</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int chdir(const char *path);</span><br><span class="hljs-comment">        作用：修改进程的工作目录</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            path : 需要修改的工作目录</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    char *getcwd(char *buf, size_t size);</span><br><span class="hljs-comment">        作用：获取当前工作目录</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="hljs-comment">            - size: 数组的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            返回的指向的一块内存，这个数据就是第一个参数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="目录的遍历函数"><a href="#目录的遍历函数" class="headerlink" title="目录的遍历函数"></a>目录的遍历函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 此目录进入点的inode</span><br>    <span class="hljs-type">ino_t</span> d_ino; <br>    <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>    <span class="hljs-type">off_t</span> d_off;   <br>    <span class="hljs-comment">// d_name 的长度, 不包含NULL字符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> d_reclen; <br>    <span class="hljs-comment">// d_name 所指的文件类型</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_type;   <br>    <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-type">char</span> d_name[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">d_type</span><br><span class="hljs-comment">    DT_BLK - 块设备</span><br><span class="hljs-comment">    DT_CHR - 字符设备</span><br><span class="hljs-comment">    DT_DIR - 目录</span><br><span class="hljs-comment">    DT_LNK - 软连接</span><br><span class="hljs-comment">    DT_FIFO - 管道</span><br><span class="hljs-comment">    DT_REG - 普通文件</span><br><span class="hljs-comment">    DT_SOCK - 套接字</span><br><span class="hljs-comment">    DT_UNKNOWN - 未知</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 打开一个目录</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;dirent.h&gt;</span><br><span class="hljs-comment">    DIR *opendir(const char *name);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - name: 需要打开的目录的名称</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            DIR * 类型，理解为目录流</span><br><span class="hljs-comment">            错误返回NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 读取目录中的数据</span><br><span class="hljs-comment">    #include &lt;dirent.h&gt;</span><br><span class="hljs-comment">    struct dirent *readdir(DIR *dirp);</span><br><span class="hljs-comment">        - 参数：dirp是opendir返回的结果</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            struct dirent，代表读取到的文件的信息</span><br><span class="hljs-comment">            读取到了末尾或者失败了，返回NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 关闭目录</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;dirent.h&gt;</span><br><span class="hljs-comment">    int closedir(DIR *dirp);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>读取某个目录下所有的普通文件的个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// #define __USE_MISC </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span>;<br><br><span class="hljs-comment">// 读取某个目录下所有的普通文件的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s path\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> num = getFileNum(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;普通文件的个数为：%d\n&quot;</span>, num);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 用于获取目录下所有普通文件的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开目录</span><br>    DIR * dir = opendir(path);<br><br>    <span class="hljs-keyword">if</span>(dir == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;opendir&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> *<span class="hljs-title">ptr</span>;</span><br><br>    <span class="hljs-comment">// 记录普通文件的个数</span><br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>((ptr = readdir(dir)) != <span class="hljs-literal">NULL</span>) &#123;<br><br>        <span class="hljs-comment">// 获取名称</span><br>        <span class="hljs-type">char</span> * dname = ptr-&gt;d_name;<br><br>        <span class="hljs-comment">// 忽略掉. 和..</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dname, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dname, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断是否是普通文件还是目录</span><br>        <span class="hljs-keyword">if</span>(ptr-&gt;d_type == DT_DIR) &#123;<br>            <span class="hljs-comment">// 目录,需要继续读取这个目录</span><br>            <span class="hljs-type">char</span> newpath[<span class="hljs-number">256</span>];<br>            <span class="hljs-built_in">sprintf</span>(newpath, <span class="hljs-string">&quot;%s/%s&quot;</span>, path, dname);<br>            total += getFileNum(newpath);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;<br>            <span class="hljs-comment">// 普通文件</span><br>            total++;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 关闭目录</span><br>    closedir(dir);<br><br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dup、dup2"><a href="#dup、dup2" class="headerlink" title="dup、dup2"></a>dup、dup2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<span class="hljs-comment">// 复制文件描述符，返回最小的未使用的文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<span class="hljs-comment">// 重定向文件描述符</span><br></code></pre></td></tr></table></figure><p>dup 函数示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int dup(int oldfd);</span><br><span class="hljs-comment">        作用：复制一个新的文件描述符</span><br><span class="hljs-comment">        fd=3, int fd1 = dup(fd),</span><br><span class="hljs-comment">        fd指向的是a.txt, fd1也是指向a.txt</span><br><span class="hljs-comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br><br>    <span class="hljs-type">int</span> fd1 = dup(fd); <span class="hljs-comment">// 关闭文件描述符</span><br><br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;dup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);<br><br>    close(fd);<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">// 通过 fd1 向文件中写入 &quot;hello,world&quot;</span><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dup2 函数示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int dup2(int oldfd, int newfd);</span><br><span class="hljs-comment">        作用：重定向文件描述符, 复制文件描述符并指定新的文件描述符为 newfd</span><br><span class="hljs-comment">        调用函数成功后 oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="hljs-comment">        如果 newfd 本身和 b.txt 关联，则在复制文件描述符前关闭文件描述符 newfd，使其不再指向 b.txt，然后将其重新指向a.txt</span><br><span class="hljs-comment">        oldfd 必须是一个有效的文件描述符</span><br><span class="hljs-comment">        oldfd 和 newfd值相同，相当于什么都没有做</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);<br><br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;dup2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello, dup2&quot;</span>;<br>    <span class="hljs-type">int</span> len = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);<br><br>    close(fd);<br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;<br><span class="hljs-comment">// 使用 cmd 操作文件文件描述符，如复制文件描述符、设置/获取文件的状态标志等</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    #include &lt;fcntl.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int fcntl(int fd, int cmd, ...);</span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        fd : 表示需要操作的文件描述符</span><br><span class="hljs-comment">        cmd: 表示对文件描述符进行如何操作</span><br><span class="hljs-comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="hljs-comment">                int ret = fcntl(fd, F_DUPFD);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="hljs-comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="hljs-comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="hljs-comment">              可选性：O_APPEND, O)NONBLOCK</span><br><span class="hljs-comment">                O_APPEND 表示追加数据</span><br><span class="hljs-comment">                NONBLOK 设置成非阻塞</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        阻塞和非阻塞：描述的是函数调用的行为。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2.修改或者获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件描述符状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    flag |= O_APPEND;   <span class="hljs-comment">// flag = flag | O_APPEND</span><br><br>    <span class="hljs-comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 升级 gcc-11</title>
    <link href="/posts/334154d9/"/>
    <url>/posts/334154d9/</url>
    
    <content type="html"><![CDATA[<h2 id="ubuntu-更新-gcc、-g-："><a href="#ubuntu-更新-gcc、-g-：" class="headerlink" title="ubuntu 更新 gcc、 g++："></a>ubuntu 更新 gcc、 g++：</h2><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install build-essential manpages-dev software-properties-common<br>sudo add-apt-repository ppa:ubuntu-toolchain-r/test<br>sudo add-apt-repository &#x27;deb http://mirrors.kernel.org/ubuntu hirsute main universe&#x27;<br>sudo apt update &amp;&amp; sudo apt install gcc-11 g++-11<br></code></pre></td></tr></table></figure><p>多版本管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 50 --slave /usr/bin/g++ g++ /usr/bin/g++-11<br><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 10 --slave /usr/bin/g++ g++ /usr/bin/g++-9<br><br></code></pre></td></tr></table></figure><p>设置默认gcc版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --config gcc<br></code></pre></td></tr></table></figure><h2 id="更新gdb-11"><a href="#更新gdb-11" class="headerlink" title="更新gdb-11"></a>更新gdb-11</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install libgmp-dev<br>wget http://ftp.gnu.org/gnu/gdb/gdb-11.1.tar.gz<br>tar -xvzf gdb-11.1.tar.gz<br>./configure<br>sudo make &amp;&amp; sudo make install<br></code></pre></td></tr></table></figure><p>可能要安装textinfo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install texinfo<br></code></pre></td></tr></table></figure><p>替换老版本，新生成的gdb二进制文件会在编译目录gdb-10.2&#x2F;gdb&#x2F;gdb ，将其拷贝到&#x2F;usr&#x2F;bin&#x2F;，替换原来的，也可以将原来的做个备份，以防出问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /usr/local/bin/gdb /usr/local/bin/gdb_bak<br>cp ~/gdb-11.1/gdb/gdb /usr/local/bin/<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>mysql 8 修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/posts/f89cb603/"/>
    <url>/posts/f89cb603/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h1><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><p>二叉搜索树（BST）具备以下特性（规则）：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉搜索树。</li></ol><p>在BST中最大比较次数为树的高度，树的高度范围为 $[log(n), n]$。 </p><p>当树中每个结点左、右子树高度大致相同时，树高为 $\text{log}(n)$ ，则平均查找长度与 $\text{log}(n)$ 成正比，查找的平均时间复杂度在 $O(\text{log}n)$ 数量级上。</p><p>当树形结构为一个单子树时，此时树高 $n$ ，则平均查找长度为 $(n+1)&#x2F;2$ ，查找的平均时间复杂度在 $O(n)$ 数量级上。</p><p>相同序列构成的不同二叉搜索树：<a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树 - 力扣（LeetCode）</a></p><h2 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h2><p>平衡二叉查找树的出现，主要是为了解决<strong>当二叉树查找树形态结构变成一个链条结构的时候，查找效率变低的问题</strong>，算法由<code>Adel&#39;son-Vel&#39;skii</code>和<code>Landis</code>发明，同时也称<code>AVL</code>树，特性（规则）如下：</p><ol><li><p>它的左子树和右子树都是平衡二叉树；</p></li><li><p>且它的左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。</p></li></ol><p>AVL是严格平衡的BST（平衡因子不超过1）。查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是 $O(\text{log}n)$ 。</p><p>$$<br>balance\  factor &#x3D; height\ of\ left\ subtree - height\ of\ right\ subtree \<br>bf &#x3D; {-1, 0, 1} \<br>|bf| &#x3D; |hl - hr| \le 1 \<br>$$</p><p>AVL 的旋转：</p><ol><li>LL-imbalance：由于在左子树的左子树插入或删除而导致的不平衡，进行LL-Rotation；</li><li>LR-imbalance：由于在左子树的右子树插入或删除而导致的不平衡，进行LR-Rotation；</li><li>RR-imbalance：由于在右子树的右子树插入或删除而导致的不平衡，进行RR-Rotation；</li><li>RL-imbalance：由于在右子树的左子树插入或删除而导致的不平衡，进行RL-Rotation。</li></ol><p>在插入、删除树节点的时候，<strong>AVL树会自动进行调整</strong>。也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。AVL在每次插入节点时对树进行检查和调整，AVL的旋转每次只涉及以imbalance节点为根节点的3个节点（如下图）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031408586.png" alt="AVL树的旋转-插入42"></p><p>以 LL-Rotation 和 LR-Rotation 为例（假设图中节点A为第一个 $|bf| \neq 1$ 的节点）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031412866.png" alt="LL-Rotation"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031413467.png" alt="LR-Rotation"></p><p>给定节点数为 $n$ 的AVL树，最大高度为 $\text{log}(2n)$ ，而不是 $n$。</p><p>平衡二叉搜索树解决二叉搜索树的问题，保证了不会成为线性的链表。<br>左结点小于根节点，右结点大于根节点，并且还规定了左子树和右子树的高度差不得超过1。</p><p>但其仍然存在问题：</p><ol><li>由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。</li><li>每一个节点只能存放一个元素，每个节点只有两个子节点，所以查找时，需要多次磁盘IO（如果数据存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页。）</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>视频：<a href="https://www.youtube.com/watch?v=aZjYr87r1b8">10.2 B Trees and B+ Trees. How they are useful in Databases - YouTube</a></p><p>B 树的基本思想：多级索引</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031643643.png" alt="多级索引"></p><p>一个m阶的B树的规则：</p><ol><li>根结点至少有两个子树（1个索引）；</li><li>每个中间节点都包含 $k-1$ 个元素和 $k$ 个孩子，其中 $m&#x2F;2 \le k \le m$  ；</li><li>每一个叶子节点都包含 $k-1$ 个元素，其中 $m&#x2F;2 \le k \le m$  ；</li><li>所有的叶子结点都位于同一层；</li><li>每个节点中的元素从小到大排列，节点当中 $k-1$ 个元素正好是 $k$ 个孩子包含的元素的值域分划。</li></ol><p>4阶B树，例子：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031545671.png" alt="B树的构建"></p><h2 id="2-3-4-树"><a href="#2-3-4-树" class="headerlink" title="2-3-4 树"></a>2-3-4 树</h2><p>2-3-4 树 是 四阶 B树，它是一种多路查找树，其结构有以下限制：</p><ol><li>所有叶子节点具有相同的深度；</li><li>节点只能是2-节点、3-节点和4-节点之一：<ul><li>2-节点：包含1个元素的节点，有2个子树；</li><li>3-节点：包含2个元素的节点，有3个子树；</li><li>4-节点：包含3个元素的节点，有4个子树。</li></ul></li><li>所有节点必须至少包含一个元素；</li><li>元素始终保持排序顺序 ，整体上保持二叉搜索树的性质，即父节点的值大于左子树所有节点，小于右子树所有节点；</li><li>节点有多个元素时，每个元素必须大于它左边的和左子树中的元素。</li></ol><p>例：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031651195.png" alt="2-3-4树"></p><p>2-3-4树的实现在一些编程语言中较为困难，一般使用其等同的红黑树。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>视频：<a href="https://www.bilibili.com/video/BV1j44y1q7k8?p=1&vd_source=88ba307806f3a95297a7d08a098d6a4b">【完整版】最全最新红黑树讲解，数组、链表、二叉树、AVL树、红黑树哔哩哔哩_bilibili</a></p><h2 id="2-3-4-树和红黑树的等价关系"><a href="#2-3-4-树和红黑树的等价关系" class="headerlink" title="2-3-4 树和红黑树的等价关系"></a>2-3-4 树和红黑树的等价关系</h2><p>2-3-4 树和红黑树的等价关系：</p><ol><li>2-节点对应RB-Tree黑节点；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712340.png" alt="2-节点"></p><ol start="2"><li>3-节点对应RB-Tree上黑下红（分为左倾和右倾两种）；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712317.png" alt="3-节点"></p><ol start="3"><li>4-节点对应RB-Tree上黑下红。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031713313.png" alt="4-节点"></p><p>2-3-4 树到红黑树的转换：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031756841.png" alt="2-3-4 树到红黑树（左倾）"></p><p>平衡二叉查找树通过严格平衡策略，以牺牲建立查找结构的代价换来了稳定的查找时间复杂度。但是相对来说，在删除方面，时间复杂度稍大。而红黑树不严格控制左、右子树高度或节点数之差小于等于1。</p><h2 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h2><p>红黑树是自平衡（不严格限制）的二叉搜索树， <strong>红黑树的5条规则：</strong></p><ol><li>节点要么是黑色要么是红色；</li><li>根节点是黑色；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>每个红色节点的两个子节点都是黑色（也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点）；</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍，因而，红黑树是相对的接近平衡的二叉树，但是相比平衡二叉树而言，尤其是删除的时间复杂度，有所降低）。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031616562.png" alt="红黑树"></p><p><strong>分析：</strong></p><ol><li>第2条特性：从 2-3-4 树到红黑树的转换中，根节点要么是2-节点（黑色），要么是3-节点或4-节点分裂出的（上黑）；</li><li>第5条特性：从 2-3-4 树到红黑树的转换中，可以看出2-3-4 树的每个节点中有且仅有一个黑色元素，由于B树中所有的叶子结点都位于同一层，所以从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（2-3-4树的高度+1）。</li></ol><p>红黑树在查找方面和AVL树操作几乎相同。牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。任何不平衡都会在三次旋转之内解决。<br>确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证 $O(\text{log}n)$ 。</p><p>红黑树的通过旋转和染色来自平衡。</p><h2 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h2><p>红黑树的查找与二叉树搜索树的查找一样。</p><h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/166319823">红黑树的原理 (插入+ 删除) 案例分析 - 知乎 (zhihu.com)</a></p><p>向红黑树中插入新的结点。具体做法是：</p><ol><li>将新结点的 color 赋为红色，然后以二叉排序树的插入方法插入到红黑树中去。之所以将新插入的结点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。</li><li>通过颜色调换和树旋转来调整可能会出现两个连续红色节点的冲突。</li></ol><p>插入不同的情况：</p><ol><li>插入根节点；</li><li>插入节点的父节点为黑色；</li><li>插入节点的父节点为红色，叔节点也为红色；</li><li>插入节点的父节点是红色，叔节点是黑色：<ol><li>左左插入</li><li>左右插入</li><li>右右插入</li><li>右左插入</li></ol></li></ol><p>具体操作：</p><ol><li><p>插入根结点：直接染黑。</p></li><li><p>插入节点的父节点为黑色，没有出现两个连续红色节点的冲突，不需要调整。</p></li><li><p>插入节点的父节点为红色，叔节点也为红色，不需要旋转，直接染色，注意递归向上调整。</p><p>分析：插入N之前，N所在的位置必为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点必为 NIL</strong>。插入新节点之后树仍是平衡的，所以不需要旋转。</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032144818.png" alt="case 3"></p><ol start="4"><li><p>插入节点的父节点是红色，叔节点是黑色:</p><ol><li><p>左左插入，左旋</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LL-imbalance，需要进行LL-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032202879.png" alt="case 4-1"></p></li><li><p>左右插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LR-imbalance，需要进行LR-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032207490.png" alt="case4-2"></p></li><li><p>右右插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RR-imbalance，需要进行RR-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032213353.png" alt="case4-3"></p></li><li><p>右左插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RL-imbalance，需要进行RL-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032318044.png" alt="case4-4"></p></li></ol></li></ol><p>总结：根据平衡二叉树正常插入节点之后根据平衡判断是否需要旋转，若不需要旋转，则将 <code>Parent</code> 和 <code>Uncle</code> 染黑，<code>GrandParent</code> 染红，再递归向上调整；若不平衡，则根据情况进行旋转，旋转之后上黑（新的 <code>GrandParent</code> ）下红染色。</p><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p>参考：<a href="https://www.bilibili.com/video/BV1KA41187v6?vd_source=88ba307806f3a95297a7d08a098d6a4b">红黑树删除_bilibili</a></p><p>删除不同的情况：</p><ol><li>删除叶节点，且叶节点为红色，无需调整；</li><li>删除叶节点，叶节点为黑色，需要调整；</li><li>删除节点非叶节点，若该节点只有一个子节点，则用该子节点替代删除节点；若该节点有两个子节点，则将要删除的节点与其前驱或者后继节点进行替代。此时情况变为1或2（根据实际被删除的节点的颜色决定）。</li></ol><p>情况2若删除后不平衡则需要根据AVL旋转规则旋转后染色，否则直接染色。</p><p>如果不旋转，则将兄弟节点设置为红色，将父节点设置为当前节点递归，直到根节点，或遇到红色节点；如果旋转，则旋转之后 <code>Parent</code> 位置的颜色不变，其他位置根据黑色节点个数进行调整。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/posts/735e5788/"/>
    <url>/posts/735e5788/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022027979.png" alt="概览"></p><p>排序算法主要可根据 <strong>稳定性</strong> 、<strong>就地性</strong> 、<strong>自适应性</strong> 分类。理想的排序算法具有以下特性：</p><ul><li>具有稳定性，即相等元素的相对位置不变化；</li><li>具有就地性，即不使用额外的辅助空间；</li><li>具有自适应性，即时间复杂度受元素分布影响。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>算法步骤：</strong></p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022027854.gif" alt="冒泡排序"></p><p>冒泡排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort1</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort2</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-type">bool</span> swapped = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><br><span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果上一轮没有发生交换，则说明已经有序</span><br><br>swapped = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>swapped = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>算法步骤</strong><br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028501.gif" alt="选择排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-type">int</span> minIdx = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[minIdx] &gt; arr[j]) &#123;<br>minIdx = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>算法步骤：</strong><br>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028731.gif" alt="插入排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> key = arr[i];<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key)<br>&#123;<br>arr[j + <span class="hljs-number">1</span>] = arr[j--];<br>&#125;<br>arr[j + <span class="hljs-number">1</span>] = key;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p><strong>算法步骤：</strong><br>选择一个增量序列 <code>t1, t2, ..., tk</code>，其中 <code>ti &gt; tj, tk = 1</code>；<br>按增量序列个数 <code>k</code>，对序列进行 <code>k</code> 趟排序；<br>每趟排序，根据对应的增量 <code>ti</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028025.gif" alt="希尔排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 希尔排序，优化版的插入排序</span><br><span class="hljs-comment">// 每次组内排序必须用插入排序或者冒泡排序（优化过的），插入排序和冒泡排序对“基本有序”的序列排序接近O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> gap = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n = array.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (gap &lt; n / <span class="hljs-number">3</span>) <span class="hljs-comment">// 确定分组间隔</span><br>    &#123;<br>        gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (gap &gt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> key = array[i];<br>            <span class="hljs-type">int</span> j = i - gap;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; key &lt; array[j])<br>            &#123;<br>                array[j + gap] = array[j];<br>                j -= gap;<br>            &#125;<br>            array[j + gap] = key;<br>        &#125;<br>        gap = gap / <span class="hljs-number">3</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022029938.gif" alt="归并排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> left ,<span class="hljs-type">int</span> right)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(left &gt;= right)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 划分</span><br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(vec, left, mid);     <span class="hljs-comment">// [l,mid] 有序</span><br>    <span class="hljs-built_in">mergeSort</span>(vec, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// [mid+1,r] 有序</span><br><br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(vec.begin()+left, vec.begin()+right + <span class="hljs-number">1</span>)</span></span>; <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = left; k &lt;= right; ++k)&#123;<br>        <span class="hljs-keyword">if</span>(left + i &gt; mid) &#123;<br>            vec[k] = tmp[j++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left + j &gt; right || tmp[i] &lt;= tmp[j]) <span class="hljs-comment">// &lt;= 稳定</span><br>        &#123;<br>            vec[k] = tmp[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vec[k] = tmp[j++];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022029722.gif" alt="快速排序"></p><p>算法步骤：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partitionVec</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 以 vec[l] 作为基准</span><br>    <span class="hljs-type">int</span> i = l;<br>    <span class="hljs-type">int</span> j = r;<br><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; vec[j] &gt;= vec[l])<br>            --j;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; vec[i] &lt;= vec[l])<br>            ++i;<br>        <span class="hljs-built_in">swap</span>(vec[i], vec[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">swap</span>(vec[l], vec[i]);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 子数组的长度为 1 时终止递归</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 哨兵划分</span><br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partitionVec</span>(vec, l, r);<br><br>    <span class="hljs-comment">// 左右数组递归</span><br>    <span class="hljs-built_in">quickSort</span>(vec, l, pos - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quickSort</span>(vec, pos + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用<strong>堆</strong>这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于<strong>升序排列</strong>（递增数组）；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于<strong>降序排列</strong>（递减数组）。</li></ol><p>堆排序的平均时间复杂度为 $O(n\text{log}n)$。</p><p>算法步骤：</p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022107615.gif" alt="堆排序演示"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022108887.gif" alt="堆排序"></p><p>一般用数组存储堆结构：</p><p>下标为 $i$ 的节点的父节点下标为 $(i-1)&#x2F;2$ ；</p><p>下标为 $i$ 的节点的左子节点下标为 $i \times 2 + 1$ ；</p><p>下标为 $i$ 的节点的右子节点下标为 $i \times 2 + 2$ 。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> parent = start;<br>    <span class="hljs-type">int</span> child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子节点下标</span><br><br>    <span class="hljs-keyword">while</span> (child &lt;= end)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(child + <span class="hljs-number">1</span> &lt;= end &amp;&amp; vec[child] &lt; vec[child + <span class="hljs-number">1</span>])<br>            ++child;<br><br>        <span class="hljs-keyword">if</span> (vec[parent] &gt; vec[child]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">swap</span>(vec[parent], vec[child]);<br>            parent = child;<br>            child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = vec.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">max_heapify</span>(vec, i, len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化堆，从最后一个根结点开始调整</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">swap</span>(vec[<span class="hljs-number">0</span>], vec[i]); <span class="hljs-comment">// 将跟节点（最大元素）与最后一个元素交换</span><br>        <span class="hljs-built_in">max_heapify</span>(vec, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 将堆的尺寸缩小 1，再进行调整</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题笔记</title>
    <link href="/posts/9813b472/"/>
    <url>/posts/9813b472/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>题目列表：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>          </div><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><p>常用算法</p><ul><li>二分</li><li>双指针</li><li>滑动窗口</li><li>模拟</li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><table><thead><tr><th>暴力</th><th>$O(n)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(\text{log}n)$</td></tr></tbody></table><p>二分的前提是数组是有序的，二分法每次能排除一半的元素，时间复杂度为 $O(\text{log}n)$。<br>使用二分法是要注意解是否包含在左右边界中，在循环中，区间的定义不能改变（区间的开闭）。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><table><thead><tr><th>暴力</th><th>$O(n^2)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(n)$</td></tr></tbody></table><ul><li>快慢指针（追击）</li><li>相向指针（相遇）</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><table><thead><tr><th>暴力</th><th>$O(n^2)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(n)$</td></tr></tbody></table><p>理解滑动窗口如何移动、窗口起始位置、如何更新窗口大小。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>注意状态更新和数组越界。</p><h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>常用技巧：虚拟头结点</p><p>常见题型：</p><ol><li>反转链表<ol><li>迭代</li><li>递归</li></ol></li><li>删除倒数第 $n$个节点、<ol><li>快慢指针</li></ol></li><li>链表相交<ol><li>双指针</li><li>哈希表</li></ol></li><li>环形链表<ol><li>快慢指针</li><li>哈希表</li></ol></li></ol><p>注意nullptr。</p><h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><ol><li>不同的数据通过哈希函数映射到统一索引的现象叫<strong>哈希碰撞</strong>，一般的解决方法有<ol><li>拉链法</li><li>线性探测法</li></ol></li><li>哈希法解决问题一般选择的数据结构：<ol><li>数组</li><li>set</li><li>map</li></ol></li></ol><table><thead><tr><th><strong>集合</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><table><thead><tr><th><strong>映射</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><ol><li>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</li></ol><h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>双指针</p><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>模拟</p><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>空间复杂度$O(1)$解法：<br>首先扩充数组到每个空格替换成”%20”之后的大小。然后从后向前替换空格，也就是双指针法。</p><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p>空间复杂度$O(1)$解法：</p><ol><li>移除多余空格（快慢指针）</li><li>将整个字符串反转</li><li>将每个单词反转</li></ol><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>空间复杂度$O(1)$解法：</p><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><p>重要<strong>Knuth-Morris-Pratt (KMP) 字符串查找算法</strong><br>暴力算法：$O(m\times n)$<br>KMP算法：$O(m+n)$</p><ol><li><strong>主要思想：</strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li><strong>前缀表：</strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。<br>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪个位置开始重新匹配。</li><li>**最长公共前后缀<br>**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。<br>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。<br><code>aabaa</code>的最长 ~~公共 ~~相同 前后缀为 <code>aa</code>，长度为2。</li><li>模式串与前缀表对应位置的数字表示的是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022020803.png" alt="字符串匹配"></p><p>当<code>s[i]</code>不匹配时，应该回退到前缀表 <code>next[i-1]</code>中记录的下标位继续匹配。</p><ol><li>构造next数组<br>构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：<ol><li>初始化</li><li>处理前后缀不相同的情况：回退</li><li>处理前后缀相同的情况：匹配长度+1</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// j 指向前缀末尾位置(前缀长度)</span><br>    next[<span class="hljs-number">0</span>] = j; <span class="hljs-comment">// next[i] 表示 i(包括i)之前最长相等的前后缀长度（其实就是j）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// i 指向后缀末尾位置，注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        &#125;<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何回退？</strong>举例子:</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022021543.png" alt="KMP回退"></p><p><code>B</code>和<code>C</code>不匹配，发生回退，要找到与后缀 <code>ABA</code>相同部分最长的前缀，其实等同于找到找到左边部分的最长相等前缀，即为<code>n[j-1]</code>。</p><ol><li>使用前缀表进行匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// // 因为next数组里记录的起始位置为-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i就从0开始</span><br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 不匹配</span><br>            j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>            j++; <span class="hljs-comment">// i的增加在for循环里</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == (needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) &#123; <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>            <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>思路：构建<code>next</code>数组，<strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>双指针</li></ol><ul><li>反转字符串</li><li>替换空格，先给数组扩容再从后向前操作</li><li>移除元素，快慢指针</li></ul><p>erase是$O(n)$的操作，放在<code>for</code>循环里会导致 $O(n^2)$的复杂度。</p><ol start="2"><li>反转</li><li>KMP：字符串匹配问题</li></ol><h1 id="五、双指针"><a href="#五、双指针" class="headerlink" title="五、双指针"></a>五、双指针</h1><ol><li>数组<br>移除元素，通过两个指针在一个for循环内完成两个for循环的工作</li><li>字符串<ol><li>反转</li><li>扩充</li><li>移除</li></ol></li><li>链表<ol><li>快慢指针</li></ol></li><li>N数之和<ol><li>排序 + 双指针 + <strong>剪枝（注意剪枝条件）</strong></li></ol></li></ol><h1 id="六、栈和队列"><a href="#六、栈和队列" class="headerlink" title="六、栈和队列"></a>六、栈和队列</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><ol><li><p>C++标准库是有多个版本的，以下为三个最为普遍的STL版本：</p><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol></li><li><p>栈是以底层容器完成其所有的工作，<strong>对外提供统一的接口</strong>，底层容器是可插拔的（也就是说我们可以控制<strong>使用哪种容器</strong>来实现栈的功能）。所以STL中栈往往<strong>不被归类为容器</strong>，而被归类为container adapter（容器适配器）。我们常用的SGI STL，如果没有指定底层实现的话，默认是<strong>以deque为缺省</strong>情况下栈的低层结构。也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></table></figure></li><li><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，SGI STL中队列一样是以deque为缺省情况下的底部结构。所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p></li></ol><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">力扣题目链接</a><br>stkIn：队尾元素<br>stkOut：队首元素</p><ol><li>push() ：直接压入stkIn。</li><li>pop() ：先peek()，再stkOut.pop()。</li><li>peek()：若stkB不为空，直接返回stkOut.top()；否则将stkIn的元素全部压入stkOut中，再返回stkOut.top()。</li><li>empty() ：若stkIn与stkOut均为空则为空。</li></ol><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>deque实现单调栈。</p><h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p>priority_queue 容器适配器定义了一个元素有序排列的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。但是如何定义“优先级”完全取决于我们自己。<br>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Container=std::vector&lt;T&gt;, <span class="hljs-keyword">typename</span> Compare=std::less&lt;T&gt;&gt; <span class="hljs-keyword">class</span> priority_queue;<br><span class="hljs-comment">// less&lt;T&gt; 大顶堆 </span><br><span class="hljs-comment">// greater&lt;T&gt; 小顶堆</span><br></code></pre></td></tr></table></figure><p>priority_queue 实例默认有一个 vector 容器。函数对象类型 less<T> 是一个默认的<strong>排序断言</strong>，定义在头文件 functional中，决定了容器中最大的元素会排在队列前面。functional中定义了  greater<T>，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，<strong>如果指定模板的最后一个参数，就必须提供另外的两个模板类型参数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m.second &gt; n.second; <span class="hljs-comment">// 小顶堆</span><br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; occurrences;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : nums) &#123;<br>            occurrences[v]++;<br>        &#125;<br><br>        <span class="hljs-comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(&amp;cmp)&gt; <span class="hljs-built_in">q</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [num, count] : occurrences) &#123;<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() == k) &#123;<br>                <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">top</span>().second &lt; count) &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">emplace</span>(num, count);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                q.<span class="hljs-built_in">emplace</span>(num, count);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ret.<span class="hljs-built_in">emplace_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>提问：</p><ol><li>C++中stack，queue 是容器么？</li><li>我们使用的stack，queue是属于那个版本的STL？</li><li>我们使用的STL中stack，queue是如何实现的？</li><li>stack，queue 提供迭代器来遍历空间么？</li></ol><p>栈里面的元素在内存中是连续分布的么？</p><ul><li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。</li><li>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，</li></ul><h1 id="七、二叉树"><a href="#七、二叉树" class="headerlink" title="七、二叉树"></a>七、二叉树</h1><h2 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h2><p><strong>一、二叉树的种类</strong></p><ol><li>满二叉树<ol><li>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</li><li>每层的节点数为$2^{k-1}$。</li><li>深度为$k$的满二叉树节点个数为$2^0+2^1+ \cdots + 2^{k-1} &#x3D; 2^k -1$。</li></ol></li><li>完全二叉树<ol><li>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</li><li>若最底层为第 h 层，则该层包含 $[1,2^{h-1}]$  个节点。</li></ol></li><li>二叉搜索树<br>二叉搜索树是一个有序树：<ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ol></li><li>平衡搜索二叉树<ol><li>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：<ol><li>它是一棵空树或它的<strong>左右两个子树的高度差的绝对值不超过1。</strong></li><li>左右两个子树都是一棵平衡二叉树。</li></ol></li><li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（具体来说是红黑树）</strong>，所以map、set的增删操作时间时间复杂度是$logn(0)$。unordered_map、unordered_set，unordered_map、unordered_map底层实现是<strong>哈希表</strong>。</li></ol></li></ol><p><strong>二、二叉树的存储方式</strong></p><ol><li>链式存储（指针）</li><li>顺序存储（数组）<ol><li>对于完全二叉树，如果父节点的数组下标是 $i$，那么它的左孩子就是 $2i+1$，右孩子就是 $2i+2$。</li></ol></li></ol><p><strong>三、二叉树的遍历方式</strong></p><ol><li>深度优先（前中后指<strong>中间节点的遍历顺序</strong>）<ol><li>前序遍历（迭代、递归）</li><li>中序遍历（迭代、递归）</li><li>后续遍历（迭代、递归）</li></ol></li><li>广度优先<ol><li>层次遍历（迭代）</li></ol></li></ol><p><strong>DFS两种实现</strong></p><ol><li>递归三要素：<ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol></li><li>迭代：<ol><li>前序：处理顺序与访问顺序一致<ol><li>先处理根结点</li><li>right入栈、left入栈<strong>（空节点不入栈，出栈顺序中左右）</strong></li></ol></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(root);<br><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>中序：处理顺序与访问顺序不一致</p><ol><li>根结点入栈、left（不为空）入栈</li><li>弹栈访问数据</li><li>right（不为空）入栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode* cur = root;<br><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>后序：处理顺序与访问顺序一致</p><ol><li>right入栈、left入栈<strong>（空节点不入栈，出栈顺序左右中）</strong></li><li>弹栈访问数据</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>    stk.<span class="hljs-built_in">emplace</span>(root);<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;right);<br>    &#125; <br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BFS实现：</strong><br>队列</p><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>比较<code>leftNode-&gt;left</code>与<code>rightNode-&gt;right</code>、<code>leftNode-&gt;right</code>与<code>rightNode-&gt;left</code>。</p><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><blockquote><p>类似题目：剑指 Offer 07. 重建二叉树</p></blockquote><p>后序遍历的顺序为：左右中<br>后序遍历<code>postorder</code>的最后一个元素为当前根节点<code>root</code>，在中序遍历搜索<code>root</code>的索引，可将中序遍历<code>inorder</code>划分为<code>[leftTree | root | rightTree]</code>，随即可求出<code>leftTree</code>和<code>rightTree</code>的长度，根据子树长度可将后序遍历划分为<code>leftTree | rightTree | root</code>。由于构建二叉树时确定的是<code>postorder</code>中的<code>root</code>位置和子树长度，所以右子树的根节点为<code>root-1</code>，左子树的根节点为<code>root - 1 - rightLen</code>。<br>递归构建二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-comment">// inorder 根结点左侧为左子树，右侧为右子树</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>            dict[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bulid</span>(inorder, postorder, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">bulid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[i]);<br>        <span class="hljs-type">int</span> rootIdx = dict[postorder[i]];  <br>        root-&gt;left = <span class="hljs-built_in">bulid</span>(inorder, postorder, i - <span class="hljs-number">1</span> - (r - rootIdx), l, rootIdx - <span class="hljs-number">1</span>); <span class="hljs-comment">// (r - rootIdx) 为右子树长度</span><br>        root-&gt;right = <span class="hljs-built_in">bulid</span>(inorder, postorder, i - <span class="hljs-number">1</span>, rootIdx + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同理，前序遍历是构建二叉树时确定的是<code>preorder</code>中的<code>root</code>位置和子树长度，所以左子树的根节点为<code>root+1</code>，左子树的根节点为<code>root + 1 + leftLen</code>。</p><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><ol><li>二叉树的理论基础<ol><li>二叉树的种类</li><li>存储方式：链式、顺序</li><li>遍历方式</li><li>定义方式</li></ol></li><li>二叉树的遍历方式<ol><li>深度（递归、迭代）</li><li>广度（队列）</li></ol></li><li>求二叉树的属性<ol><li>是否对称</li><li>深度</li><li>节点数</li><li>平衡（优先递归，迭代效率低）</li><li>路径（回溯）</li><li>左下角的值</li></ol></li><li>二叉树的修改与构造<ol><li>翻转</li><li>构造（优先递归）</li><li>合并</li></ol></li><li>求二叉搜索树的属性<ol><li>中序遍历，有序数组</li></ol></li><li>二叉树公共祖先问题<ol><li>优先递归</li><li>搜索树可以迭代</li></ol></li></ol><h1 id="八、回溯算法"><a href="#八、回溯算法" class="headerlink" title="八、回溯算法"></a>八、回溯算法</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ol><li>回溯的效率<br>回溯法并不是什么高效的算法。因为回溯的<strong>本质是穷举</strong>，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些<strong>剪枝</strong>的操作，但也改不了回溯法就是穷举的本质。</li><li>回溯解决的问题<ol><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ol></li><li>理解回溯<br>回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度构成的树的深度</strong>。</li><li>回溯模板<br>回溯三部曲：<ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022022275.png" alt="回溯"></p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>递归的返回值<ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 </li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</li></ul></li></ol><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p>方法一：回溯</p><ol><li>记录映射关系（字典序排序）</li><li>回溯<ol><li>终止条件</li><li>避免死循环</li><li>遇到符合条件的路径及时返回</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ticketNum = tickets.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(ticketNum == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> tickets[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(vector&lt;string&gt; t : tickets) &#123;<br>            targets[t[<span class="hljs-number">0</span>]][t[<span class="hljs-number">1</span>]] ++;<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-built_in">recur</span>(<span class="hljs-string">&quot;JFK&quot;</span>, ticketNum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    unordered_map&lt;string, map&lt;string,<span class="hljs-type">int</span>&gt;&gt; targets;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; from, <span class="hljs-type">int</span> ticketNum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; to : targets[from]) &#123; <span class="hljs-comment">// 必须是引用</span><br>            <span class="hljs-keyword">if</span>(to.second &gt; <span class="hljs-number">0</span>) &#123;<br>                -- to.second;<br>                res.<span class="hljs-built_in">emplace_back</span>(to.first);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">recur</span>(to.first, ticketNum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                ++ to.second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：<strong>Hierholzer 算法</strong><br>化简题意：给定一个 $n$个点 $m$ 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。<br>这种「一笔画」问题与<strong>欧拉图</strong>或者<strong>半欧拉图</strong>有着紧密的联系，下面给出定义：</p><ul><li>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路；</li><li>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路；</li><li>具有欧拉回路的无向图称为欧拉图；</li><li>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</li></ul><blockquote><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><ul><li>对于无向图 $G$，$G$ 是欧拉图当且仅当 $G$是连通的且没有奇度顶点。</li><li>对于无向图 $G$，$G$是半欧拉图当且仅当 $G$是连通的且 $G$中恰有 $0$个或 $2$ 个奇度顶点。</li><li>对于有向图 $G$，$G$ 是欧拉图当且仅当 $G$ 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</li><li>对于有向图 $G$，$G$ 是半欧拉图当且仅当<ul><li>如果将 $G$中的所有有向边退化为无向边时，那么 $G$ 的所有顶点属于同一个强连通分量；</li><li>最多只有一个顶点的出度与入度差为$1$；</li><li>最多只有一个顶点的入度与出度差为$1$；</li><li>所有其他顶点的入度和出度相同。</li></ul></li></ul></blockquote><p><strong>Hierholzer 算法</strong>用于在连通图中寻找欧拉路径，其流程如下：</p><ol><li>从起点出发，进行深度优先搜索。</li><li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li><li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li></ol><p>注意到只有那个入度与出度差为$1$ 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。<br>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。<br>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec; <span class="hljs-comment">// string-&gt;priority_queue 小顶堆</span><br><br>vector&lt;string&gt; stk;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; curr)</span> </span>&#123; <span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-keyword">while</span> (vec.<span class="hljs-built_in">count</span>(curr) &amp;&amp; vec[curr].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 映射表中存在当前出发点，且目的节点数不为0</span><br>string tmp = vec[curr].<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//字典序大的先入栈，逆序后字典序最小</span><br>vec[curr].<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 移除当前边</span><br><span class="hljs-built_in">dfs</span>(<span class="hljs-built_in">move</span>(tmp));<br>&#125;<br>stk.<span class="hljs-built_in">emplace_back</span>(curr); <span class="hljs-comment">// 遇到死胡同入栈</span><br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : tickets) &#123;<br>vec[it[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(it[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 构建映射表</span><br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br><br><span class="hljs-built_in">reverse</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> stk;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h1><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022023286.png" alt="摆动序列"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                result++;<br>                preDiff = curDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022024794.png" alt="跳跃游戏II"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightmost = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nextStepMost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(rightmost &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            nextStepMost = <span class="hljs-built_in">max</span>(nextStepMost, i + nums[i]);<br>            <span class="hljs-keyword">if</span>(nextStepMost &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ++ step;<br>            <span class="hljs-keyword">if</span>(rightmost &lt;= i) &#123;<br>                ++ step;<br>                rightmost = nextStepMost;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 记录最低价格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 情况二：相当于买入</span><br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br><br>            <span class="hljs-comment">// 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）</span><br>            <span class="hljs-keyword">if</span> (prices[i] &gt;= minPrice &amp;&amp; prices[i] &lt;= minPrice + fee) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出</span><br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice + fee) &#123;<br>                result += prices[i] - minPrice - fee;<br>                minPrice = prices[i] - fee; <span class="hljs-comment">// 情况一，这一步很关键</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-comment">// 0 无覆盖； 1：存在摄像头； 2: 不需要摄像头(被覆盖或空子树)</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 空子树</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 左右子树为空 或者 左右子树被覆盖但是没有相机</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// </span><br>            result++; <span class="hljs-comment">//左右子树中有一个未被覆盖</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//安装摄像头</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 左右子树均被覆盖，且至少存在一个摄像头</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="十、动态规划"><a href="#十、动态规划" class="headerlink" title="十、动态规划"></a>十、动态规划</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022025304.png" alt="动态规划"></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h1 id="十一、单调栈"><a href="#十一、单调栈" class="headerlink" title="十一、单调栈"></a>十一、单调栈</h1><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/posts/3687adfb/"/>
    <url>/posts/3687adfb/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是C-11"><a href="#什么是C-11" class="headerlink" title="什么是C++11"></a>什么是C++11</h2><p>C++11标准为C++编程语言的第三个官方标准，正式名叫ISO&#x2F;IEC 14882:2011 - Information technology – Programming languages – C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO&#x2F;IEC 14882:2003 - Programming languages – C++成为C++语言新标准。</p><p>C++11是对目前C++语言的扩展和修正， C++11不仅包含核心语言的新机能，而且扩展了C++的标准程序库（STL） ，并入了大部分的C++ Technical Report 1（TR1） 程序库(数学的特殊函数除外)。</p><p>C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、 decltype，和模板的大量改进。</p><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。从这个意义上讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型。</p><p>注意：</p><ol><li>定义变量时必须初始化；</li><li>不支持函数形参（C++11）；</li><li>不能作为自定义类型的成员变量；</li><li>不能作为模板实例化时的参数；</li><li>不能出现在顶级数组类型。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>)</span> </span>&#123;&#125;  <span class="hljs-comment">// 2: auto函数参数，有些编译器无法通过编译</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">str</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> var = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 3: auto非静态成员变量，无法通过编译</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> a;     <span class="hljs-comment">// 1: 无法推导，无法通过编译</span><br>    vector&lt;<span class="hljs-keyword">auto</span>&gt; b = &#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 4: auto模板参数（实例化时），无法通过编译</span><br>    <span class="hljs-keyword">auto</span> c[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 5: auto数组，无法通过编译</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code>可以从一个变量或表达式中得到其类型。</p><h3 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h3><p>返回类型后置：在函数名和参数列表后面指定返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> T1 &amp; t1, <span class="hljs-type">const</span> T2 &amp; t2)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t1 * t2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t1 * t2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="易用性的改进"><a href="#易用性的改进" class="headerlink" title="易用性的改进"></a>易用性的改进</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>类内成员初始化</li><li>初始化列表</li><li>使用列表初始化可以防止类型收窄</li></ol><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>使用基于范围的for循环，其for循环迭代的范围必须是可确定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span><span class="hljs-comment">//形参中数组是指针变量，无法确定元素个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e: a) <span class="hljs-comment">// err, 编译失败</span><br>    &#123;<br>        cout &lt;&lt; e;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">func</span>(a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><p>C&#x2F;C++提供了调试工具<code>assert</code>，这是一个宏，用于在<strong>运行阶段</strong>对断言进行检查，如果条件为真，执行程序，否则调用<code>abort()</code>。</p><p>C++ 11新增了关键字<code>static_assert</code>，可用于在<strong>编译阶段</strong>对断言进行测试。</p><p>静态断言的好处：</p><ul><li><p>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</p></li><li><p>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</p></li></ul><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>C++11 使用<code>noexcept</code>替代<code>throw()</code>代表此函数不能抛出异常，如果抛出，就会异常。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code>是为了解决原来C++中<code>NULL</code>的二义性问题而引进的一种新的类型，因为<code>NULL</code>实际上代表的是0。</p><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>C++ 11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明请类型枚举非常简单，只需要在enum后加上使用class或struct。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Old</span>&#123;Yes, No&#125;;          <span class="hljs-comment">// old style</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">New</span>&#123;Yes, No&#125;;    <span class="hljs-comment">// new style</span><br><span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">New2</span>&#123;Yes, No&#125;;  <span class="hljs-comment">// new style</span><br></code></pre></td></tr></table></figure><p>“传统”的C++枚举类型有一些缺点：它会在一个代码区间中抛出枚举类型成员（<strong>如果在相同的代码域中的两个枚举类型具有相同名字的枚举成员，这会导致命名冲突</strong>），它们会被隐式转换为<strong>整型</strong>，并且不可以指定枚举的底层数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;Ok, Error&#125;;<br>    <span class="hljs-comment">//enum Status2&#123;Ok, Error&#125;;//err, 导致命名冲突, Status已经有成员叫Ok, Error</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++11中，强类型枚举解决了这些问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Status</span> &#123;Ok, Error&#125;;<br>    <span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">Status2</span>&#123;Ok, Error&#125;;<br> <br>    <span class="hljs-comment">//Status flag2 = Ok; // err，必须使用强类型名称</span><br>    Status flag3 = Status::Ok;<br> <br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">char</span> &#123; C1 = <span class="hljs-number">1</span>, C2 = <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//指定枚举的底层数据类型</span><br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">D</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123; D1 = <span class="hljs-number">1</span>, D2 = <span class="hljs-number">2</span>, Dbig = <span class="hljs-number">0xFFFFFFF0</span>U &#125;;<br> <br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(C::C1) &lt;&lt; endl;   <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::D1) &lt;&lt; endl;     <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::Dbig) &lt;&lt; endl;   <span class="hljs-comment">// 4</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</p><p>这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算。</p><p><code>constexpr</code>函数的限制：</p><ul><li><p>函数中只能有一个return语句（有极少特例）</p></li><li><p>函数必须返回值（不能是void函数）</p></li><li><p>在使用前必须已有定义（不能先声明）</p></li><li><p>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式</p></li></ul><p>常量表达式的构造函数有以下限制：</p><ul><li>函数体必须为空</li><li>初始化列表只能由常量表达式来赋值</li></ul><h3 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h3><p>用户自定义字面值，或者叫“自定义后缀”更直观些，主要作用是简化代码的读写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _mm(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x / <span class="hljs-number">1000</span>; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _m(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)  &#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _km(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">1000</span>; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_mm &lt;&lt; endl; <span class="hljs-comment">//0.001</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_m  &lt;&lt; endl; <span class="hljs-comment">//1</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_km &lt;&lt; endl; <span class="hljs-comment">//1000</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 C++ 11 标准，只有下面参数列表才是合法的，最后四个对于字符串相当有用，第二个参数会自动推断为字符串的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> <span class="hljs-type">const</span> *<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span><br><span class="hljs-type">long</span> <span class="hljs-type">double</span><br><span class="hljs-type">char</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">wchar_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char16_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char32_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br></code></pre></td></tr></table></figure><h3 id="原生字符串字面值"><a href="#原生字符串字面值" class="headerlink" title="原生字符串字面值"></a>原生字符串字面值</h3><p>原生字符串字面值(raw string literal)使用户书写的字符串“所见即所得”。C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用括号左右标识，就可以声明该字符串字面量为原生字符串了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">R&quot;(hello,\n</span><br><span class="hljs-string">         world)&quot;</span> &lt;&lt; endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的改进"><a href="#类的改进" class="headerlink" title="类的改进"></a>类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">double</span> d, <span class="hljs-type">int</span> i) &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">float</span> f, <span class="hljs-type">int</span> i, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* c) &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::A; <span class="hljs-comment">// 继承构造函数</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ExtraInterface</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量</p></li><li><p>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</p></li><li><p>一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数</p></li></ul><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>和继承构造函数类似，委托构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。</p><p> 如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这<strong>必须通过初始化列表进行操作</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Info</span>() : <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>) &#123; &#125;    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">Info</span>(i, <span class="hljs-string">&#x27;a&#x27;</span>) &#123; &#125; <span class="hljs-comment">// 既是目标构造函数，也是委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">char</span> e): <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>, e) &#123; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">char</span> e): <span class="hljs-built_in">type</span>(i), <span class="hljs-built_in">name</span>(e) &#123; <span class="hljs-comment">/* 其它初始化 */</span> &#125; <span class="hljs-comment">// 目标构造函数</span><br>    <span class="hljs-type">int</span>  type;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="继承控制"><a href="#继承控制" class="headerlink" title="继承控制"></a>继承控制</h3><p>C++11之前，一直没有继承控制关键字，禁用一个类的进一步衍生比较麻烦。</p><p>C++ 11添加了两个继承控制关键字：<code>final</code>和<code>override</code>。</p><ul><li><p>final阻止类的进一步派生和虚函数的进一步重写</p></li><li><p>override确保在派生类中声明的函数跟基类的虚函数有相同的签名</p></li></ul><h3 id="类默认函数的控制"><a href="#类默认函数的控制" class="headerlink" title="类默认函数的控制"></a>类默认函数的控制</h3><ol><li><code>=default</code><ul><li>编译器将为显式声明的 <code>=default</code>函数自动生成函数体</li><li>仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数</li><li>函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义</li></ul></li><li><code>=delete</code><ul><li>在函数声明后加上<code>=delete</code>，就可将该函数禁用</li><li>可用于禁用类的某些转换构造函数，从而避免不期望的类型转换</li><li>禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象</li></ul></li></ol><h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><h3 id="右尖括号的改进"><a href="#右尖括号的改进" class="headerlink" title="右尖括号的改进"></a>右尖括号的改进</h3><p>在C++98&#x2F;03的泛型编程中，模板实例化有一个很繁琐的地方，就是连续两个右尖括号<code>&gt;&gt;</code>会被编译解释成右移操作符，而不是模板参数表的形式，需要一个空格进行分割，以避免发生编译时的错误。</p><p>在实例化模板时会出现连续两个右尖括号，同样<code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>表达式转换时也会遇到相同的情况。C++98标准是让程序员在<code>&gt;&gt;</code>之间填上一个空格，在C++11中，这种限制被取消了。在C++11标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出<code>&gt;&gt;</code>是一个右移操作符还是模板参数表的结束标记。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">//std::is_same</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">using</span> uint = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// CPP11</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> UINT;<br><span class="hljs-keyword">using</span> sint = <span class="hljs-type">int</span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//std::is_same 判断类型是否一致</span><br>    <span class="hljs-comment">//这个结构体作用很简单，就是两个一样的类型会返回true</span><br>    cout &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; endl; <span class="hljs-comment">// 1</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><p>C++11之前，类模板是支持默认的模板参数，却不支持函数模板的默认模板参数。类模板的默认模板参数必须从右往左定义，数模板的默认模板参数则没这个限定。</p><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>在C++11之前，类模板和函数模板只能含有固定数量的模板参数。C++11增强了模板功能，允许模板定义中包含0到任意个模板参数，这就是可变参数模板。</p><p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在<code>typename</code>或<code>class</code>后面带上省略号<code>...</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//可变参数的模板函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ... T&gt; <span class="hljs-comment">//T叫模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T... args)</span><span class="hljs-comment">//args叫函数参数包</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">250</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>省略号<code>...</code>的作用有两个：</p><ul><li>声明一个参数包，这个参数包中可以包含0到任意个模板参数 </li><li>在模板定义的右边，可以将参数包展开成一个一个独立的参数</li></ul><p>应用：</p><ol><li>函数的递归调用</li><li>类的递归继承</li></ol><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><p>左值引用是对一个左值进行引用的类型，右值引用则是对一个右值进行引用的类型。</p><p>左值引用和右值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须<strong>立即进行初始化</strong>。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个<strong>别名</strong>。</p><p>左值引用是具名变量值的别名，而右值引用则是<strong>不具名（匿名）变量</strong>的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;a = <span class="hljs-number">2</span>;       <span class="hljs-comment">// 左值引用绑定到右值，编译失败, err</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 非常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = b; <span class="hljs-comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;e = c; <span class="hljs-comment">// 常量左值引用绑定到常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 常量左值引用绑定到右值，编程通过, ok</span><br></code></pre></td></tr></table></figure><p><code>const 类型 &amp;</code>为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。</p><p>右值引用，使用<code>&amp;&amp;</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp; r1 = <span class="hljs-number">22</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> &amp;&amp; r2 = x + y;<br>T &amp;&amp; a = <span class="hljs-built_in">ReturnRvalue</span>();<br></code></pre></td></tr></table></figure><p>通常情况下，右值引用是不能够绑定到任何的左值的。</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</p><p>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。</p><p>通过转移语义，临时对象中的资源能够转移其它的对象里。</p><h4 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//移动构造函数</span><br>    <span class="hljs-comment">//参数是非const的右值引用</span><br>    <span class="hljs-built_in">MyString</span>(MyString &amp;&amp; t)<br>    &#123;<br>        str = t.str; <span class="hljs-comment">//拷贝地址，没有重新申请内存</span><br>        len = t.len;<br> <br>        <span class="hljs-comment">//原来指针置空，必须修改</span><br>        t.str = <span class="hljs-literal">NULL</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>和拷贝构造函数类似，有几点需要注意：</p><ul><li>参数（右值）的符号必须是右值引用符号，即<code>&amp;&amp;</code>。</li><li>参数（右值）不可以是常量，因为我们需要修改右值。</li><li>参数（右值）的资源链接和标记必须修改，否则，右值的析构函数就会释放资源，转移到新对象的资源也就无效了。</li></ul><p>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。转移赋值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>        <br>    <span class="hljs-comment">//移动赋值函数</span><br>    <span class="hljs-comment">//参数为非const的右值引用</span><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(MyString &amp;&amp;tmp)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(&amp;tmp == <span class="hljs-keyword">this</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//先释放原来的内存</span><br>        len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">delete</span> [] str;<br><br>        <span class="hljs-comment">//无需重新申请堆区空间</span><br>        len = tmp.len;<br>        str = tmp.str; <span class="hljs-comment">//地址赋值</span><br>        tmp.str = <span class="hljs-literal">NULL</span>;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;移动赋值函数\n&quot;</span>;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>   ...<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="标准库函数-std-move"><a href="#标准库函数-std-move" class="headerlink" title="标准库函数 std::move()"></a>标准库函数 std::move()</h3><p>如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用。标准库提供了函数 <code>std::move()</code>，这个函数以非常简单的方式将左值引用转换为右值引用。</p><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward()"></a>完美转发 std::forward()</h3><p>完美转发适用于这样的场景：<strong>需要将一组参数原封不动的传递给另一个函数</strong>。</p><p>“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：<strong>左值／右值和 const&#x2F;non-const</strong>。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样。在泛型函数中，这样的需求非常普遍。</p><p>C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。</p><p>C++11中的引用折叠规则：</p><table><thead><tr><th>TR的类型定义</th><th>声明v的类型</th><th>v的实际类型</th></tr></thead><tbody><tr><td>T &amp;</td><td>TR</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;&amp;</td><td>T &amp;</td></tr><tr><td>T  &amp;&amp;</td><td>TR</td><td>T  &amp;&amp;</td></tr><tr><td>T &amp;&amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T  &amp;&amp;</td><td>TR &amp;&amp;</td><td>T  &amp;&amp;</td></tr></tbody></table><p><strong>一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用。</strong></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>C++11中有<code>unique_ptr</code>、<code>shared_ptr</code>与<code>weak_ptr</code>等智能指针(smart pointer)，定义在<code>&lt;memory&gt;</code>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><code>unique_ptr</code>持有对对象的独有权，同一时刻只能有一个<code>unique_ptr</code>指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p><p><code>unique_ptr</code>指针本身的生命周期：从<code>unique_ptr</code>指针创建时开始，直到离开作用域。</p><p>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用<code>delete</code>操作符，用户可指定其他操作)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;   <span class="hljs-comment">// 无法复制的unique_ptr</span><br>    <span class="hljs-comment">//unique_ptr&lt;int&gt; up2 = up1;        // err, 不能通过编译</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">move</span>(up1);    <span class="hljs-comment">// 现在p3是数据的唯一的unique_ptr</span><br>    up3.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 显式释放内存</span><br>    up1.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 不会导致运行时错误</span><br>    <br>    up4.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">44</span>)); <span class="hljs-comment">//&quot;绑定&quot;动态对象</span><br>    <br>    up4 = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价</span><br>    <br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">55</span>))</span></span>;<br>    <span class="hljs-type">int</span> *p = up5.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//只是释放控制权，不会释放内存</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//释放堆区资源</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><code>shared_ptr</code>允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个<code>shared_ptr</code>共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数2</span><br>    <br>    sp1.<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">//显式让引用计数减1</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下<code>shared_ptr</code>可以正常运转，但是在循环引用的场景下，<code>shared_ptr</code>无法正确释放内存。循环引用，顾名思义，<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>，在表示双向关系时，是很可能出现这种情况的，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Father&gt; father_;<br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son = <span class="hljs-built_in">make_shared</span>&lt;Son&gt;();<br>    <span class="hljs-keyword">auto</span> father = <span class="hljs-built_in">make_shared</span>&lt;Father&gt;();<br>    son-&gt;father_ = father;<br>    father-&gt;son_ = son;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Son<br>Father<br>son: 2<br>father: 2</p></blockquote><p>可以看到，程序分别执行了Son和Father的构造函数，但是没有执行析构函数，出现了内存泄漏。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><code>weak_ptr</code>是为配合<code>shared_ptr</code>而引入的一种智能指针来协助<code>shared_ptr</code>工作，它可以从一个<code>shared_ptr</code>或另一个<code>weak_ptr</code>对象构造，<strong>它的构造和析构不会引起引用计数的增加或减少</strong>。没有重载 <code>*</code> 和<code> -&gt;</code> 但可以使用<code>lock</code>获得一个可用的<code>shared_ptr</code>对象</p><p><code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存，而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>share_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值<code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp = sp1; <span class="hljs-comment">// 指向shared_ptr&lt;int&gt;所指对象</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印计数器 2</span><br><br>    sp1.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    sp2.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决循环引用的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    SharedPtr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    WeakPtr&lt;Father&gt; father_;  <span class="hljs-comment">// 将SharedPtr改为WeakPtr</span><br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();  <span class="hljs-comment">// 创建一个Son对象，返回指向Son对象的指针son_</span><br>    <span class="hljs-keyword">auto</span> father_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Father</span>();  <span class="hljs-comment">// 创建一个Father对象，返回指向Father对象的指针father_</span><br>    <span class="hljs-function">SharedPtr&lt;Son&gt; <span class="hljs-title">son</span><span class="hljs-params">(son_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：son.counter=1, son.weakref=0</span><br>    <span class="hljs-function">SharedPtr&lt;Father&gt; <span class="hljs-title">father</span><span class="hljs-params">(father_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：father.counter=1, father.weakref=0</span><br>    son.resource-&gt;father_ = father;  <span class="hljs-comment">// 调用WeakPtr赋值函数：father.counter=1, father.weakref=1</span><br>    father.resource-&gt;son_ = son;  <span class="hljs-comment">// 调用SharedPtr赋值函数：son.counter=2, son.weakref=0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h2><p>闭包有很多种定义，一种说法是，闭包是带有上下文的函数。即有状态的函数。</p><p>那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。</p><p>函数是代码，状态是一组变量，将代码和一组变量捆绑 (bind) ，就形成了闭包。</p><p>闭包的状态捆绑，必须发生在运行时。</p><h3 id="仿函数：重载-operator"><a href="#仿函数：重载-operator" class="headerlink" title="仿函数：重载 operator()"></a>仿函数：重载 operator()</h3><p>仿函数实现闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFunctor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> tmp) : <span class="hljs-built_in">round</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; <span class="hljs-keyword">return</span> tmp + round; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> round;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> round = <span class="hljs-number">2</span>;<br>    <span class="hljs-function">MyFunctor <span class="hljs-title">f</span><span class="hljs-params">(round)</span></span>;<span class="hljs-comment">//调用构造函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">//operator()(int tmp)</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对象，或者实现了opetator()的对象。</p><p>C++11中，新增加了一个<code>std::function</code>类模板，它是对C++中现有的可调用实体的一种类型安全的包裹。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//普通全局函数</span><br>    cout &lt;&lt; __func__ &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">foo_func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//类中静态函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//仿函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//绑定一个普通函数</span><br>    function&lt; <span class="hljs-type">void</span>(<span class="hljs-type">void</span>) &gt; f1 = func;<br>    <span class="hljs-built_in">f1</span>();<br> <br>    <span class="hljs-comment">//绑定类中的静态函数</span><br>    function&lt; <span class="hljs-type">int</span>(<span class="hljs-type">int</span>) &gt; f2 = Foo::foo_func;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">111</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">//绑定一个仿函数</span><br>    Bar obj;<br>    f2 = obj;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">222</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     运行结果：</span><br><span class="hljs-comment">        func</span><br><span class="hljs-comment">        foo_func(111) -&gt;: 111</span><br><span class="hljs-comment">        operator()(222) -&gt;: 222</span><br><span class="hljs-comment">    */</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::function</code>对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与<code>NULL</code>或者<code>nullptr</code>进行比较。</p><h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p><code>std::bind</code>是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。</p><p>C++98中，有两个函数<code>bind1st</code>和<code>bind2nd</code>，它们分别可以用来绑定<code>functor</code>的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得<code>bind1st</code>和<code>bind2nd</code>的可用性大大降低。</p><p>在C++11中，提供了<code>std::bind</code>，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>C++11中的lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。<br>lambda表达式的基本构成：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022009099.png" alt="lambda表达式"></p><ol><li><p>函数对象参数</p><p><code>[]</code>，标识一个lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义lambda为止时lambda所在作用范围内可见的局部变量（包括lambda所在类的this）。函数对象参数有以下形式：</p><ul><li>空。没有使用任何函数对象参数。</li><li>&#x3D;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>&amp;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量)。</li><li>this。函数体内可以使用lambda所在类中的成员变量。</li><li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>&amp;a。将a按引用进行传递。</li><li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li><li>&#x3D;，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul></li><li><p>操作符重载函数参数<br>标识重载的<code>()</code>操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p></li><li><p>可修改标示符<br><code>mutable</code>声明，这部分可以省略。按值传递函数对象参数时，加上<code>mutable</code>修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p></li><li><p>错误抛出标示符</p><p><code>exception</code>声明，这部分也可以省略。</p></li><li><p>函数返回值</p><p><code>-&gt;返回值类型</code>，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p></li><li><p>是函数体<br><code>&#123;&#125;</code>，标识函数的实现，这部分不能省略，但函数体可以为空。</p></li></ol><p>除去在语法层面上的不同，lambda和仿函数有着相同的内涵——都可以捕获一些变量作为初始化状态，并接受参数进行运行。</p><p>而事实上，仿函数是编译器实现lambda的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式。</p><p>lambda表达式的类型在C++11中被称为<strong>“闭包类型”</strong>，每一个lambda表达式则会产生一个**临时对象(右值)**。因此，严格地将，lambda函数并非函数指针。</p><p>不过C++11标准却允许lambda表达式向函数指针的转换，但提前是<strong>lambda函数没有捕获任何变量</strong>，且函数指针所示的函数原型，必须跟lambda函数函数有着相同的调用方式。</p><p>lambda表达式的价值在于，就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在C++11之前，C&#x2F;C++一直是一种顺序的编程语言。顺序是指所有指令都是串行执行的，即在相同的时刻，有且仅有单个CPU的程序计数器执行代码的代码段，并运行代码段中的指令。而C&#x2F;C++代码也总是对应地拥有一份操作系统赋予进程的包括堆、栈、可执行的（代码）及不可执行的（数据）在内的各种内存区域。</p><p>而在C++11中，一个相当大的变化就是引入了多线程的支持。这使得C&#x2F;C++语言在进行线程编程时，不比依赖第三方库。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷 C++11/14 笔记</title>
    <link href="/posts/bea73fec/"/>
    <url>/posts/bea73fec/</url>
    
    <content type="html"><![CDATA[<h2 id="Variadic-Template"><a href="#Variadic-Template" class="headerlink" title="Variadic Template"></a>Variadic Template</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>可变参数模板。</p><ol><li><p>谈的是模板Templates：</p><ul><li>函数模板 </li><li>类模板</li></ul></li><li><p>变化的是模板参数：</p><ul><li>参数个数：利用参数个数逐一递减的特性，实现递归函数的调用，使用函数模板完成。</li><li>参数类型：利用参数个数逐一递减以致参数类型也逐一递减的特性，实现递归继承或递归复合，以类模板完成。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;                <span class="hljs-comment">//这里的...是关键字的一部分：模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; firstArg, <span class="hljs-type">const</span> Types&amp;... args)</span>     <span class="hljs-comment">//这里的...要写在自定义类型Types后面：函数参数类型包</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; firstArg &lt;&lt; endl;<br>    <span class="hljs-built_in">print</span>(args...);                                     <span class="hljs-comment">//这里的...要写在变量args后面：函数参数包</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>注意三种不同的<code>...</code>的应用环境，这些都是<strong>语法规则</strong>，所以记住即可。</p></li><li><p>还要注意的是，在可变模板参数内部可以使用<code>sizeof...(args)</code>得到实参的个数。</p></li><li><p>如果同时定义了：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*......*/</span>&#125;<br></code></pre></td></tr></table></figure><p>该函数重载了<code>void print()</code>，<code>void print(const T&amp; firstArg, const Types&amp;... args)</code> 是其特化版本，编译器会优先调用特化版本。 </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>实现函数的 递归调用</p><p> 举了一个unordered容器中hash函数的计算例子：万用的哈希函数，函数入口<code>return hash_val(c.fname, c.lname, c.no)</code>;</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerHash</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(c.fname, c.lname, c.no);<br>        <span class="hljs-comment">// 2-1-1-...-1-3</span><br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val, <span class="hljs-type">const</span> Types&amp;... args)</span></span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args);<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// 2</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 3</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val)</span></span>&#123;<br>    <span class="hljs-built_in">hash_conbine</span>(seed, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022007091.png" alt="递归调用"></p><ol><li>实现递归继承</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Values&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;<br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;&gt; &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;Head, Tail...&gt;<br>    : <span class="hljs-keyword">private</span> tuple&lt;Tail...&gt;                  <span class="hljs-comment">//注意这里的私有继承</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> tuple&lt;Tail...&gt; inherited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">tuple</span>() &#123;&#125;<br>    <span class="hljs-built_in">tuple</span>(Head v, Tail... vtail)<br>        :<span class="hljs-built_in">m_head</span>(v), <span class="hljs-built_in">inherited</span>(vtail...) &#123;&#125;<br><br>    <span class="hljs-function">Head <span class="hljs-title">head</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_head; &#125;<br>    <span class="hljs-function">inherited&amp; <span class="hljs-title">tail</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;       <span class="hljs-comment">//这里涉及派生类到基类的类型转换</span><br><br><span class="hljs-keyword">protected</span>:<br>    Head m_head;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022008946.png" alt="递归继承"></p><h2 id="模板表达式中的空格"><a href="#模板表达式中的空格" class="headerlink" title="模板表达式中的空格"></a>模板表达式中的空格</h2><p>C++11可以去掉模块表达式前面的空格。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>标准库允许使用nullptr取代0或者NULL来对指针赋值。</p><ul><li>nullptr 是个新关键字</li><li>nullptr 可以被自动转换为各种 pointer 类型，但不会被转换为任何整数类型</li><li>nullptr的类型为std::nullptr_t，定义于 <cstddef> 头文件中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 调用 f(int).</span><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">NULL</span>);     <span class="hljs-comment">// 如果定义NULL为0，则调用 f(int)，否则具有二义性</span><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 调用 f(void *).</span><br></code></pre></td></tr></table></figure><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><ol><li>C++11 auto可以进行自动类型推导。<ul><li><strong>C语言</strong>默认的局部变量是auto类型的</li><li><strong>C++11</strong> auto可以进行自动类型推导</li></ul></li><li>使用auto的场景：类型太长或者类型太复杂</li></ol><h2 id="一致性初始化（uniform-initialization）"><a href="#一致性初始化（uniform-initialization）" class="headerlink" title="一致性初始化（uniform initialization）"></a>一致性初始化（uniform initialization）</h2><p>C++11之前初始化时存在多个版本 <code>&#123;&#125;，（），=</code>。让使用者使用时比较混乱，C++11提供一种万用的初始化方法，就是使用大括号<code>&#123;&#125;</code>。</p><p>原理解析：当编译器看到大括号包起来的东西<code>&#123;t1,t2...tn&#125;</code>时，会生成一个<code>initializer_list&lt;T&gt;</code>（<code>initializer_list</code>关联至一个<code>array&lt;T,n&gt;</code>）。调用函数（例如构造函数<code>ctor</code>）时该<code>array</code>内的元素可被编译器分解<strong>逐一传给函数</strong>；元素逐一分解传递给函数进行初始化。</p><p>但是如果调用函数自身提供了<code>initializer_list&lt;T&gt;</code>参数类型的构造函数时，则不会分解而是直接传过去。直接整包传入进行初始化。所有的容器都可以接受这样的参数。</p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer_list"></a>Initializer_list</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i;      <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span> j&#123;&#125;;    <span class="hljs-comment">// j = 0</span><br><span class="hljs-type">int</span>* p;     <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span>* q&#123;&#125;;   <span class="hljs-comment">// q = nullptr</span><br></code></pre></td></tr></table></figure><ol><li><p><code>initializer_list&lt;T&gt;</code>使用举例：</p><ul><li><code>initializer_list&lt;T&gt;</code>是一个<code>class</code>（类模板），这个必须类型要一致，跟模板不定的参数类型相比，模板不定的参数类型可以都不一样。</li><li><code>initializer_list&lt;T&gt;</code>类似于容器的使用方法</li></ul></li><li><p><code>initializer_list</code>源码剖析：</p><ul><li><code>initializer_list&lt;T&gt;</code>背后有<code>array</code>数组支撑，<code>initializer_list</code>关联一个<code>array&lt;T,n&gt;</code></li><li><code>initializer_list&lt;T&gt;</code>包含一个指向<code>array</code>的指针，它的拷贝只是一个浅拷贝，比较危险，两个指针指向同一个内存。</li></ul></li><li><p>initializer_list在STL中的使用：</p><ul><li>所有容器都接受指定任意数量的值用于构造或赋值或者<code>insert()</code>或<code>assign()</code>。</li><li>算法<code>max()</code>和<code>min()</code>也接受任意参数。</li></ul></li></ol><h2 id="explict"><a href="#explict" class="headerlink" title="explict"></a>explict</h2><p><code>explicit</code>关键字一直存在，只能作用在构造函数中，目的是阻止编译器进行不应该允许的构造函数进行隐式转换。声明为<code>explicit</code>的构造函数不能进行隐式转换，只能允许使用者明确调用构造函数。</p><p>C++11之前，只有<code>non-explicit one argument</code>的构造函数才能进行隐式转换，2.0之后支持<code>more than one argument</code>的构造函数的隐式转换。 </p><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (decl : coll) &#123;<br>    statement<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br>vector&lt;<span class="hljs-type">double</span>&gt; vec;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:  vec) &#123;...&#125;;     <span class="hljs-comment">// 赋值，无法改变容器的内容</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; elem:  vec) &#123;...&#125;;    <span class="hljs-comment">// 引用</span><br></code></pre></td></tr></table></figure><p>基于范围的<code>for</code>循环对于<code>explicit</code>类型申明的转换是不可以的。</p><h2 id="x3D-default-x3D-delete"><a href="#x3D-default-x3D-delete" class="headerlink" title="&#x3D; default, &#x3D; delete"></a>&#x3D; default, &#x3D; delete</h2><p>在 C++ 中，如果自定义了 big-five 函数，编译器就不会再生成默认的相关函数，但是如果我们在后边加上<code>= default</code> 关键字，就可以重新获得并使用编译器为我们生成的默认函数（显式缺省:告知编译器即使自己定义了也要生成函数默认的缺省版本）；</p><p><code>=delete</code>关键字相对于上面来说则是相反的，<code>=delete</code>表示不要这个函数，就是说这个函数已经删除了不能用了，一旦别人使用就会报错（显式删除：告知编译器不生成函数默认的缺省版本)，引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p><p>补充：</p><p>1、编译器提供的默认函数：</p><p>C++中，当我们设计与编写一个类时，若不显著申明，则类会默认为我们提供如下几个函数：</p><ol><li>构造函数(<code>A()</code>)</li><li>析构函数（<code>~A()</code>）</li><li>拷贝构造函数(<code>A(A&amp;)</code>)</li><li>拷贝赋值函数（<code>A&amp; operator=(A&amp;)</code>）</li><li>移动构造函数（<code>A(A&amp;&amp;)</code>）</li><li>移动赋值函数（<code>A&amp; operator=(A&amp;&amp;)</code>）</li></ol><p>注意：拷贝函数如果涉及指针就要区分浅拷贝（指针只占4字节，浅拷贝只把指针所占的那4个字节拷贝过去）和深拷贝（不仅要拷贝指针所占的字节，还要把指针所指的东西也要拷贝过去）；</p><p>默认提供全局的默认操作符函数：</p><ol><li><code>operator</code></li><li><code>operator &amp;</code></li><li><code>operator &amp;&amp;</code></li><li><code>operator *</code></li><li><code>operator-&gt;</code></li><li><code>operator-&gt;*</code></li><li><code>operator new</code></li><li><code>operator delete</code></li></ol><p><strong>2、何时需要自定义big-three(构造函数、拷贝构造、拷贝赋值)&#x2F;big-five(新增移动构造函数、移动赋值函数)？</strong></p><p>如果类中带有<code>pointer member</code>（指针成员），那我们就可以断定必须要给出 big-three ；<br>如果不带，绝大多与情况下就不必给出 big-three 。</p><p>3、<code>default</code>、<code>delete</code>关键字使用示例</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022012705.png" alt="=default, =delete"></p><p>在c++中，如果你自定义了big-five函数，编译器就不会再为你生成默认的相关函数，但是如果我们在后边加上<code>= default</code>关键字，就可以重新获得并使用编译器为我们生成的默认函数（显式缺省:告知编译器即使自己定义了也要生成函数默认的缺省版本）；</p><p><code>=delete</code>关键字相对于上面来说则是相反的，<code>=delete</code>表示不要这个函数，就是说这个函数已经删除了不能用了，一旦别人使用就会报错（显式删除：告知编译器不生成函数默认的缺省版本)，引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022013341.png" alt="image-20220802201319128"></p><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;<br><br><span class="hljs-comment">//使用</span><br>Vec&lt;<span class="hljs-type">int</span>&gt; coll;<br></code></pre></td></tr></table></figure><p>Alias Template 无法特化。</p><p>应用实例(引出模板模板参数)</p><p>考虑这样一种需求，假设我们需要实现一个函数<code>test_moveable(容器对象，类型对象)</code>，从而能实现传入任意的容器和类型，都能将其组合为一个新的东西：容器&lt;类型&gt;，这样的话我们的函数应该怎么设计呢？</p><p>（1）解法一：函数模板(无法实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_moveable</span><span class="hljs-params">(Container cntr, T elem)</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;T&gt; c;            <span class="hljs-comment">//[Error] &#x27;Container&#x27; is not a template</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>        c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">T</span>());<br>    <br>    <span class="hljs-built_in">output_static_data</span>(<span class="hljs-built_in">T</span>());<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>    c1.<span class="hljs-built_in">swap</span>(c2);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）解法二：函数模板+iterator+traits(可以实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_moveable</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::value_type Valtype;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>        c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Valtype</span>());<br>    <br>    <span class="hljs-built_in">output_static_data</span>(*(c.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>    c1.<span class="hljs-built_in">swap</span>(c2);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是可以达到效果的，但是却改变了函数签名，使用的时候我们需要这样调用：<code>test_moveable(list&lt;int&gt;())</code>，和我们开始设计的是不一样的。那么，有没有 template 语法能够在模板接受一个 template 参数 Container 时，当 Container 本身又是一个 class template ，能取出 Container 的template 参数？例如收到一个<code>vector&lt;string&gt;</code>，能够取出其元素类型<code>string</code>？那么这就引出了<strong>模板模板参数</strong>的概念。也就是下面的解法三。</p><p>（3）解法三：模板模板参数 + alias template(可以实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>          <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 模板模板参数中的T可以不写，默认就是前面的T</span><br>              <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>         &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XCls</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    Container&lt;T&gt; c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">XCLs</span>()<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>            c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">T</span>());<br> <br>        <span class="hljs-built_in">output_static_data</span>(<span class="hljs-built_in">T</span>());<br>        <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>        <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>        c1.<span class="hljs-built_in">swap</span>(c2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用时会报错</span><br>XCls&lt;MyString, vector&gt; c1;        <span class="hljs-comment">//[Error] vector的实际类型和模板中的Container&lt;T&gt;类型不匹配</span><br></code></pre></td></tr></table></figure><p>这是因为 <code>vector</code> 其实有<strong>两个模板参数</strong>，虽然第二个有默认值，我们平时也可以像<code>vector&lt;int&gt;</code>这样用。但是在模板中直接这样写类型是不匹配的（ <code>Container</code> 只有一个模板参数 ）。所以这里就用到了我们一开始提到的模板别名，只要传入的是<code>vector</code>的模板别名就可以了，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//不得在function body之内声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;<br> <br>XCls&lt;MyString, Vec&gt; c1;<br></code></pre></td></tr></table></figure><h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>类型别名类似于typedef。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">//相当于</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><code>using</code> 的用法：</p><ol><li>打开命令空间或者命令空间的成员</li><li>类似第一种，打开类的成员</li><li>类型别名和模板别名（C++ 11开始支持）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::cin;                 <span class="hljs-comment">//1</span><br><span class="hljs-keyword">using</span> _Base::_M_alloacte;       <span class="hljs-comment">//2</span><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="noexpect"><a href="#noexpect" class="headerlink" title="noexpect"></a>noexpect</h2><p>保证该函数不会丢出异常，可以在后面加上条件,也就是说在某种条件满足情况下，不会抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> noexpect</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexpect</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>一般异常处理流程</strong>：当程序发生异常时会将异常信息上报返回给调用者，如果有异常处理则处理，如果该调用者没有处理异常则会接着上报上一层，若到了最上层都没有处理，就会调用<code>std::terminate()-&gt;std::abort()</code>，然后终止程序。</p><div class="note note-warning">            <p>移动构造函数和移动赋值函数。如果构造函数没有<code>noexcept</code>，<code>vector</code>将不敢使用它。</p>          </div><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p><code>override</code>用于明确要重写父类的虚函数上，相当于告诉编译器这个函数就是要重写父类虚函数这样一个意图，让编译器帮忙检查，而没有这个关键字，编译器是不会帮你检查的。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022015702.png" alt="override"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><code>final</code>新增两种功能：</p><ol><li>禁止基类被继承</li><li>禁止虚函数被重写</li></ol><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="decltype-定义"><a href="#decltype-定义" class="headerlink" title="decltype 定义"></a>decltype 定义</h3><p>引入新关键字<code>decltype</code>可以让编译器找出表达式的类型，为了区别<code>typeof</code>，以下做一个概念区分：</p><ul><li><code>typeof</code>是一个一元运算，放在一个运算数之前，运算数可以是任意类型，非常依赖平台，已过时，由<code>decltype</code>代替；理解为：我们根据<code>typeof()</code>括号里面的变量，自动识别变量类型并返回该类型；</li><li><code>typedef</code>：定义一种类型的别名，而不只是简单的宏替换；</li><li><code>define</code>：简单的宏替换；</li><li><code>typeid()</code> 返回变量类型的字符串，用于<code>print</code>变量类型。</li></ul><h3 id="decltype-用法"><a href="#decltype-用法" class="headerlink" title="decltype 用法"></a>decltype 用法</h3><ol><li>用来声明函数的返回值类型，一种新的指定函数返回值类型的方式；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Add</span><span class="hljs-params">(T1 x, T2 y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x + y)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>模板之间的应用</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022016392.png" alt="模板之间的应用"></p><ol start="3"><li><p>用来求 lambda 表达式的类型</p><p>lambda 是匿名的函数对象或仿函数，每一个都是独一无二的；如果需要声明一个这种对象的话，需要用模板或者 auto ；如果需要他的 type ，可以使用 decltype ；lambda 没有默认构造函数和析构函数。</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022017251.png" alt="lambda表达式"></p><h2 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h2><h3 id="lambda-语法以及调用方式"><a href="#lambda-语法以及调用方式" class="headerlink" title="lambda 语法以及调用方式"></a>lambda 语法以及调用方式</h3><p>定义： lambda 是一组功能的组合定义， lambda 可以定义为内联函数，可以被当做一个参数或者一个对象，类似于仿函数。</p><p>最简单的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">[] &#123;<br>    statements<br>&#125;;<br><br><span class="hljs-keyword">auto</span> l = [] &#123;<br>    statements<br>&#125;;<br><br><span class="hljs-built_in">l</span>(); <br></code></pre></td></tr></table></figure><p>完整形式：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022019028.png" alt="lambda表达式"></p><table><thead><tr><th></th><th>含义</th></tr></thead><tbody><tr><td>[]</td><td>lambda 导入器，取用外部变量</td></tr><tr><td>()</td><td>类似函数参数</td></tr><tr><td>mutable</td><td>[]中的导入数据是否可变</td></tr><tr><td>throwSpec</td><td>抛出异常</td></tr><tr><td>retType</td><td>类似函数返回值</td></tr><tr><td>{}</td><td>类似函数体</td></tr></tbody></table><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022017584.png" alt="image-20220802201742502"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022018597.png" alt="image-20220802201822504"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++项目笔记——MyTinySTL(1)概述</title>
    <link href="/posts/135304f3/"/>
    <url>/posts/135304f3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/ww1820/MyTinySTL">ww1820&#x2F;MyTinySTL: A tiny STL in C++11，练手项目 (github.com)</a></p></blockquote><h2 id="STL（Standard-Template-Library）"><a href="#STL（Standard-Template-Library）" class="headerlink" title="STL（Standard Template Library）"></a>STL（Standard Template Library）</h2><ul><li>C++ Standard Library，C++ 标准库<ul><li>C++ Standard Template Library，C++ 标准模板库</li></ul></li></ul><p>STL 是 <strong>C++ 标准库的一部分</strong>，不用单独安装。. C++ STL 借助模板（Template）把常用的 <strong>数据结构</strong> 及其<strong>算法</strong>都实现了一遍，并且做到了数据结构和算法的<strong>分离</strong>（GP <strong>vs.</strong> OOP）。</p><p>C++标准库以头文件的形式呈现：</p><ul><li>新式C++头文件不带<code>.h</code> 后缀，如<code>#include&lt;vector&gt;</code></li><li>旧式C++头文件带<code>.h</code> 后缀，如<code>#include&lt;stdio.h&gt;</code></li><li>新式头文件内的组件封装于<code>namespace std</code></li><li>旧式头文件内的组件不封装于<code>namespace std</code></li></ul><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><ol><li>分配器（Allocators）：内存管理。</li><li>迭代器（Iterators）：泛化的指针，算法通过迭代器访问容器中的数据。</li><li>容器（Containers）：封装了大量常用的数据结构。</li><li>算法（Algorithms）：定义了一些常用算法，处理数据。</li><li>仿函数（Functors）：具有函数特质的对象（重载<code>operator()</code>的类）。</li><li>适配器（Adapters）：修改接口。</li></ol><p><img src="https://aweiii.coding.net/p/blog/d/img/git/raw/main/posts/STLComponents.png" alt="STLComponents"></p><h2 id="容器的分类与结构"><a href="#容器的分类与结构" class="headerlink" title="容器的分类与结构"></a>容器的分类与结构</h2><ul><li>顺序容器：<ul><li>Array：长度固定的数组，存储空间连续，支持随机访问</li><li>Vector：动态数组，存储空间连续，支持随机访问</li><li>Deque：双端队列，存储空间分段连续，支持随机访问</li><li>List：双向链表，存储空间不连续，不支持随机访问</li><li>Forward-List：单向链表，存储空间不连续，不支持随机访问</li></ul></li><li>关联容器：红黑树实现，有序。Multi的key可以重复<ul><li>Set&#x2F;MultiSet</li><li>Map&#x2F;MultiMap</li></ul></li><li>无序容器：哈希表（Separate Chaining）实现<ul><li>Unoedered Set&#x2F;MultiSet</li><li>Unoedered Map&#x2F;MultiMap</li></ul></li></ul><p><img src="https://aweiii.coding.net/p/blog/d/img/git/raw/main/posts/p1.png" alt="容器的分类与结构"></p><div class="note note-warning">            <ol><li><p>C++ Primer 中指出  <code>string</code> 是与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</p></li><li><p>deque由<strong>若干段</strong>连续空间串接而成，一旦有必要在deque的头部或尾端增加新的空间，便配置一段定量连续的空间，串接在deque的头部或尾端。deque的最大任务，就是在这些分段连续的空间上维护其整体连续的假象，并提供随机存取的接口。</p><p>deque首次插入一个元素，默认会动态分配512字节空间，当这512字节空间用完后，它会再动态分配自己另外的512字节空间，然后<strong>虚拟地</strong>连在一起。<strong>deque的随机访问和遍历性能比vector差。</strong></p></li></ol>          </div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="主要文件结构"><a href="#主要文件结构" class="headerlink" title="主要文件结构"></a>主要文件结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs stylus">MyTinySTL<br>│      alloc<span class="hljs-selector-class">.h</span>       <span class="hljs-comment">// 分配器</span><br>│      allocator<span class="hljs-selector-class">.h</span>   <br>│      construct<span class="hljs-selector-class">.h</span><br>│      uninitialized<span class="hljs-selector-class">.h</span><br>│      memory<span class="hljs-selector-class">.h</span><br>│      iterator<span class="hljs-selector-class">.h</span>    <span class="hljs-comment">// 迭代器</span><br>│      type_traits<span class="hljs-selector-class">.h</span> <span class="hljs-comment">// 萃取器</span><br>│      list<span class="hljs-selector-class">.h</span>        <span class="hljs-comment">// 容器</span><br>│      vector<span class="hljs-selector-class">.h</span><br>│      deque<span class="hljs-selector-class">.h</span><br>│      rb_tree<span class="hljs-selector-class">.h</span><br>│      set<span class="hljs-selector-class">.h</span><br>│      map<span class="hljs-selector-class">.h</span><br>│      hashtable<span class="hljs-selector-class">.h</span><br>│      unordered_map<span class="hljs-selector-class">.h</span><br>│      unordered_set<span class="hljs-selector-class">.h</span><br>│      astring<span class="hljs-selector-class">.h</span><br>│      basic_string<span class="hljs-selector-class">.h</span><br>│      queue<span class="hljs-selector-class">.h</span><br>│      stack<span class="hljs-selector-class">.h</span><br>│      algo<span class="hljs-selector-class">.h</span> <span class="hljs-comment">// 算法</span><br>│      algobase<span class="hljs-selector-class">.h</span><br>│      algorithm<span class="hljs-selector-class">.h</span><br>│      numeric<span class="hljs-selector-class">.h</span><br>│      heap_algo<span class="hljs-selector-class">.h</span><br>│      set_algo<span class="hljs-selector-class">.h</span><br>│      functional<span class="hljs-selector-class">.h</span>  <span class="hljs-comment">//仿函数</span><br>│      exceptdef<span class="hljs-selector-class">.h</span>   <span class="hljs-comment">//其他</span><br>│      util<span class="hljs-selector-class">.h</span><br>│<br>└─Test            <span class="hljs-comment">// 测试文件</span><br>    │  test<span class="hljs-selector-class">.cpp</span>      <span class="hljs-comment">// 程序入口</span><br>    │  algorithm_performance_test<span class="hljs-selector-class">.h</span><br>    │  algorithm_test<span class="hljs-selector-class">.h</span><br>    │  deque_test<span class="hljs-selector-class">.h</span><br>    │  list_test<span class="hljs-selector-class">.h</span><br>    │  map_test<span class="hljs-selector-class">.h</span><br>    │  queue_test<span class="hljs-selector-class">.h</span><br>    │  set_test<span class="hljs-selector-class">.h</span><br>    │  stack_test<span class="hljs-selector-class">.h</span><br>    │  string_test<span class="hljs-selector-class">.h</span><br>    │  test<span class="hljs-selector-class">.h</span><br>    │  unordered_map_test<span class="hljs-selector-class">.h</span><br>    │  unordered_set_test<span class="hljs-selector-class">.h</span><br>    │  vector_test<span class="hljs-selector-class">.h</span><br>    │  CMakeLists<span class="hljs-selector-class">.txt</span><br>    │  README.md<br></code></pre></td></tr></table></figure><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mystl::test;<br><br>  std::cout.<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">//算法测试: 包含了 mystl 的 81 个算法测试 algorithm_test.h</span><br>  <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>  <span class="hljs-comment">// 仅仅针对 sort, binary_search 做了性能测试 algorithm_performance_test.h</span><br>  algorithm_performance_test::<span class="hljs-built_in">algorithm_performance_test</span>();<br>  <span class="hljs-comment">// vector test : 测试 vector 的接口与 push_back 的性能</span><br>  vector_test::<span class="hljs-built_in">vector_test</span>();<br>  <span class="hljs-comment">// list test : 测试 list 的接口与 insert, sort 的性能</span><br>  list_test::<span class="hljs-built_in">list_test</span>();<br>  <span class="hljs-comment">// deque test : 测试 deque 的接口和 push_front/push_back 的性能</span><br>  deque_test::<span class="hljs-built_in">deque_test</span>();<br>  <span class="hljs-comment">// queue test : 测试 queue, priority_queue 的接口和它们 push 的性能</span><br>  queue_test::<span class="hljs-built_in">queue_test</span>();<br>  queue_test::<span class="hljs-built_in">priority_test</span>();<br>  <span class="hljs-comment">// stack test : 测试 stack 的接口 和 push 的性能</span><br>  stack_test::<span class="hljs-built_in">stack_test</span>();<br>  <span class="hljs-comment">// map test : 测试 map, multimap 的接口与它们 insert 的性能</span><br>  map_test::<span class="hljs-built_in">map_test</span>();<br>  map_test::<span class="hljs-built_in">multimap_test</span>();<br>  <span class="hljs-comment">// set test : 测试 set, multiset 的接口与它们 insert 的性能</span><br>  set_test::<span class="hljs-built_in">set_test</span>();<br>  set_test::<span class="hljs-built_in">multiset_test</span>();<br>  <span class="hljs-comment">// unordered_map test : 测试 unordered_map, unordered_multimap 的接口与它们 insert 的性能</span><br>  unordered_map_test::<span class="hljs-built_in">unordered_map_test</span>();<br>  unordered_map_test::<span class="hljs-built_in">unordered_multimap_test</span>();<br>  <span class="hljs-comment">// unordered_set test : 测试 unordered_set, unordered_multiset 的接口与它们 insert 的性能</span><br>  unordered_set_test::<span class="hljs-built_in">unordered_set_test</span>();<br>  unordered_set_test::<span class="hljs-built_in">unordered_multiset_test</span>();<br>  <span class="hljs-comment">// string test : 测试 string 的接口和 insert 的性能</span><br>  string_test::<span class="hljs-built_in">string_test</span>();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_MSC_VER) &amp;&amp; defined(_DEBUG)</span><br>  _CrtDumpMemoryLeaks();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// check memory leaks</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于宏的两点：</p><ol><li><p>特殊符号 <code>#</code> 和 <code>##</code> </p><p><code>#</code> ： 预处理时，将<code>#</code>后连接的实参字符串化</p><p><code>##</code> ：一种分隔连接方式，它的作用是先分隔，然后进行强制连接。在普通的宏定义中，预处理器一般把空格解释成分段标志，对于每一段和前面比较，相同的就被替换。但是这样做的结果是，被替换段之间存在一些空格。如果我们不希望出现这些空格，就可以通过添加一些<code>##</code>来替代空格。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE1(type,name)   type name_##type##_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE2(type,name)   type name##_##type##_type</span><br><br><span class="hljs-built_in">TYPE1</span>(<span class="hljs-type">int</span>, c); <span class="hljs-comment">// int 　name_int_type; (因为##号将后面分为 name_ 、type 、 _type三组，替换后强制连接)</span><br><span class="hljs-built_in">TYPE2</span>(<span class="hljs-type">int</span>, d); <span class="hljs-comment">// int 　d_int_type;    (因为##号将后面分为 name、_、type 、_type四组，替换后强制连接)</span><br></code></pre></td></tr></table></figure></li><li><p>宏定义中的<code>do&#123; &#125;while(0)</code></p><p>使用do{…}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 测试案例的类名，替换为 test_case_TEST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TESTCASE_NAME(testcase_name) \</span><br><span class="hljs-meta">    testcase_name##_TEST</span><br><br><span class="hljs-comment">// 使用宏定义掩盖复杂的测试样例封装过程，把 TEXT 中的测试案例放到单元测试中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYTINYSTL_TEST_(testcase_name)                        \</span><br><span class="hljs-meta">class TESTCASE_NAME(testcase_name) : public TestCase &#123;        \</span><br><span class="hljs-meta">public:                                                       \</span><br><span class="hljs-meta">    TESTCASE_NAME(testcase_name)(const char* case_name)       \</span><br><span class="hljs-meta">        : TestCase(case_name) &#123;&#125;;                             \</span><br><span class="hljs-meta">    virtual void Run();                                       \</span><br><span class="hljs-meta">private:                                                      \</span><br><span class="hljs-meta">    static TestCase* const testcase_;                         \</span><br><span class="hljs-meta">&#125;;                                                            \</span><br><span class="hljs-meta">                                                              \</span><br><span class="hljs-meta">TestCase* const TESTCASE_NAME(testcase_name)                  \</span><br><span class="hljs-meta">    ::testcase_ = UnitTest::GetInstance()-&gt;RegisterTestCase(  \</span><br><span class="hljs-meta">        new TESTCASE_NAME(testcase_name)(#testcase_name));    \</span><br><span class="hljs-meta">void TESTCASE_NAME(testcase_name)::Run()</span><br><br><span class="hljs-comment">// 简单测试的宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST(testcase_name) \</span><br><span class="hljs-meta">  MYTINYSTL_TEST_(testcase_name)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Run()后边没有写实现，是为了用宏定义将测试用例放入到 Run 的实现里，例如：</span><br><span class="hljs-comment">TEST(AddTestDemo)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">EXPECT_EQ(3, Add(1, 2));</span><br><span class="hljs-comment">EXPECT_EQ(2, Add(1, 1));</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">上述代码将 &#123; EXPECT_EQ(3, Add(1, 2)); EXPECT_EQ(2, Add(1, 1)); &#125; 接到 Run() 的后面</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>预处理阶段，上述代码在<code>TEST</code> 处展开后，<code>TEST</code> 后面<code>&#123;...&#125;</code> 的内容将拼接到 <code>Run()</code> 后，成为<code>Run()</code> 的实现。</p><p><code>MYTINYSTL_TEST_(testcase_name)</code> 展开后声明一个名为 <code>testcase_name_TEST</code> 的类（<code>testcase_name</code> 是形参），13行声明了一个静态指针常量成员，指向一个测试用例，16行对该静态成员进行定义，并将其加入到用例集合中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/qq_40571533/article/details/102558371?spm=1001.2014.3001.5502">MyTinySTL阅读笔记—概述_xiaoxiao涛的博客-CSDN博客_mytinystl源码分析</a></p><p>[2] <a href="https://github.com/Alinshans/MyTinySTL">Alinshans&#x2F;MyTinySTL: Achieve a tiny STL in C++11 (github.com)</a></p><p>[3] <a href="https://github.com/Alinshans/MyTinySTL/wiki">Home · Alinshans&#x2F;MyTinySTL Wiki (github.com)</a></p><p>[4] <a href="https://www.cnblogs.com/Anker/p/3418792.html">C语言宏高级用法 总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中虚函数、虚继承内存模型</title>
    <link href="/posts/3e911f6d/"/>
    <url>/posts/3e911f6d/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>转自：<a href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p>          </div><blockquote><p>C++中虚函数、虚继承的内存模型是一个经典问题，其实现依赖于编译器，但其主要原理大体相同。本文以问题导向的方式，详细介绍了g++中虚函数和虚继承的内存模型及其原理。</p></blockquote><h1 id="1-多态类型"><a href="#1-多态类型" class="headerlink" title="1 多态类型"></a>1 多态类型</h1><p>在C++中，多态类型是指声明或者继承了至少一个虚函数的类型，反之则为非多态类型。<br>对于非多态类型的变量，其类型信息都可以在编译时确定。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br>...<br><br>A a;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>();  <span class="hljs-comment">// 可以在编译时确定a的类型为A</span><br>a.<span class="hljs-built_in">foo</span>();     <span class="hljs-comment">// 可以在编译时确定A::foo在内存中的地址</span><br><span class="hljs-built_in">sizeof</span>(a);   <span class="hljs-comment">// 尽管A为空，但由于需要在内存中确定a的地址，因此A类型对象所占空间为1个字节</span><br></code></pre></td></tr></table></figure><p>而对于多态类型，一些信息必须延迟到运行时才可以确定，例如它的实际类型、所调用的虚函数的地址等。下面的这个例子中，类型<code>B</code>继承了声明有虚函数的类型<code>A</code>，因此<code>A</code>和<code>B</code>都是多态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 声明虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-comment">// 隐式继承了虚函数</span><br>&#125;;<br><br>...<br><br>B b&#123;&#125;;<br>A&amp; a_rb = b; <span class="hljs-comment">// 将b绑定到A的左值引用a_rb上</span><br><br><span class="hljs-built_in">typeid</span>(<span class="hljs-keyword">decltype</span>(a_rb)).<span class="hljs-built_in">name</span>(); <span class="hljs-comment">// decltype产生的是编译时即可确定的声明类型，因此为A</span><br><span class="hljs-built_in">typeid</span>(a_rb).<span class="hljs-built_in">name</span>()；  <span class="hljs-comment">// 由于a_rb是多态类型的glvalue，typeid在运行时计算，因此为B</span><br><br>a_rb.<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// 这里调用的是B中的foo，其函数地址是运行时确定的</span><br><span class="hljs-built_in">sizeof</span>(b);   <span class="hljs-comment">// 这里的sizeof是编译器决定的，通常为8 (64位)</span><br></code></pre></td></tr></table></figure><h1 id="2-虚函数的内存模型"><a href="#2-虚函数的内存模型" class="headerlink" title="2 虚函数的内存模型"></a>2 虚函数的内存模型</h1><p>我们可以用基类型<code>A</code>的引用或者指针持有实际类型为派生类<code>B</code>的对象，这意味着，编译时我们无法通过其声明类型来确定其实际类型，也就无法确定应该调用哪个具体的虚函数。考虑到程序中的每个函数都在内存中有着唯一的地址，我们可以将具体函数的地址作为成员变量，存放在对象之中，这样就可以在运行时，通过访问这个成员变量，获取到实际类型虚函数的地址。</p><h2 id="2-1-单继承内存模型"><a href="#2-1-单继承内存模型" class="headerlink" title="2.1 单继承内存模型"></a>2.1 单继承内存模型</h2><p>现代的C++编译器都采用了<strong>表格驱动</strong>的对象模型。具体来说，对于每一个多态类型，其所有的虚函数的地址都以一个表格的方式存放在一起，每个函数的偏移量在基类型和导出类型中均相同，这使得虚函数相对于表格首地址的偏移量在可以在编译时确定。虚函数表格的首地址储存在每一个对象之中，称为虚(表)指针(vptr)或者虚函数指针(vfptr)，这个虚指针始终位于对象的起始地址。使用多态类型的引用或指针调用虚函数时，首先通过虚指针和偏移量计算出虚函数的地址，然后进行调用。<br>例如，有如下所示的类型<code>A</code>和<code>B</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;; <span class="hljs-comment">// 重写f0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>它们的对象模型和虚表模型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br> <span class="hljs-function">object                                            A <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 - vptr_A --------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 - <span class="hljs-type">int</span> ax                                    |    <span class="hljs-title">A::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +--------------+</span><br><span class="hljs-function">                                                   |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function"></span><br><span class="hljs-function">struct B</span><br><span class="hljs-function"> object                                         </span><br><span class="hljs-function">     <span class="hljs-number">0</span> - struct A                                  B VTable (不完整)</span><br><span class="hljs-function">     <span class="hljs-number">0</span> -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     <span class="hljs-number">8</span> -   int ax                                  |    B::f0()   |</span><br><span class="hljs-function">    <span class="hljs-number">12</span> - int bx                                    +--------------+</span><br><span class="hljs-function">sizeof(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>注意到，由于<code>B</code>重写了方法<code>f0()</code>，因此它的虚表在同样的位置，将<code>A::f0()</code>覆盖为<code>B::f0()</code>。当发生<code>f0()</code>函数调用时，对于实际类型为<code>A</code>的对象，其VTable偏移量为<code>offset0</code>的位置为<code>A::f0()</code>， 对于实际类型为<code>B</code>的对象，对应位置为<code>B::f0()</code>，这样就实现了运行时虚函数函数地址的正确选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>B b;<br>A &amp;a_ra = a;<br>A &amp;a_rb = b;<br>a_ra.<span class="hljs-built_in">f0</span>(); <span class="hljs-comment">// call (a_ra-&gt;vptr_A + offset0) --&gt; A::f0()</span><br>a_rb.<span class="hljs-built_in">f0</span>(); <span class="hljs-comment">// call (a_rb-&gt;vptr_A + 0ffset0) --&gt; B::f0()</span><br></code></pre></td></tr></table></figure><p>在以上的例子中，<code>B</code>中虚函数都已经在<code>A</code>中声明过，如果类型<code>B</code>中出现了基类型<code>A</code>中没有的虚函数，新的虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。例如<code>B</code>中新增加了函数<code>f2()</code>，虚函数表变化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br> object                                         <br>     <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                                  <span class="hljs-function">B <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 -   <span class="hljs-type">int</span> ax                                  |    <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function">    12 - <span class="hljs-type">int</span> bx                                    +--------------+</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function">                                                   |    B::f2()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time Type Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前，所示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                                          <span class="hljs-function">B <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function"> object                                            +--------------+</span><br><span class="hljs-function">     0 - <span class="hljs-keyword">struct</span> A                                  |  RTTI <span class="hljs-keyword">for</span> B  |</span><br><span class="hljs-function">     0 -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 -   <span class="hljs-type">int</span> ax                                  |    <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function">    12 - <span class="hljs-type">int</span> bx                                    +--------------+</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function">                                                   |    B::f2()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>现在的虚表中，不仅含有函数地址，还含有RTTI的地址，之后还会加入许多新项目。虚表中的每一项都称作一个实体(entity)。<br>上述的解决方案，可以很好的处理单链继承的情况。在单链继承中，每一个派生类型都包含了其基类型的数据以及虚函数，这些虚函数可以按照继承顺序，依次排列在同一张虚表之中，因此只需要一个虚指针即可。并且由于每一个派生类都包含它的直接基类，且没有第二个直接基类，因此其数据在内存中也是线性排布的，这意味着实际类型与它所有的基类型都有着相同的起始地址。例如，<code>B</code>继承<code>A</code>，<code>C</code>继承<code>B</code>，它们的定义和内存模型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">int</span> cx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>内存模型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                      C VTable（不完整)<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                                              +------------+<br>object                                                | RTTI <span class="hljs-keyword">for</span> C |<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                            +-------&gt; +------------+<br>    <span class="hljs-number">0</span> -   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                          |         |   C::<span class="hljs-built_in">f0</span>()  |<br>    <span class="hljs-number">0</span> -     vptr_A -------------------------+         +------------+<br>    <span class="hljs-number">8</span> -     <span class="hljs-type">int</span> ax                                    |   B::<span class="hljs-built_in">f1</span>()  |<br>   <span class="hljs-number">12</span> -   <span class="hljs-type">int</span> bx                                      +------------+<br>   <span class="hljs-number">16</span> - <span class="hljs-type">int</span> cx                                        |   C::<span class="hljs-built_in">f2</span>()  |<br><span class="hljs-built_in">sizeof</span>(C): <span class="hljs-number">24</span>    align: <span class="hljs-number">8</span>                             +------------+<br></code></pre></td></tr></table></figure><p>从上图可以看出，使用一个类型<code>A</code>或<code>B</code>的引用持有实际类型为<code>C</code>的对象，它的起始地址仍然指向<code>C</code>的起始地址，这意味着单链继承的情况下，动态向下转换和向上转换时，不需要对this指针的地址做出任何修改，只需要对其重新“解释”。<br>然而，并非所有派生类都是单链继承的，它们的起始地址和其基类的起始地址不一定始终相同。</p><h2 id="2-2-多继承内存模型"><a href="#2-2-多继承内存模型" class="headerlink" title="2.2 多继承内存模型"></a>2.2 多继承内存模型</h2><p>假设类型<code>C</code>同时继承了两个独立的基类<code>A</code>和<code>B</code>， 它们的定义关系如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-type">int</span> bx;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">int</span> cx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>与单链继承不同，由于<code>A</code>和<code>B</code>完全独立，它们的虚函数没有顺序关系，即<code>f0</code>和<code>f1</code>有着相同对虚表起始位置的偏移量，不可以顺序排布。 并且<code>A</code>和<code>B</code>中的成员变量也是无关的，因此基类间也不具有包含关系。这使得<code>A</code>和<code>B</code>在<code>C</code>中必须要处于两个不相交的区域中，同时需要有两个虚指针分别对它们虚函数进行索引。 其内存布局如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                <span class="hljs-function">C <span class="hljs-title">Vtable</span> <span class="hljs-params">(<span class="hljs-number">7</span> entities)</span></span><br><span class="hljs-function">                                                +--------------------+</span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> C                                        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span>  |</span><br><span class="hljs-function">object                                          +--------------------+</span><br><span class="hljs-function">    0 - <span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-params">(primary base)</span>                 |     RTTI <span class="hljs-keyword">for</span> C     |</span><br><span class="hljs-function">    0 -   vptr_A -----------------------------&gt; +--------------------+       </span><br><span class="hljs-function">    8 -   <span class="hljs-type">int</span> ax                                |       <span class="hljs-title">C::f0</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   16 - <span class="hljs-keyword">struct</span> B                                +--------------------+</span><br><span class="hljs-function">   16 -   vptr_B ----------------------+        |       <span class="hljs-title">C::f1</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   24 -   <span class="hljs-type">int</span> bx                       |        +--------------------+</span><br><span class="hljs-function">   28 - <span class="hljs-type">int</span> cx                         |        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">-16</span>)</span>|</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(C)</span>: <span class="hljs-number">32</span>    align: <span class="hljs-number">8</span>              |        +--------------------+</span><br><span class="hljs-function">                                       |        |     RTTI for C     |</span><br><span class="hljs-function">                                       +------&gt; +--------------------+</span><br><span class="hljs-function">                                                |    Thunk C::f1()   |</span><br><span class="hljs-function">                                                +--------------------+</span><br></code></pre></td></tr></table></figure><p>在上图所示的布局中，<code>C</code>将<code>A</code>作为主基类，也就是将它虚函数“并入”<code>A</code>的虚函数表之中，并将<code>A</code>的虚指针作为<code>C</code>的内存起始地址。<br>而类型<code>B</code>的虚指针<code>vptr_B</code>并不能直接指向虚表中的第4个实体，这是因为<code>vptr_B</code>所指向的虚表区域，在格式上必须也是一个完整的虚表。因此，需要为<code>vptr_B</code>创建对应的虚表放在虚表A的部分之后 。<br>在上图中，出现了两个“新”的实体，一个是<code>offset_to_top</code>，另一个是<code>Thunk</code>。<br>在多继承中，由于不同的基类起点可能处于不同的位置，因此当需要将它们转化为实际类型时，<code>this</code>指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体<code>offset_to_top</code>表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让<code>this</code>指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体<code>offset_to_top</code>也会存在于每一个多态类型之中。<br>而实体<code>Thunk</code>又是什么呢？如果不考虑这个<code>Thunk</code>，这里应该存放函数<code>C::f1()</code>的地址。然而，dump虚表可以看到，<code>Thunk C::f1()</code>和<code>C::f1()</code>的地址并不一样。<br>为了弄清楚<code>Thunk</code>是什么，我们首先要注意到，如果一个类型<code>B</code> 的引用持有了实际类型为<code>C</code>的变量，这个引用的起始地址在<code>C+16</code>处。当它调用由类型<code>C</code>重写的函数<code>f1()</code>时，如果直接使用<code>this</code>指针调用<code>C::f1()</code>会由于<code>this</code>指针的地址多出16字节的偏移量导致错误。 因此在调用之前，this指针必须要被调整至正确的位置 。这里的<code>Thunk</code>起到的就是这个作用：首先将<code>this</code>指针调整到正确的位置，即减少16字节偏移量，然后再去调用函数<code>C::f1()</code>。</p><h2 id="2-3-构造与析构过程"><a href="#2-3-构造与析构过程" class="headerlink" title="2.3 构造与析构过程"></a>2.3 构造与析构过程</h2><p>在多态类型的构造和析构过程中，所调用的虚函数并不是最终的实际类型的对应函数，而是当前已经创建了的(或尚未析构的)类型的对应函数。这句话比较绕口，我们通过一个例子来说明。如下所示的两个类型<code>A</code>和<code>B</code>， 它们在构造和析构时都会调用对应的虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">B</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br><br>    ~<span class="hljs-built_in">B</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">// 输出：ABBA</span><br></code></pre></td></tr></table></figure><p>运行上述程序，可以得到输出“ABBA”，表明程序依次调用了<code>A::A()</code>、<code>B::B()</code>、<code>B::~B()</code>、<code>A::~A()</code>。直观上理解，在构造<code>A</code>时，<code>B</code>中的数据还没有创建，因此B重写的虚函数当然不可使用，因此应该调用<code>A</code>中的版本；反过来，析构的时候，由于<code>B</code>先析构，在<code>B</code>析构之后，<code>B</code>中的函数当然也不可用，因此也应该调用<code>A</code>中的版本。<br>在程序运行中，这一过程是通过动态的修改对象的虚指针实现的。<br>根据C++中继承类的构造顺序，首先基类<code>A</code>被构造。在构造<code>A</code>时， 对象自身的虚指针指向<code>A</code>的虚表。由于<code>A</code>的虚表中，<code>f0()</code>的位置保存着<code>A::f0()</code>的地址，因此<code>A::f0()</code>被调用。在<code>A</code>的构造结束后，<code>B</code>的构造启动，此时虚指针被修改为指向<code>B</code>的虚表。析构过程与此相反。</p><h1 id="3-虚继承内存模型"><a href="#3-虚继承内存模型" class="headerlink" title="3 虚继承内存模型"></a>3 虚继承内存模型</h1><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。<br>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p><h2 id="3-1-菱形继承的内存模型"><a href="#3-1-菱形继承的内存模型" class="headerlink" title="3.1 菱形继承的内存模型"></a>3.1 菱形继承的内存模型</h2><p>下面展示了一个经典的菱形虚继承关系，为了避免重复包含<code>A</code>中的成员，类型<code>B</code>和<code>C</code>分别虚继承<code>A</code>。类型<code>D</code>继承了<code>B</code>和<code>C</code>。依据其继承方式的不同，<code>D</code>中的<code>B</code>、<code>C</code>的偏移量可以在编译时确定，而<code>A</code>的偏移量在运行时确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/****************************/</span><br>&#123;                                     <span class="hljs-comment">/*                          */</span><br>    <span class="hljs-type">int</span> bx;                           <span class="hljs-comment">/*             A            */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*           v/ \v          */</span><br>&#125;;                                    <span class="hljs-comment">/*           /   \          */</span> <br>                                      <span class="hljs-comment">/*          B     C         */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/*           \   /          */</span><br>&#123;                                     <span class="hljs-comment">/*            \ /           */</span><br>    <span class="hljs-type">int</span> cx;                           <span class="hljs-comment">/*             D            */</span> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*                          */</span><br>&#125;;                                    <span class="hljs-comment">/****************************/</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-type">int</span> dx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先对类型<code>A</code>的内存模型进行分析。由于虚继承影响的是子类，不会对父类造成影响，因此A的内存布局和虚表都没有改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                   A VTable<br>                                                   +------------------+<br>                                                   | <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>) |<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                                           +------------------+<br> object                                            |    RTTI <span class="hljs-keyword">for</span> A    |<br>     <span class="hljs-number">0</span> - vptr_A --------------------------------&gt;  +------------------+<br>     <span class="hljs-number">8</span> - <span class="hljs-type">int</span> ax                                    |      A::<span class="hljs-built_in">f0</span>()     |<br><span class="hljs-built_in">sizeof</span>(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +------------------+<br>                                                   |      A::<span class="hljs-built_in">bar</span>()    |<br>                                                   +------------------+<br></code></pre></td></tr></table></figure><p>类型<code>B</code>类和类型<code>C</code>没有本质的区别，因此只分析类型<code>B</code>。下图为类型B的内存模型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          B VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">16</span>)  |<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                                  +---------------------+<br>object                                    |      RTTI <span class="hljs-keyword">for</span> B     |<br>    <span class="hljs-number">0</span> - vptr_B -------------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> - <span class="hljs-type">int</span> bx                            |       B::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_A --------------+          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> ax               |          +---------------------+         |<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-16</span>) |o----+   |<br>                               |          +---------------------+     |   |<br>                               |          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-16</span>) |     |   |<br>                               |          +---------------------+     |   |<br>                               |          |      RTTI <span class="hljs-keyword">for</span> B     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+</span><br></code></pre></td></tr></table></figure><p>对于形式类型为<code>B</code>的引用，在编译时，无法确定它的基类<code>A</code>它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为<strong>vbase_offset</strong>，位于<strong>offset_to_top</strong>上方。<br>除此之外，如果在<code>B</code>中调用<code>A</code>声明且<code>B</code>没有重写的函数，由于<code>A</code>的偏移量无法在编译时确定，而这些函数的调用由必须在<code>A</code>的偏移量确定之后进行， 因此这些函数的调用相当于使用<code>A</code>的引用调用。也因此，当使用虚基类<code>A</code>的引用调用重载函数时 ，每一个函数对<code>this</code>指针的偏移量调整都可能不同，它们被记录在镜像位置的<code>vcall_offset</code>中。例如，调用<code>A::bar()</code>时，<code>this</code>指针指向的是<code>vptr_A</code>，正是函数所属的类<code>A</code>的位置，因此不需要调整，即<code>vcall_offset(0)</code>；而<code>B::f0()</code>是由类型<code>B</code>实现的， 因此需要将<code>this</code>指针向前调整<code>16</code>字节。<br>对于类型<code>D</code>，它的虚表更为复杂，但虚表中的实体我们都已熟悉。 以下为<code>D</code>的内存模型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          D VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">32</span>)  |<br>                                          +---------------------+<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>                                  |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br>object                                    +---------------------+<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> (primary base)           |      RTTI <span class="hljs-keyword">for</span> D     |<br>    <span class="hljs-number">0</span> -   vptr_B  ----------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> -   <span class="hljs-type">int</span> bx                          |       D::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_C  ------------------+     |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">16</span>)  |<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> cx                    |     +---------------------+<br>   <span class="hljs-number">28</span> - <span class="hljs-type">int</span> dx                      |     |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-16</span>) |<br>   <span class="hljs-number">32</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> (<span class="hljs-keyword">virtual</span> base)     |     +---------------------+<br>   <span class="hljs-number">32</span> -   vptr_A --------------+    |     |      RTTI <span class="hljs-keyword">for</span> D     |<br>   <span class="hljs-number">40</span> -   <span class="hljs-type">int</span> ax               |    +---&gt; +---------------------+<br><span class="hljs-built_in">sizeof</span>(D): <span class="hljs-number">48</span>    align: <span class="hljs-number">8</span>      |          |       D::<span class="hljs-built_in">f0</span>()       |<br>                               |          +---------------------+<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>                               |          +---------------------+         |<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-32</span>) |o----+   |<br>                               |          +---------------------+     |   |<br>                               |          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-32</span>) |     |   |<br>                               |          +---------------------+     |   |<br>                               |          |      RTTI <span class="hljs-keyword">for</span> D     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">D::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+ </span><br></code></pre></td></tr></table></figure><h2 id="3-2-析构过程"><a href="#3-2-析构过程" class="headerlink" title="3.2 析构过程"></a>3.2 析构过程</h2><p>与非虚继承相似，通过虚继承产生的派生类在构造和析构时，所调用的虚函数只是当前阶段的的虚表中对应的函数。一个问题也就由此产生，由于在虚基类的不同的派生类中，虚基类相对于该类型的偏移量是可以不同的，如果直接使用2.3中的方法，直接用继承虚基类的类型自身的虚表作为构建该类时使用的虚表，会由于偏移量的不同，导致无法正确获取虚基类中的对象。<br>这个描述比较抽象拗口，我们通过3.1中的菱形继承的例子进行解释。四个类型<code>A</code>，<code>B</code>，<code>C</code>和<code>D</code>的继承关系如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/****************************/</span><br>&#123;                                     <span class="hljs-comment">/*                          */</span><br>    <span class="hljs-type">int</span> bx;                           <span class="hljs-comment">/*             A            */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*           v/ \v          */</span><br>&#125;;                                    <span class="hljs-comment">/*           /   \          */</span><br>                                      <span class="hljs-comment">/*          B     C         */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/*           \   /          */</span><br>&#123;                                     <span class="hljs-comment">/*            \ /           */</span><br>    <span class="hljs-type">int</span> cx;                           <span class="hljs-comment">/*             D            */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;              <span class="hljs-comment">/*                          */</span><br>&#125;;                                    <span class="hljs-comment">/****************************/</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-type">int</span> dx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>观察实际类型为<code>B</code>和实际类型为<code>D</code>对象的内存布局可以发现，如果实际类型为<code>B</code>，虚基类A对B的首地址的偏移量为16；若实际类型为<code>D</code>，则其中A对B首地址的偏移量为32。这明显与<code>B</code>自身的虚表冲突。如果构建<code>D::B</code>时还采用的是<code>B</code>自身的虚表，会由于偏移量的不同导致错误。<br>这一问题的解决方法其实很粗暴，那就是在对象构造、析构阶段，会用到多少种虚表，会用到多少种虚指针就生成多少种虚指针。在构造或析构时，“按需分配”。<br>例如，这里的类型<code>D</code>是类型<code>B</code>和<code>C</code>的子类，而<code>B</code>和<code>C</code>虚继承了类型<code>A</code>。 这种继承关系会导致<code>D</code>内部含有的<code>B</code>(称作<code>B-in-D</code>)、<code>C</code>(称作<code>C-in-D</code>)的虚表与<code>B</code>、<code>C</code>的虚表不同。 因此，这需要生成两张新的虚表，即<code>B-in-D</code>和<code>C-in-D</code>的虚表。<br>由于<code>B-in-D</code>也是<code>B</code>类型的一种布局，<code>B</code>的一个虚表对应两个虚指针，分别是<code>vptr_B</code>和<code>vptr_A</code>，因此它也有两个着两个虚指针。在构造或析构<code>D::B</code>时，其对象的内存布局和虚表布局如图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          B-in-D VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">32</span>)  |<br>                                          +---------------------+<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> (Constructing/Deconstructing B)  |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br>object                                    +---------------------+<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> (primary base)           |      RTTI <span class="hljs-keyword">for</span> B     |<br>    <span class="hljs-number">0</span> -   vptr_B -----------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> -   <span class="hljs-type">int</span> bx                          |       B::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_C                          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> cx                          +---------------------+         |<br>   <span class="hljs-number">28</span> - <span class="hljs-type">int</span> dx                            |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-32</span>) |o----+   |<br>   <span class="hljs-number">32</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> (<span class="hljs-keyword">virtual</span> base)           +---------------------+     |   |<br>   <span class="hljs-number">32</span> -   vptr_A --------------+          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-32</span>) |     |   |<br>   <span class="hljs-number">40</span> -   <span class="hljs-type">int</span> ax               |          +---------------------+     |   |<br><span class="hljs-built_in">sizeof</span>(D): <span class="hljs-number">48</span>    align: <span class="hljs-number">8</span>      |          |      RTTI <span class="hljs-keyword">for</span> B     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+</span><br></code></pre></td></tr></table></figure><p>同样的，在<code>C-in-D</code>中也会有两个虚指针，分别是<code>vptr_C</code>和<code>vptr_A</code>。此外，在最终的<code>D</code>中还有三个虚指针，总计7个不同的虚指针，它们指向3张虚表的7个不同位置。因此编译器为类型D总共生成了3个不同的虚表，和7个不同的虚指针。将这7个虚指针合并到一个表中，这个表就是**虚表的表(Virtual Table Table, VTT)**。显然，只有当一个类的父类是继承了虚基类的类型时，编译器才会为它创建VTT。<br>在构造和析构过程中，子类的构造函数或析构函数向基类传递一个合适的、指向VTT某个部分指针，使得父类的构造函数或析构函数获取到正确的虚表。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ul><li>虚函数地址通过虚指针索引的虚函数表在运行时确定；</li><li>虚表中不仅储存了虚函数的地址，还储存了类型<code>RTTI</code>的地址、距实际类型首地址偏移量等信息；</li><li>虚函数的调用可能涉及到<code>this</code>指针的变更，需要<code>Thunk</code>等方式实现；</li><li>对于虚基类的派生类，虚基类的偏移量由实际类型决定，因此在<strong>运行时才可以确定虚基类的地址</strong>；</li><li>在多态类型的构造和析构过程中，通过修改虚指针使其指向不同的虚表，可以实现在不同的阶段调用不同的虚函数；</li><li>对于虚继承的情况，由于同一类型虚表的虚表在不同具体类型中可以不同，在构造和析构时，需要通过<code>VTT</code>传递正确的虚表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>类相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/4a17b156/"/>
    <url>/posts/4a17b156/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
