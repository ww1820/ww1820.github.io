<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WebSever 环境配置</title>
    <link href="/posts/cbaa05f8/"/>
    <url>/posts/cbaa05f8/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器-WebSever-环境配置问题记录"><a href="#Linux服务器-WebSever-环境配置问题记录" class="headerlink" title="Linux服务器 WebSever 环境配置问题记录"></a>Linux服务器 WebSever 环境配置问题记录</h1><h2 id="vscode-连接远程服务器"><a href="#vscode-连接远程服务器" class="headerlink" title="vscode 连接远程服务器"></a>vscode 连接远程服务器</h2><p>下载 Remote-SSH 插件配置连接。</p><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>本地电脑cmd输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br></code></pre></td></tr></table></figure><p>将生成的公钥复制到云服务器的<code>~/.ssh/authorized_keys</code> 里</p><h2 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h2><p>sudo apt-get install mysql-server<br>apt-get isntall mysql-client<br>sudo apt-get install libmysqlclient-dev</p><p>sudo mysql -u root -p</p><p>修改密码</p><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’</p><p>flush privileges;</p><h2 id="解决-github-Permission-denied-publickey"><a href="#解决-github-Permission-denied-publickey" class="headerlink" title="解决 github Permission denied (publickey)"></a>解决 github Permission denied (publickey)</h2><ol><li>如果没有ssh key 的话，输入命令：ssh-keygen -t <a href="https://so.csdn.net/so/search?q=rsa&spm=1001.2101.3001.7020">rsa</a> -C “<a href="mailto:&#x78;&#120;&#64;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#120;&#64;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a>“</li><li>打开刚刚生成的id_rsa.pub，将里面的内容复制，进入github在settings下，SSH and GPG keys下new SSH key，title随便取一个名字，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 多进程开发（2）</title>
    <link href="/posts/d87f7e0c/"/>
    <url>/posts/d87f7e0c/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-多进程开发（2）——-进程间通信"><a href="#Linux-多进程开发（2）——-进程间通信" class="headerlink" title="Linux 多进程开发（2）—— 进程间通信"></a>Linux 多进程开发（2）—— 进程间通信</h1><h2 id="进程间通信简介"><a href="#进程间通信简介" class="headerlink" title="进程间通信简介"></a>进程间通信简介</h2><p><strong>进程是一个独立的资源分配单元</strong>，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信(IPC: Inter Processes Communication )。</p><p>进程间通信的目的：</p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程。</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li><li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供<strong>互斥和同步</strong>机制。</li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840928.png" alt="Linux 进程间通信的方式"></p><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。<br>统计一个目录中文件的数目命令：ls | wc -l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。<code>|</code> 就是一个匿名管道</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840845.png" alt="管道"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840865.png" alt="使用管道进行进程间通信"></p><p>管道的特点：</p><ul><li>管道其实是一个在<strong>内核内存中维护的缓冲器</strong>，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。</li><li>管道拥有文件的特质：读操作、写操作，<strong>匿名管道没有文件实体</strong>，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</li><li>一个管道是一个<strong>字节流</strong>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</li><li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。</li><li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，<strong>管道是半双工的</strong>。</li><li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。</li><li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li></ul><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840924.png" alt="管道缓冲区"></p><p>管道的数据结构：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840036.png" alt="管道的数据结构：环形队列"></p><h3 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int pipe(int pipefd[2]);</span><br><span class="hljs-comment">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="hljs-comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="hljs-comment">            pipefd[0] 对应的是管道的读端</span><br><span class="hljs-comment">            pipefd[1] 对应的是管道的写端</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    查看管道缓冲大小的函数：</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">long size = fpathconf(pipefd[0], _PC_PIPE_BUF);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 子进程发送数据给父进程，父进程读取到数据输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <br>        <span class="hljs-comment">// 从管道的读取端读取数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());<br>            <br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-comment">//char * str = &quot;hello,i am parent&quot;;</span><br>            <span class="hljs-comment">//write(pipefd[1], str, strlen(str));</span><br>            <span class="hljs-comment">//sleep(1);</span><br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>            <span class="hljs-comment">//sleep(1);</span><br><br>            <span class="hljs-comment">// int len = read(pipefd[0], buf, sizeof(buf));</span><br>            <span class="hljs-comment">// printf(&quot;child recv : %s, pid : %d\n&quot;, buf, getpid());</span><br>            <span class="hljs-comment">// bzero(buf, 1024);</span><br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管道的读写特点"><a href="#管道的读写特点" class="headerlink" title="管道的读写特点"></a>管道的读写特点</h3><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I&#x2F;O操作）</p><ol><li><p>所有的指向管道写端的文件描述符都关闭了（管道<strong>写端引用计数为0</strong>），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次<strong>read会返回0</strong>，就像读到文件末尾一样。</p></li><li><p>如果有指向管道写端的文件描述符没有关闭（管道的<strong>写端引用计数大于0</strong>），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次<strong>read会阻塞</strong>，直到管道中有数据可以读了才读取数据并返回。</p></li><li><p>如果所有指向管道读端的文件描述符都关闭了（管道的<strong>读端引用计数为0</strong>），这个时候有进程向管道中写数据，那么该进程会收到一个信号 <strong>SIGPIPE</strong> ，通常会导致进程异常终止。</p></li><li><p>如果有指向管道读端的文件描述符没有关闭（管道的<strong>读端引用计数大于0</strong>），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次<strong>write会阻塞</strong>，直到管道中有空位置才能再次写入数据并返回。</p></li></ol><p>总结：</p><ul><li><p>读管道：</p><ul><li>管道中有数据，read返回实际读到的字节数。</li><li>管道中无数据：<ul><li>写端被全部关闭，read返回0（相当于读到文件的末尾）</li><li>写端没有完全关闭，read阻塞等待</li></ul></li></ul></li><li><p>写管道：</p><ul><li>管道读端全部被关闭，进程异常终止（进程收到 SIGPIPE 信号）</li><li>管道读端没有全部关闭：<ul><li>管道已满，write阻塞</li><li>管道没有满，write将数据写入，并返回实际写入的字节数</li></ul></li></ul></li></ul><h3 id="设置管道非阻塞"><a href="#设置管道非阻塞" class="headerlink" title="设置管道非阻塞"></a>设置管道非阻塞</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改文件属性</span><br>        <span class="hljs-type">int</span> flags = fcntl(pipefd[<span class="hljs-number">0</span>], F_GETFL);  <span class="hljs-comment">// 获取原来的flag</span><br>        flags |= O_NONBLOCK;            <span class="hljs-comment">// 修改flag的值</span><br>        fcntl(pipefd[<span class="hljs-number">0</span>], F_SETFL, flags);   <span class="hljs-comment">// 设置新的flag</span><br></code></pre></td></tr></table></figure><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><ol><li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。</li><li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</li><li>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</li><li>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li></ol><h3 id="有名管道（FIFO）-vs-匿名管道（PIPE"><a href="#有名管道（FIFO）-vs-匿名管道（PIPE" class="headerlink" title="有名管道（FIFO） vs. 匿名管道（PIPE)"></a>有名管道（FIFO） vs. 匿名管道（PIPE)</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840941.png" alt="有名管道（FIFO） vs. 匿名管道（PIPE)"></p><h3 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h3><div class="note note-warning">            <p>有名管道的注意事项：</p><pre><code class="hljs">1. 一个以只读方式打开管道的进程会阻塞，直到另外一个进程以可写方式打开该管道；2. 一个以只写方式打开管道的进程会阻塞，直到另外一个进程以可读方式打开该管道。</code></pre>          </div><ol><li>写进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建fifo文件</span><br><span class="hljs-comment">    1.通过命令： mkfifo 名字</span><br><span class="hljs-comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 管道名称的路径</span><br><span class="hljs-comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="hljs-comment">                    是一个八进制的数</span><br><span class="hljs-comment">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 向管道中写数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2.创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;       <br><br>    &#125;<br><br>    <span class="hljs-comment">// 3.以只写的方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    读管道：</span><br><span class="hljs-comment">        管道中有数据，read返回实际读到的字节数</span><br><span class="hljs-comment">        管道中无数据：</span><br><span class="hljs-comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="hljs-comment">            写端没有全部被关闭，read阻塞等待</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    写管道：</span><br><span class="hljs-comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="hljs-comment">        管道读端没有全部关闭：</span><br><span class="hljs-comment">            管道已经满了，write会阻塞</span><br><span class="hljs-comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol start="2"><li>读进程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 读数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接了...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用有名管道完成简单的聊天功能"><a href="#使用有名管道完成简单的聊天功能" class="headerlink" title="使用有名管道完成简单的聊天功能"></a>使用有名管道完成简单的聊天功能</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840338.png" alt="使用有名管道完成简单的聊天功能"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// client1.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br><br>    <span class="hljs-comment">// 1. 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125;<br><br>    ret = access(<span class="hljs-string">&quot;fifo2&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        ret = mkfifo(<span class="hljs-string">&quot;fifo2&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 2 .以只写的方式打开管道fifo1</span><br>    <span class="hljs-type">int</span> fdw = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fdw == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开 fifo1 成功，准备写入...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 3 .以只读的方式打开管道fifo2，非阻塞</span><br>    <span class="hljs-type">int</span> fdr = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fdr == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开 fifo2 成功，等待写入...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 4. 创建子进程，父进程写，子进程读，循环写读数据</span><br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// parent</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>            <span class="hljs-comment">// 获取标准输入的数据</span><br>            fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>            <span class="hljs-comment">// 写数据</span><br>            ret = write(fdw, buf, <span class="hljs-built_in">strlen</span>(buf));<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>                perror(<span class="hljs-string">&quot;write&quot;</span>);<br>                close(fdw);<br>                close(fdr);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// child</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>            <span class="hljs-comment">// 读数据</span><br>            ret = read(fdr, buf, <span class="hljs-number">128</span>);<br>            <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>) &#123;<br>                perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                close(fdw);<br>                close(fdr);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv: %s&quot;</span>, buf);<br>        &#125;<br>        <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        close(fdw);<br>        close(fdr);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    close(fdw);<br>    close(fdr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>client2.c</code> 代码与<code>client1.c</code>基本一致，读写的<code>fifo</code>不同。</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840340.png" alt="内存映射"></p><h3 id="内存映射的系统调用"><a href="#内存映射的系统调用" class="headerlink" title="内存映射的系统调用"></a>内存映射的系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="hljs-comment">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - void *addr: NULL, 由内核指定</span><br><span class="hljs-comment">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="hljs-comment">                    获取文件的长度：stat lseek</span><br><span class="hljs-comment">            - prot : 对申请的内存映射区的操作权限</span><br><span class="hljs-comment">                -PROT_EXEC ：可执行的权限</span><br><span class="hljs-comment">                -PROT_READ ：读权限</span><br><span class="hljs-comment">                -PROT_WRITE ：写权限</span><br><span class="hljs-comment">                -PROT_NONE ：没有权限</span><br><span class="hljs-comment">                要操作映射内存，必须要有读的权限。</span><br><span class="hljs-comment">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="hljs-comment">            - flags :</span><br><span class="hljs-comment">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="hljs-comment">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="hljs-comment">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="hljs-comment">                - 通过open得到，open的是一个磁盘文件</span><br><span class="hljs-comment">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="hljs-comment">                    prot: PROT_READ                open:只读/读写 </span><br><span class="hljs-comment">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="hljs-comment">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。</span><br><span class="hljs-comment">        - 返回值：返回创建的内存的首地址</span><br><span class="hljs-comment">            失败返回MAP_FAILED，(void *) -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int munmap(void *addr, size_t length);</span><br><span class="hljs-comment">        - 功能：释放内存映射</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - addr : 要释放的内存的首地址</span><br><span class="hljs-comment">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用内存映射实现进程间通信：</span><br><span class="hljs-comment">    1.有关系的进程（父子进程）</span><br><span class="hljs-comment">        - 还没有子进程的时候</span><br><span class="hljs-comment">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="hljs-comment">        - 有了内存映射区以后，创建子进程</span><br><span class="hljs-comment">        - 父子进程共享创建的内存映射区</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    2.没有关系的进程间通信</span><br><span class="hljs-comment">        - 准备一个大小不是0的磁盘文件</span><br><span class="hljs-comment">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 使用内存映射区通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：内存映射区通信，是非阻塞。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);  <span class="hljs-comment">// 获取文件的大小</span><br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data : %s\n&quot;</span>, buf);<br>       <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭内存映射区</span><br>    munmap(ptr, size);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h3><ol><li><p>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?<br>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p></li><li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?<br>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的<strong>权限保持一致</strong>。</p></li><li><p>如果文件偏移量为1000会怎样?<br>偏移量必须是4K的整数倍，返回MAP_FAILED</p></li><li><p>mmap什么情况下会调用失败?</p><ul><li>第二个参数：length &#x3D; 0</li></ul><pre><code class="hljs">- 第三个参数：prot      - 只指定了写权限        - prot PROT_READ | PROT_WRITE          第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY</code></pre></li><li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p><ul><li>可以的，但是创建的文件的大小如果为0的话，肯定不行<br>- 可以对新的文件进行扩展<ul><li>lseek()</li><li>truncate()</li></ul></li></ul></li><li><p>mmap后关闭文件描述符，对mmap映射有没有影响？<br>int fd &#x3D; open(“XXX”);<br>mmap(,,,,fd,0);<br>close(fd);<br>映射区还存在，创建映射区的fd被关闭，没有任何影响。</p></li><li><p>对ptr越界操作会怎样？<br>&#96;void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p></li></ol><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul><li><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为<strong>软件中断</strong>，它是在<strong>软件层次上对中断机制的一种模拟</strong>，是一种<strong>异步通信</strong>的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p></li><li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p><ul><li><p>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。</p></li><li><p>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</p></li><li><p>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。</p></li><li><p>运行 kill 命令或调用 kill 函数。</p></li></ul></li></ul><p>使用信号的两个主要目的是：</p><ul><li>让进程知道已经发生了一个特定的事情。</li><li>强迫进程执行它自己代码中的信号处理程序。</li></ul><p>信号的特点：</p><ul><li><p>简单</p></li><li><p>不能携带大量信息</p></li><li><p>满足某个特定条件才发送</p></li><li><p>优先级比较高</p></li></ul><p>查看系统定义的信号列表：kill –l </p><p>前 31 个信号为常规信号，其余为实时信号。</p><h3 id="linux-常见信号"><a href="#linux-常见信号" class="headerlink" title="linux 常见信号"></a>linux 常见信号</h3><table><thead><tr><th>编号</th><th>信号</th><th>对应事件</th><th>默认动作</th></tr></thead><tbody><tr><td>2</td><td>SIGINT</td><td>当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td><td>终止进程</td></tr><tr><td>3</td><td>SIGQUIT</td><td>用户按下&lt;Ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td><td>终止进程</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程。该信号不能被忽略，处理和阻塞</td><td>终止进程，可以杀死任何正常的进程</td></tr><tr><td>11</td><td>SIGSEGV</td><td>指示进程进行了无效内存访问(段错误)</td><td>终止进程并产生core文件</td></tr><tr><td>13</td><td>SIGPIPE</td><td>Broken pipe向一个没有读端的管道写数据</td><td>终止进程</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程结束时，父进程会收到这个信号</td><td>忽略这个信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>如果进程已停止，则使其继续运行</td><td>继续&#x2F;忽略</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程的执行。信号不能被忽略，处理和阻塞</td><td></td></tr></tbody></table><h3 id="信号的-5-种默认处理动作"><a href="#信号的-5-种默认处理动作" class="headerlink" title="信号的 5 种默认处理动作"></a>信号的 5 种默认处理动作</h3><p>查看信号的详细信息：<code>man 7 signal</code></p><ul><li><p>信号的 5 中默认处理动作：</p><ul><li><p>Term 终止进程</p></li><li><p>Ign 当前进程忽略掉这个信号</p></li><li><p>Core 终止进程，并生成一个Core文件</p></li><li><p>Stop 暂停当前进程</p></li><li><p>Cont 继续执行当前被暂停的进程</p></li></ul></li><li><p>信号的几种状态：产生、未决、递达</p></li><li><p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p></li></ul><h3 id="信号相关的函数"><a href="#信号相关的函数" class="headerlink" title="信号相关的函数"></a>信号相关的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>; <span class="hljs-comment">// linux 系统调用 </span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int kill(pid_t pid, int sig);</span><br><span class="hljs-comment">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - pid ：</span><br><span class="hljs-comment">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="hljs-comment">                = 0 : 将信号发送给当前的进程组</span><br><span class="hljs-comment">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="hljs-comment">                &lt; -1 : 将信号发送给进程组ID为-pid的所有进程</span><br><span class="hljs-comment">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        kill(getppid(), 9);</span><br><span class="hljs-comment">        kill(getpid(), 9);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>; <span class="hljs-comment">// 标准 C 库函数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int raise(int sig);</span><br><span class="hljs-comment">        - 功能：给当前进程发送信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - sig : 要发送的信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 成功 0</span><br><span class="hljs-comment">            - 失败 非0</span><br><span class="hljs-comment">        kill(getpid(), sig);   </span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// 标准 C 库函数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    void abort(void);</span><br><span class="hljs-comment">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="hljs-comment">        kill(getpid(), SIGABRT);</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    unsigned int alarm(unsigned int seconds);</span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="hljs-comment">                函数会给当前的进程发送一个信号：SIGALARM</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="hljs-comment">                    取消一个定时器，通过alarm(0)。</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 之前没有定时器，返回0</span><br><span class="hljs-comment">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="hljs-comment">        alarm(10);  -&gt; 返回0</span><br><span class="hljs-comment">        过了1秒</span><br><span class="hljs-comment">        alarm(5);   -&gt; 返回9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    实际的时间 = 内核时间 + 用户时间 + 消耗的时间</span><br><span class="hljs-comment">    进行文件IO操作的时候比较浪费时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_val, <span class="hljs-keyword">struct</span> itimerval *old_value)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/time.h&gt;</span><br><span class="hljs-comment">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="hljs-comment">                        struct itimerval *old_value);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - which : 定时器以什么时间计时</span><br><span class="hljs-comment">              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="hljs-comment">              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="hljs-comment">              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - new_value: 设置定时器的属性</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">                struct itimerval &#123;      // 定时器的结构体</span><br><span class="hljs-comment">                    struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="hljs-comment">                    struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                struct timeval &#123;        // 时间的结构体</span><br><span class="hljs-comment">                    time_t      tv_sec;     //  秒数     </span><br><span class="hljs-comment">                    suseconds_t tv_usec;    //  微秒    </span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1 并设置错误号</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="信号捕捉函数signal"><a href="#信号捕捉函数signal" class="headerlink" title="信号捕捉函数signal"></a>信号捕捉函数signal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    typedef void (*sighandler_t)(int);</span><br><span class="hljs-comment">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="hljs-comment">        - 功能：设置某个信号的捕捉行为</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum: 要捕捉的信号</span><br><span class="hljs-comment">            - handler: 捕捉到信号要如何处理</span><br><span class="hljs-comment">                - SIG_IGN ： 忽略信号</span><br><span class="hljs-comment">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="hljs-comment">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="hljs-comment">                回调函数：</span><br><span class="hljs-comment">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="hljs-comment">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="hljs-comment">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="hljs-comment">            失败，返回SIG_ERR，设置错误号</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><ul><li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</li><li>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为 “未决信号集” 。这两个信号集都是内核使用<strong>位图机制</strong>来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改（信号的状态：阻塞、未决、抵达）。</li><li>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li><li>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li><li>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li></ul><p>阻塞信号集和未决信号集例子：</p><ol><li><p>用户通过键盘  Ctrl + C， 产生2号信号SIGINT （信号被创建）</p></li><li><p>信号产生但是没有被处理 （未决）</p><ul><li>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</li><li>SIGINT信号状态被存储在第二个标志位上<ul><li>这个标志位的值为0， 说明信号不是未决状态</li><li>这个标志位的值为1， 说明信号处于未决状态</li></ul></li></ul></li><li><p>这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较</p><ul><li>阻塞信号集默认不阻塞任何的信号</li><li>如果想要阻塞某些信号需要用户调用系统的API</li></ul></li><li><p>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了</p><ul><li>如果没有阻塞，这个信号就被处理</li><li>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</li></ul></li></ol><h3 id="自定义信号集操作相关函数"><a href="#自定义信号集操作相关函数" class="headerlink" title="自定义信号集操作相关函数"></a>自定义信号集操作相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">int sigemptyset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigfillset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigaddset(sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置不阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        - 功能：判断某个信号是否阻塞</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要判断的那个信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            1 ： signum被阻塞</span><br><span class="hljs-comment">            0 ： signum不阻塞</span><br><span class="hljs-comment">            -1 ： 失败</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h3 id="内核中的信号集的相关操作"><a href="#内核中的信号集的相关操作" class="headerlink" title="内核中的信号集的相关操作"></a>内核中的信号集的相关操作</h3><p>未决信号集只能获取不能设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="hljs-comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - how : 如何对内核阻塞信号集进行处理</span><br><span class="hljs-comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="hljs-comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="hljs-comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="hljs-comment">                    mask &amp;= ~set</span><br><span class="hljs-comment">                SIG_SETMASK:覆盖内核中原来的值</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            - set ：已经初始化好的用户自定义的信号集</span><br><span class="hljs-comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">                设置错误号：EFAULT、EINVAL</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigpending(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：获取内核中的未决信号集</span><br><span class="hljs-comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="信号捕捉函数sigaction"><a href="#信号捕捉函数sigaction" class="headerlink" title="信号捕捉函数sigaction"></a>信号捕捉函数sigaction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    int sigaction(int signum, const struct sigaction *act,</span><br><span class="hljs-comment">                            struct sigaction *oldact);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="hljs-comment">            - act ：捕捉到信号之后的处理动作</span><br><span class="hljs-comment">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     struct sigaction &#123;</span><br><span class="hljs-comment">        // 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="hljs-comment">        void     (*sa_handler)(int);</span><br><span class="hljs-comment">        // 不常用</span><br><span class="hljs-comment">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="hljs-comment">        // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span><br><span class="hljs-comment">        sigset_t   sa_mask;</span><br><span class="hljs-comment">        // 使用哪一个信号处理对捕捉到的信号进行处理</span><br><span class="hljs-comment">        // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span><br><span class="hljs-comment">        int        sa_flags;</span><br><span class="hljs-comment">        // 被废弃掉了</span><br><span class="hljs-comment">        void     (*sa_restorer)(void);</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="内核实现信号捕捉的过程"><a href="#内核实现信号捕捉的过程" class="headerlink" title="内核实现信号捕捉的过程"></a>内核实现信号捕捉的过程</h3><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840429.png" alt="信号捕捉"></p><h3 id="SIGCHILD-信号"><a href="#SIGCHILD-信号" class="headerlink" title="SIGCHILD 信号"></a>SIGCHILD 信号</h3><ul><li>SIGCHLD信号产生的条件<ul><li>子进程终止时</li><li>子进程接收到 SIGSTOP 信号停止时</li><li>子进程处在停止态，接受到SIGCONT后唤醒时</li></ul></li></ul><p>以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SIGCHLD信号产生的3个条件：</span><br><span class="hljs-comment">        1.子进程结束</span><br><span class="hljs-comment">        2.子进程暂停了</span><br><span class="hljs-comment">        3.子进程继续运行</span><br><span class="hljs-comment">        都会给父进程发送该信号，父进程默认忽略该信号。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    使用SIGCHLD信号解决僵尸进程的问题。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myFun</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号 ：%d\n&quot;</span>, num);<br><br>    <span class="hljs-comment">// 回收子进程PCB的资源</span><br>    <span class="hljs-comment">// while(1) &#123;</span><br>    <span class="hljs-comment">//     wait(NULL); </span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>       <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die , pid = %d\n&quot;</span>, ret);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 说明还有子进程或者</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>           <span class="hljs-comment">// 没有子进程</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 将 信号集 set 添加到内核阻塞信号集中</span><br><br>    <span class="hljs-comment">// 创建一些子进程</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br><br>        <span class="hljs-comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>        act.sa_flags = <span class="hljs-number">0</span>;<br>        act.sa_handler = myFun;<br>        sigemptyset(&amp;act.sa_mask);<br>        sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-comment">// 注册完信号捕捉以后，解除阻塞</span><br>        sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process pid : %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid : %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    来自评论区的大佬：https://www.nowcoder.com/study/live/504/2/27</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # 1</span><br><span class="hljs-comment">    视频中出现段错误的原因在于在信号处理函数中调用了不可重入的函数：</span><br><span class="hljs-comment">    使用gdb调试跟踪函数调用栈   // 学起来！</span><br><span class="hljs-comment">    最下层f 23可以看到是在main函数中，再往上f 22是在父进程中调用了printf</span><br><span class="hljs-comment">    再往上f 10可以看到调用了信号处理函数，这里是我们在main函数中调用printf但是printf还没有调用完成，直接转到了信号处理函数，我这里的信号处理函数为handler，见f 9，再往上f 8调用printf，可以看到f 8 和f 22是一样的</span><br><span class="hljs-comment">    SIGSEGV是因为printf会分配临时空间，在主函数调用printf至malloc时，中断处理函数调用，在其中也调用了printf至malloc时就出现了错误。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # 2</span><br><span class="hljs-comment">    1.为什么加了while可以回收之前被忽略掉SIGCHLD的僵尸进程。</span><br><span class="hljs-comment">    小伙伴们不要有这样的误解：A子进程产生信号，调用了myfun函数，waitpid（wait函数同理）就只会去回收A进程（x）。waitpid函数是个劳模，它只要见到僵尸进程就忍不住要回收，但能力有限，一次只能回收一次。只要给它机会，它可以把所有的僵尸进程一网打尽。所以只要有while循环，就可以不断执行waitpid函数，直到break。</span><br><span class="hljs-comment">    // wait 函数只负责回收僵尸进程，和 SIGCHLD 没有关系</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2.如果信号阻塞以后不能被捕获，那么是如何做到 “先阻塞SIGCHLD信号，当注册完信号捕捉以后，再解除阻塞，这样就会继续执行回调函数回收资源”？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    要弄懂这个问题，我们需要理清内核是如何处理信号的。信号的产生是异步的，A子进程产生SIGCHLD信号，不意味着父进程要立刻捕捉然后去做一些反应。当信号产生时，内核中未决信号集第17位会置1，它会等待父进程拥有cpu权限再去执行捕获信号处理函数，在去处理的瞬间17号位就会由1变为0，代表该信号有去处理了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    当我们提前设置了堵塞SIGCHLD信号，那未决集中就会一直保持1，不会调用捕获信号处理函数（也可以说信号不能被捕获），等待堵塞解除。所以并不是说，我们把信号堵塞了，然后解除堵塞，这个信号就消失了，它还是在未决集中的，值为1。捕捉函数捕获的其实就是这个1。信号捕捉不是钓鱼，钓鱼的话如果不及时处理，鱼就会跑掉。更像是网鱼，只要信号入网了，就跑不掉了。等我们准备好工具去捕获，会看到网上的鱼还是在的。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    高老师最后为什么要提前堵塞SIGCHLD信号？加了阻塞之后是什么情况？假设极端情况，20个子进程老早就终止了，内核收到SIGCHLD信号，会将未决信号集中的17号位置为1，就算他们是接连终止，该信号位也不会计数，只有保持1 。但同时该信号被提前阻塞，所以该17号位置保持1（阻塞是保持1，不是变回0），等待处理。当注册完信号捕捉函数以后，再解除阻塞。内核发现此时第17号位居然是1，那就去执行对应的捕获处理函数。在处理函数中，waitpid函数发现：“哎呦，这怎么躺着20具僵尸呀”，然后它就先回收一具僵尸，返回子进程id，循环第二次，继续回收第2具僵尸，直到所以僵尸被回收，此时已经没有子进程了，waitpid函数返回-1，break跳出循环。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    while循环中，返回值0对应的是没有僵尸但有正常的儿子，返回值-1代表压根没有儿子。所以只要子进程中存在僵尸，这个while就不会break，waitpid就可以悠哉悠哉地一次回收一具。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    《Linux/UNIX系统编程手册》指出为了保障可移植性，应用应在创建任何子进程之前就设置信号捕捉函数。【牛客789400243号】提出了这个观点，应该在fork之前就注册信号捕捉的。其实就是对应了书上这句话。</span><br><span class="hljs-comment">    // 如果没有阻塞 SIGCHLD，当所有子进程结束时信号捕捉函数还没有完成注册，内核收到 SIGCHLD 会默认忽略，等到信号捕捉函数还完成注册时，所有 SIGCHLD 信号都已近被处理了，不会调用myfun，从而产生僵尸进程。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    3. 【去冰加芝士】小伙伴的问题：为什么捕捉到了信号后没有进行处理就直接继续执行父进程后面的程序了呢？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    信号产生，内核中未决信号集SIGCHLD信号置1，内核调用信号捕捉函数myfun的同时把该信号置0，也就是说进入myfun函数后，内核依然是可以接收到SIGCHLD信号的。但是Linux为了防止某一个信号重复产生，在myfun函数进行多次递归导致堆栈空间爆了，它在调用myfhun函数会自动（内核自己完成）堵塞同类型信号。当然也可以用参数，自己指定要堵塞其他类型的信号。要注意的是，这里堵塞不是不接收信号，而是接收了不处理。当myfun函数结束，堵塞就会自动解除，该信号会传递给父进程。想象一个场景，20个子进程，先瞬间终止10个，父进程捕获到信号，进入myfun函数wait回收。这里有个点就是，父进程在执行myfun函数的时候，其他子进程不是挂起的，也是会运行的，至于怎么调度，那就看神秘莫测的调度算法了。在回收过程中，其余10个子进程也终止了，发出呼喊：“爹，快来回收我！”。父进程：“我没空，我还在myfun函数中干活”。于是内核将未决集中SIGCHLD信号置1等待处理，父进程在myfun函数中使用waitpid函数回收僵尸,”怎么越回收越多呀”，在while函数的加持下，他成功回收了20个僵尸。当它回到主函数打算休息下，内核叮的一声，有你的SIGCHLD信号，父进程以为有僵尸再次进入myfun函数，执行waipid函数，发现压根没有僵尸（上一次都回收完了），甚至儿子都没了（返回-1，break），骂骂咧咧返回了主函数。这就是为什么父进程捕获到了信号，进入了myfun函数，一个僵尸都没回收的真相。</span><br><span class="hljs-comment">    // 父进程收到 SIGCHLD 时，到调用 myfun 这段时间里，可能有新的子进程结束，这时产生的 SIGCHLD 信号会自动被系统阻塞，但是 while 循环里的 wait 会回收掉所有已经结束的子进程，包括执行循环时产生的僵尸进程等到回收完所有的僵尸进程后，之前阻塞的 SIGCHLD 信号被处理，但是这时已经没有僵尸进程了，所以直接 break。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    4.段错误究竟是怎么发生的？段错误的复现为什么这么难？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    段错误是个迷，有的人碰到过几次，有的人怎么也碰不到，这是由于神秘莫测的调度算法导致的。【潇潇_暮雨】小伙伴提出了，这是调用了不可重入的函数。《Linux/UNIX系统编程手册》第21.1.2节 对可重入函数进行了详细的解释，有兴趣的可以去翻一下。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    可重入函数的意思是：函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。通俗点讲，就是存在一个函数，A线程执行一半，B线程抢过CPU又来调用该函数，执行到1/4倍A线程抢回执行权。在这样不断来回执行中，不出问题的，就是可重入函数。多线程中每个线程都有自己的堆栈，所以如果函数中只用到局部变量肯定是可重入的，没问题的。但是更新了全局变量或静态数据结构的函数可能是不可重入的。假设某线程正在为一个链表结构添加一个新的链表项，而另外一个线程也视图更新同一链表。由于中间涉及多个指针，一旦另一线程中断这些步骤并修改了相同指针，结果就会产生混乱。但是并不是一定会出现，一定是A线程刚好在修改指针，另外一线程又去修改才会出现。这就是为什么该问题复现难度较高的原因。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    作者在文中指出，将静态数据结构用于内部记账的函数也是不可重入的。其中最明显的例子就是stdio函数库成员（printf()、scanf()等），它们会为缓冲区I/O更新内部数据结构。所以，如果在捕捉信号处理函数中调用了printf()，而主程序又在调用printf()或其他stdio函数期间遭到了捕捉信号处理函数的中断，那么有时就会看到奇怪的输出，设置导致程序崩溃。虽然printf()不是异步信号安全函数，但却频频出现在各种示例中，是因为在展示对捕捉信号处理函数的调用，以及显示函数中相关变量的内容时，printf()都不失为一种简单而又便捷的方式。真正的应用程序应当避免使用该类函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    printf函数会使用到一块缓冲区，这块缓冲区是使用malloc或类似函数分配的一块静态内存。所以它是不可重入函数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul><li>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制<strong>无需内核介入</strong>。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li><li>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的<strong>速度更快</strong>。</li></ul><p>使用步骤：</p><ul><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li><li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。<br>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li><li>调用 shmctl() 来删除共享内存段。<strong>只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁</strong>。只有一个进程需要执行这一步。</li></ul><p>共享内存操作命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ipcs 用法</span><br>ipcs -a    # 打印当前系统中所有的进程间通信方式的信息<br>ipcs -m   # 打印出使用共享内存进行进程间通信的信息<br>ipcs -q    # 打印出使用消息队列进行进程间通信的信息<br>ipcs -s    # 打印出使用信号进行进程间通信的信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ipcrm 用法</span><br>ipcrm -M shmkey    # 移除用shmkey创建的共享内存段<br>ipcrm -m shmid   # 移除用shmid标识的共享内存段<br>ipcrm -Q msgkey   # 移除用msqkey创建的消息队列<br>ipcrm -q msqid   # 移除用msqid标识的消息队列<br>ipcrm -S semkey   # 移除用semkey创建的信号<br>ipcrm -s semid   # 移除用semid标识的信号<br></code></pre></td></tr></table></figure><h3 id="共享内存相关的函数"><a href="#共享内存相关的函数" class="headerlink" title="共享内存相关的函数"></a>共享内存相关的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="hljs-comment">     新创建的内存段中的数据都会被初始化为0</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">     - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="hljs-comment">           一般使用16进制表示，非0值</span><br><span class="hljs-comment">     - size: 共享内存的大小</span><br><span class="hljs-comment">     - shmflg: 属性</span><br><span class="hljs-comment">       - 访问权限</span><br><span class="hljs-comment">       - 附加属性：创建/判断共享内存是不是存在</span><br><span class="hljs-comment">         - 创建：IPC_CREAT</span><br><span class="hljs-comment">         - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">           IPC_CREAT | IPC_EXCL | 0664</span><br><span class="hljs-comment">     - 返回值：</span><br><span class="hljs-comment">       失败：-1 并设置错误号</span><br><span class="hljs-comment">       成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：和当前的进程进行关联</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="hljs-comment">        - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定</span><br><span class="hljs-comment">        - shmflg : 对共享内存的操作</span><br><span class="hljs-comment">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="hljs-comment">            - 读写： 0</span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">        成功：返回共享内存的首（起始）地址。  失败(void *) -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：解除当前进程和共享内存的关联</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        shmaddr：共享内存的首地址</span><br><span class="hljs-comment">    - 返回值：成功 0， 失败 -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - shmid: 共享内存的ID</span><br><span class="hljs-comment">        - cmd : 要做的操作</span><br><span class="hljs-comment">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="hljs-comment">            - IPC_SET : 设置共享内存的状态</span><br><span class="hljs-comment">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="hljs-comment">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="hljs-comment">            - IPC_STAT : buf存储数据</span><br><span class="hljs-comment">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="hljs-comment">            - IPC_RMID : 没有用，NULL</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>; <span class="hljs-comment">// C 库函数 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    - 功能：根据指定的路径名，和int值，生成一个共享内存的key</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - pathname:指定一个存在的路径</span><br><span class="hljs-comment">            /home/nowcoder/Linux/a.txt</span><br><span class="hljs-comment">            / </span><br><span class="hljs-comment">        - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节</span><br><span class="hljs-comment">                   范围 ： 0-255  一般指定一个字符 &#x27;a&#x27;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>问题1：操作系统如何知道一块共享内存被多少个进程关联？</strong></p><ul><li>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</li><li>shm_nattach 记录了关联的进程个数</li></ul><p><strong>问题2：可不可以对共享内存进行多次删除 shmctl</strong></p><pre><code class="hljs">- 可以的    - 因为shmctl 标记删除共享内存，不是直接删除    - 什么时候真正删除呢?        当和共享内存关联的进程数为0的时候，就真正被删除    - 当共享内存的key为0的时候，表示共享内存被标记删除了        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</code></pre><p><strong>共享内存和内存映射的区别：</strong></p><ol><li><p>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</p></li><li><p>共享内存效率更高</p></li><li><p>内存</p><ul><li>所有的进程操作的是同一块共享内存。</li><li>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li></ul></li><li><p>数据安全</p><ul><li>进程突然退出<ul><li>共享内存还存在</li><li>内存映射区消失</li></ul></li><li>运行进程的电脑死机，宕机了<ul><li>数据存在在共享内存中，没有了</li><li>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li></ul></li></ul></li><li><p>生命周期</p><ul><li>内存映射区：进程退出，内存映射区销毁</li><li>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0）<br>  如果一个进程退出，会自动和共享内存进行取消关联。</li></ul></li></ol><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840440.png" alt="终端"></p><p>控制终端的信息保存在PCB中。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840551.png" alt="进程组"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840643.png" alt="会话"></p><p>一个控制终端对应一个会话，会话中的唯一前台进程组才能从控制终端中读取输入。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840745.png" alt="进程组、会话、控制终端的关系"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840860.png" alt="相关函数"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840888.png" alt="守护进程"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208171840864.png" alt="创建守护进程"></p><p>其他笔记：</p><blockquote><p> 原文链接：<a href="https://www.cnblogs.com/DianaCody/p/5425641.html">linux创建守护进程</a></p></blockquote><ol><li><p>创建子进程，父进程退出: (假象–父进程已完成，可退出终端)<br> 这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成一程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在<strong>形式上做到了与控制终端的脱离</strong>。<br> 在Linux中父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程是，就会自动由1号进程（init）收养它，这样，原先的子进程就会变成init进程的子进程。</p></li><li><p>在子进程中创建新会话: 使用系统函数setid()–进程组、会话期<br>  这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用的是系统函数setsid，在具体介绍setsid之前，首先要了解两个概念：进程组和会话期</p><p>  进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且该进程组ID不会因组长进程的退出而受到影响。</p><p>  会话周期：会话期是一个或多个进程组的集合。通常，一个会话开始与用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期。<br>  接下来就可以具体介绍setsid的相关内容：<br>  setsid函数作用：setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid有下面的3个作用：</p><ul><li><p>让进程摆脱原会话的控制</p></li><li><p>让进程摆脱原进程组的控制</p></li><li><p>让进程摆脱原控制终端的控制</p></li></ul><p> 那么，在创建守护进程时为什么要调用setsid函数呢？由于创建守护进程的第一步调用了fork函数来创建子进程，再将父进程退出。由于在调用了fork函数时，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，还还不是真正意义上的独立开来，而<strong>setsid函数能够使进程完全独立出来，从而摆脱其他进程的控制</strong>。</p></li><li><p>改变当前目录为根目录<br>  使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“&#x2F;mnt&#x2F;usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入但用户模式）。因此，通常的做法是让”&#x2F;“作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如&#x2F;tmp。改变工作目录的常见函数式chdir。</p></li><li><p>重设文件权限掩码: umask(0)<br>  文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。</p></li><li><p>关闭文件描述符<br>  同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。</p><p>  在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，<strong>文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭</strong>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 多进程开发（1）</title>
    <link href="/posts/b76a0a04/"/>
    <url>/posts/b76a0a04/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-多进程开发（1）"><a href="#Linux-多进程开发（1）" class="headerlink" title="Linux 多进程开发（1）"></a>Linux 多进程开发（1）</h1><h3 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">man ps <span class="hljs-comment"># 查看手册</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ps - report a snapshot of the current processes.</span><br>ps [-option] # aux/ajx<br>a: all<br>u:<br>j: job<br>x: <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2</span><br>tty # 查看当前终端信息<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 实时查看进行信息</span><br>top [-option]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 向进程发送信号</span><br>kill <br>kill -l # 查看所有信号<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后台运行</span><br>[命令] &amp;<br></code></pre></td></tr></table></figure><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>fork函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    pid_t fork(void);</span><br><span class="hljs-comment">        函数的作用：用于创建子进程。</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span><br><span class="hljs-comment">            在父进程中返回创建的子进程的ID,</span><br><span class="hljs-comment">            在子进程中返回0</span><br><span class="hljs-comment">            如何区分父进程和子进程：通过fork的返回值。</span><br><span class="hljs-comment">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        父子进程之间的关系：</span><br><span class="hljs-comment">        区别：</span><br><span class="hljs-comment">            1.fork()函数的返回值不同</span><br><span class="hljs-comment">                父进程中: &gt;0 返回的子进程的ID</span><br><span class="hljs-comment">                子进程中: =0</span><br><span class="hljs-comment">            2.pcb中的一些数据</span><br><span class="hljs-comment">                当前的进程的id pid</span><br><span class="hljs-comment">                当前的进程的父进程的id ppid</span><br><span class="hljs-comment">                信号集</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        共同点：</span><br><span class="hljs-comment">            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span><br><span class="hljs-comment">                - 用户区的数据</span><br><span class="hljs-comment">                - 文件描述符表</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        父子进程对变量是不是共享的？</span><br><span class="hljs-comment">            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span><br><span class="hljs-comment">            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 判断是父进程还是子进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// printf(&quot;pid : %d\n&quot;, pid);</span><br>        <span class="hljs-comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent num : %d\n&quot;</span>, num);<br>        num += <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent num += 10 : %d\n&quot;</span>, num);<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前是子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());<br>       <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child num : %d\n&quot;</span>, num);<br>        num += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child num += 100 : %d\n&quot;</span>, num);<br>    &#125;<br><br>    <span class="hljs-comment">// for循环, 父子进程交替执行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy-on-write) 实现。</span><br><span class="hljs-comment">    写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span><br><span class="hljs-comment">    内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span><br><span class="hljs-comment">    只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span><br><span class="hljs-comment">    也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span><br><span class="hljs-comment">    注意：fork之后父子进程共享文件，</span><br><span class="hljs-comment">    fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="GDB-多进程调试"><a href="#GDB-多进程调试" class="headerlink" title="GDB 多进程调试"></a>GDB 多进程调试</h3><p>gdb默认只跟踪一个进程，默认调试父进程，子进程代码直接运行。设置调试默认调试的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set follow-fork-mode [parent (default) | child]<br></code></pre></td></tr></table></figure><p>设置调试的模式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set detach-on-fork [on (default) | off]<br></code></pre></td></tr></table></figure><p>on：调试时其他进程继续运行；</p><p>off：调试时其他进程被 gdb 挂起。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看调试的进程</span><br>info inferiors<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换当前调试的进程</span><br>inferior id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使进程脱离 gdb 调试</span><br>detach inferiors id<br></code></pre></td></tr></table></figure><h3 id="exce-函数族"><a href="#exce-函数族" class="headerlink" title="exce 函数族"></a>exce 函数族</h3><p>函数名称不同，功能相似的函数叫函数族。</p><ul><li>exec 函数族的作用是<strong>根据指定的文件名找到可执行文件，并用它来取代调用进程的内容</strong>，换句话说，就是在调用进程内部执行一个可执行文件。</li><li>exec 函数族的函数执行成功后<strong>不会返回</strong>，因为调用进程的实体，包括代码段，数据段和堆栈等都已经<strong>被新的内容取代</strong>，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回 -1，从<strong>原程序的调用点</strong>接着往下执行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 标准 C 库函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/* (char  *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... <span class="hljs-comment">/* (char  *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><br><span class="hljs-comment">// linux 系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br></code></pre></td></tr></table></figure><ul><li>l(list)：参数地址列表，以空指针结尾</li><li>v(vector) ：存有各参数地址的指针数组的地址</li><li>p(path) ：按 PATH 环境变量指定的目录搜索可执行文件</li><li>e(environment) ：存有环境变量字符串地址的指针数组的地址</li></ul><ol><li><code>int execl(const char *path, const char *arg, .../* (char  *) NULL */);</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int execl(const char *path, const char *arg, ...);</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - path:需要指定的执行的文件的路径或者名称</span><br><span class="hljs-comment">                a.out /workspace/cpp_test/a.out 推荐使用绝对路径</span><br><span class="hljs-comment">                ./a.out hello world</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="hljs-comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="hljs-comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="hljs-comment">                参数最后需要以NULL结束（哨兵）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="hljs-comment">            如果调用成功，没有返回值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">1</span>); <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        execl(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL);</span><br>        perror(<span class="hljs-string">&quot;execl&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid()); <span class="hljs-comment">// 不执行</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果：</span><br><span class="hljs-comment">i am parent process, pid : 9175</span><br><span class="hljs-comment">hello, world</span><br><span class="hljs-comment">i = 0, pid = 9175</span><br><span class="hljs-comment">i = 1, pid = 9175</span><br><span class="hljs-comment">i = 2, pid = 9175</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int execlp(const char *file, const char *arg, ... );</span><br><span class="hljs-comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - file:需要执行的可执行文件的文件名</span><br><span class="hljs-comment">                a.out</span><br><span class="hljs-comment">                ps</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - arg:是执行可执行文件所需要的参数列表</span><br><span class="hljs-comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span><br><span class="hljs-comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span><br><span class="hljs-comment">                参数最后需要以NULL结束（哨兵）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span><br><span class="hljs-comment">            如果调用成功，没有返回值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        int execv(const char *path, char *const argv[]);</span><br><span class="hljs-comment">        argv是需要的参数的一个字符串数组</span><br><span class="hljs-comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span><br><span class="hljs-comment">        execv(&quot;/bin/ps&quot;, argv);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;j&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br>        perror(<span class="hljs-string">&quot;execl&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果：</span><br><span class="hljs-comment">i am parent process, pid : 11115</span><br><span class="hljs-comment"> PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND</span><br><span class="hljs-comment"> 2578  2579  2579  2579 pts/0    11115 Ss     500   0:00 -bash</span><br><span class="hljs-comment"> 2579 11115 11115  2579 pts/0    11115 S+     500   0:00 ./execlp.out</span><br><span class="hljs-comment">11115 11116 11115  2579 pts/0    11115 R+     500   0:00 ps j</span><br><span class="hljs-comment">i = 0, pid = 11115</span><br><span class="hljs-comment">i = 1, pid = 11115</span><br><span class="hljs-comment">i = 2, pid = 11115</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 标准库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br><br><span class="hljs-comment">// Liunx 系统调用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151700198.png" alt="进程退出"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">    void exit(int status);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    void _exit(int status);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 相当于 return 0;</span><br>    <span class="hljs-comment">// _exit(0);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>exit(0) 执行的结果（会刷新缓冲区）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151711526.png" alt="exit(0)"></p><p>_exit(0) 执行的结果（不会刷新缓冲区）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151711601.png" alt="_exit(0)"></p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan<br>Process）。<br>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而 init 进程会循环地 wait() 它<br>的已经退出的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 判断是父进程还是子进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 当前是子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());<br>       <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p>子进程的文件描述符表里的012复制于父进程，所以输出到同一个终端。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208151715269.png" alt="孤儿进程"></p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul><li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</li><li>子进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</li><li>僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</li></ul><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">i am parent process, pid : 17195, ppid : 13038<br>i am child process, pid : 17196, ppid : 17195<br>i : 0 , pid : 17196<br>i : 1 , pid : 17196<br>i : 2 , pid : 17196<br>i am parent process, pid : 17195, ppid : 13038<br>i am parent process, pid : 17195, ppid : 13038<br>i am parent process, pid : 17195, ppid : 13038<br>...<br></code></pre></td></tr></table></figure><p>新建终端使用 ps命令查看，子进程变为僵尸进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">PPID   PID  PGID   SID  TTY      TPGID STAT   UID   TIME COMMAND<br>13038 17195 17195 13038 pts/0    17195 S+     500   0:00 ./zombie<br>17195 17196 17195 13038 pts/0    17195 Z+     500   0:00 [zombie] &lt;defunct&gt;<br></code></pre></td></tr></table></figure><h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。<br>父进程可以通过调用 wait 或 waitpid 得到它的退出状态同时彻底清除掉这个进程。<br>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，<br>waitpid() 还可以指定等待哪个子进程结束。<br>注意：一次 wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</p><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait() 函数"></a>wait() 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">    pid_t wait(int *wstatus);</span><br><span class="hljs-comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span><br><span class="hljs-comment">        参数：int *wstatus</span><br><span class="hljs-comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            - 成功：返回被回收的子进程的id</span><br><span class="hljs-comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="hljs-comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 有一个父进程，创建5个子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent, pid = %d\n&quot;</span>, getpid());<br>            <br>            <span class="hljs-comment">// int ret = wait(NULL);</span><br>            <br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//所有的子进程都结束</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFEXITED(st)) &#123;<br>                <span class="hljs-comment">// 是不是正常退出</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFSIGNALED(st)) &#123;<br>                <span class="hljs-comment">// 是不是异常终止</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-comment">// kill 信号</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>,getpid());    <br>           sleep(<span class="hljs-number">1</span>);       <br>        &#125;<br>        <br>        <span class="hljs-comment">// 正常退出</span><br>        <span class="hljs-comment">// printf(&quot;child, pid = %d\n&quot;,getpid());</span><br><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// exit(0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>退出信息相关宏函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">WIFEXITED(status)     <span class="hljs-comment">// 非0，进程正常退出</span><br>WEXITSTATUS(status)   <span class="hljs-comment">// 如果上宏为真，获取进程退出的状态（exit的参数）</span><br>WIFSIGNALED(status)   <span class="hljs-comment">// 非0，进程异常终止</span><br>WTERMSIG(status)      <span class="hljs-comment">// 如果上宏为真，获取使进程终止的信号编号</span><br>WIFSTOPPED(status)    <span class="hljs-comment">// 非0，进程处于暂停状态</span><br>WSTOPSIG(status)      <span class="hljs-comment">// 如果上宏为真，获取使进程暂停的信号的编号</span><br>WIFCONTINUED(status)  <span class="hljs-comment">// 非0，进程暂停后已经继续运行</span><br></code></pre></td></tr></table></figure><h4 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid() 函数"></a>waitpid() 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="hljs-comment">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pid:</span><br><span class="hljs-comment">                pid &gt; 0 : 某个子进程的pid</span><br><span class="hljs-comment">                pid = 0 : 回收当前进程组的任一子进程    </span><br><span class="hljs-comment">                pid = -1 : 回收任一的子进程，相当于 wait()  （最常用）</span><br><span class="hljs-comment">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="hljs-comment">            - options：设置阻塞或者非阻塞</span><br><span class="hljs-comment">                0 : 阻塞</span><br><span class="hljs-comment">                WNOHANG : 非阻塞</span><br><span class="hljs-comment">            - 返回值：</span><br><span class="hljs-comment">                &gt; 0 : 返回子进程的id</span><br><span class="hljs-comment">                = 0 : options=WNOHANG, 表示还有子进程活着</span><br><span class="hljs-comment">                = -1 ：错误，或者没有子进程了</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    getpgrp函数可获取当前进程的进程组ID。</span><br><span class="hljs-comment">    getpgid函数可获取指定进程的进程组ID。</span><br><span class="hljs-comment">    setpgid函数可改变进程默认的进程组，可加入另一个进程组或创建进程组。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 有一个父进程，创建5个子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent, pid = %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-comment">// int ret = waitpid(-1, &amp;st, 0);  // 相当于 wait(&amp;st);</span><br>            <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, &amp;st, WNOHANG);<br><br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 说明还有子进程存在</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br><br>                <span class="hljs-keyword">if</span>(WIFEXITED(st)) &#123;<br>                    <span class="hljs-comment">// 是不是正常退出</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(WIFSIGNALED(st)) &#123;<br>                    <span class="hljs-comment">// 是不是异常终止</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            &#125;<br>           <br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>         <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>,getpid());    <br>            sleep(<span class="hljs-number">1</span>);       <br>         &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 系统编程入门</title>
    <link href="/posts/bb4cd573/"/>
    <url>/posts/bb4cd573/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-系统编程入门"><a href="#Linux-系统编程入门" class="headerlink" title="Linux 系统编程入门"></a>Linux 系统编程入门</h1><h2 id="gcc-编译命令"><a href="#gcc-编译命令" class="headerlink" title="gcc 编译命令"></a>gcc 编译命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc [FileName] [-o ProgramName]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用编译选项</span><br>[-o] 目标文件名<br>[-E] 预处理，生成预处理后的代码，不编译<br>[-S] 编译，生成汇编代码，不汇编<br>[-c] 汇编，生成目标代码，但是不进行链接<br>[-I directory] 指定 include 包含文件的搜索目录<br>[-g] 在编译的时候，生成调试信息，该程序可以被调试器调试<br>[-D] 编译的时候定义一个宏<br>[-l] 链接的库<br></code></pre></td></tr></table></figure><p>g++ 在编译的阶段调用 gcc，但是 gcc 不能自动和 c++ 程序使用的库链接，除非添加编译选项 <code>gcc -lstdc++</code>。</p><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><ol><li><p>命名规则：</p><ol><li>Linux：libxxx.a</li><li>Windows：libxxx.lib</li></ol></li><li><p>静态库的制作</p><ol><li><p>gcc 编译生成 -o 汇编文件</p><p> <code>gcc -c a.c b.c</code></p></li><li><p>对汇编文件打包，创建静态库</p><p> <code>ar rcs libxxx.a a.o b.o</code></p></li></ol></li></ol><h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc FileName -l xxx<br></code></pre></td></tr></table></figure><p><code>xxx</code> 为 库名称，而非库文件名称</p><h3 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h3><ol><li><p>命名规则：</p><ol><li>Linux：libxxx.so</li><li>Windows：libxxx.dll</li></ol></li><li><p>动态库的制作</p><ol><li><p>gcc 编译生成 -o 汇编文件</p><p> <code>gcc -c -fpic/-fPIC a.c b.c</code></p></li><li><p>gcc 制作动态库</p><p> <code>gcc -shared *.o -o libxxx.so</code></p></li></ol></li></ol><h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><ol><li><p>程序运行时动态库加载失败的原因：</p><p> 系统加载可执行代码的时候，除了需要知道所依赖的动态库的名称，还需要知到其绝对路径，此时需要系统的动态载入器来获取其绝对路径。</p></li><li><p>解决方法：</p><ol><li><p>添加环境变量，只在当前终端生效（临时）</p><p> <code>export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:libso_path</code></p></li><li><p>添加环境变量，在<code>~/.bashrc</code>中添加（用户级别）</p><p> <code>export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:libso_path</code></p><p> 使环境变量生效</p><p> <code>source ~/.bashrc</code> 或者 <code>，~/.bashrc</code></p></li><li><p>添加环境变量，在<code>/etc/profile</code>中添加（系统级别）</p><p> <code>export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:libso_path</code></p><p> 使环境变量生效</p><p> <code>source /etc/profile</code> 或者 <code>，/etc/profile</code></p></li><li><p>修改 <code>/etc/ld.so.cache</code>，二进制文件，不能直接修改，通过 <code>/etc/ld.so.conf</code> 修改，直接添加<code>libso_path</code>，<code>ldconfig</code> 使修改生效。</p></li><li><p>将动态库文件放在 <code>/lib/</code> 或者 <code>/usr/lib/</code> 目录下（不建议），可能会替换同名的系统库文件。</p></li></ol></li></ol><h3 id="静态库-vs-动态库"><a href="#静态库-vs-动态库" class="headerlink" title="静态库 vs. 动态库"></a>静态库 vs. 动态库</h3><ol><li><p>静态库</p><ul><li><p>优点：</p><p> a. 加载速度快</p><p> b. 发布程序无需提供静态库，移植方便</p></li><li><p>缺点：</p><p> a. 消耗系统资源，浪费内存</p><p> b. 更新、部署、发布麻烦</p></li></ul></li><li><p>动态库</p><ul><li><p>优点：</p><p> a. 可以实现进程间的资源共享</p><p> b. 更新、部署、发布简单</p><p> c. 可以控制核实加载动态库</p></li><li><p>缺点：</p><p> a. 加载速度比静态库慢</p><p> b. 发布程序是需要提供依赖的动态库</p></li></ul></li></ol><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="什么是-Makefile"><a href="#什么是-Makefile" class="headerlink" title="什么是 Makefile"></a>什么是 Makefile</h3><ul><li>工程的源文件根据类型、功能、模块分别放在不同的目录中，Makefile 文件定义了以系列规则来指定哪些文件先编译，哪些文件后编译，哪些文件需要重新编译，甚至更复杂的功能。</li><li>Makefile 带来的好处：“自动化编译”，make 是解释 Makefile 的命令工具。</li></ul><h3 id="Makefile-文件命名和规则"><a href="#Makefile-文件命名和规则" class="headerlink" title="Makefile 文件命名和规则"></a>Makefile 文件命名和规则</h3><ol><li><p>文件命名：</p><p> Makefile 或者 makefile</p></li><li><p>规则：</p></li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">目标 ... : 依赖...<br>    命令 (shell 命令)<br>    ...<br><br><span class="hljs-section">目标: 最终要生成的文件 (伪目标除外)</span><br><span class="hljs-section">依赖: 生成目标所需要的文件或是目标</span><br><span class="hljs-section">命令: 通过执行命令对依赖操作生成目标 (前有缩进)</span><br><br>Makefile 文件里的其他规则一般是为第一条规则服务的. <br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1</span><br><span class="hljs-section">app:sub.c add.c mult.c div.c main.c</span><br>    gcc sub.c add.c mult.c div.c main.c -o app<br>    <br><span class="hljs-comment"># 2</span><br><span class="hljs-section">app:sub.o add.o mult.o div.o main.o</span><br>    gcc sub.o add.o mult.o div.o main.o -o app<br><br><span class="hljs-section">sub.o:sub.c</span><br>    gcc -c sub.c -o sub.o<br><br><span class="hljs-section">add.o:add.c</span><br>    gcc -c add.c -o add.o<br><br><span class="hljs-section">mult.o:mult.c</span><br>    gcc -c mult.c -o mult.o<br><br><span class="hljs-section">div.o:div.c</span><br>    gcc -c div.c -o div.o<br><br><span class="hljs-section">main.o:main.c</span><br>    gcc -c main.c -o main.o<br>    <br><span class="hljs-comment"># 3</span><br><span class="hljs-comment">#定义变量</span><br>src=sub.o add.o mult.o div.o main.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(src)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(src)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">sub.o:sub.c</span><br>    gcc -c sub.c -o sub.o<br><br><span class="hljs-section">add.o:add.c</span><br>    gcc -c add.c -o add.o<br><br><span class="hljs-section">mult.o:mult.c</span><br>    gcc -c mult.c -o mult.o<br><br><span class="hljs-section">div.o:div.c</span><br>    gcc -c div.c -o div.o<br><br><span class="hljs-section">main.o:main.c</span><br>    gcc -c main.c -o main.o<br>    <br><span class="hljs-comment"># 4</span><br><span class="hljs-comment">#定义变量</span><br>src=sub.o add.o mult.o div.o main.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(src)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(src)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br>    <br><span class="hljs-comment"># 5</span><br><span class="hljs-comment">#定义变量</span><br><span class="hljs-comment"># add.c sub.c main.c mult.c div.c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objs=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(objs)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(objs)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br><span class="hljs-section">clean:</span><br>    rm <span class="hljs-variable">$(objs)</span> -f<br></code></pre></td></tr></table></figure><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p>命令:</p><p>向可执行程序中加入调试信息. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g test.c -o test<br></code></pre></td></tr></table></figure><p>启动&#x2F;退出 gdb:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb [可执行文件] # 启动<br><br>(gdb) q/quit # 退出 gdb<br></code></pre></td></tr></table></figure><p>gdb 常用命令: </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 给程序设置参数/获取设置参数</span><br>(gdb) set args 10 20    <span class="hljs-comment"># 设置函数参数</span><br>(gdb) show args         <span class="hljs-comment"># 获取函数参数</span><br><br>(gdb) help [command] <span class="hljs-comment"># 查看帮助文档</span><br><br><span class="hljs-comment"># 查看当前文件代码</span><br>(gdb) list/l        <span class="hljs-comment"># 从默认位置显, 默认10行</span><br>(gdb) list/l line   <span class="hljs-comment"># 从指定的行显示, 行号上下文</span><br>(gdb) list/l func   <span class="hljs-comment"># 从指定的函数显示, func上下文</span><br><br><span class="hljs-comment"># 查看非当前文件代码</span><br>(gdb) list/l filename : line<br>(gdb) list/l filename : func<br><br><span class="hljs-comment"># 设置显示的行数</span><br>(gdb) show list/listsize<br>(gdb) set list/listsize line<br><br><span class="hljs-comment"># 设置断点</span><br>(gdb) b/break line<br>(gdb) b/break func<br>(gdb) b/break filename : line<br>(gdb) b/break filename : func<br><br><span class="hljs-comment"># 查看断点</span><br>(gdb) i/info b/break<br><br><span class="hljs-comment"># 删除断点</span><br>(gdb) d/del/delete brk_num<br><br><span class="hljs-comment"># 设置断点无效</span><br>(gdb) dis/disable brk_num<br><br><span class="hljs-comment"># 设置断点生效</span><br>(gdb) en/enable brk_num<br><br><span class="hljs-comment"># 设置条件断点 (一般用在循环位置)</span><br>(gdb) b/break 10 if i==5<br><br><span class="hljs-comment"># 运行GDB程序</span><br>(gdb) start     <span class="hljs-comment"># 停在main第一行</span><br>(gdb) run       <span class="hljs-comment"># 停在第一个断点</span><br><br><span class="hljs-comment"># 继续运行</span><br>(gdb) c/continue    <span class="hljs-comment"># 下一个断点</span><br>(gdb) n/next        <span class="hljs-comment"># 下一行, 不会进入函数体</span><br>(gdb) s/step        <span class="hljs-comment"># 单步调试, 会进入函数体</span><br>(gdb) finish        <span class="hljs-comment"># 跳出函数体</span><br><br><span class="hljs-comment"># 变量操作</span><br>(gdb) p/print variable      <span class="hljs-comment"># 打印变量值</span><br>(gdb) ptype   variable      <span class="hljs-comment"># 打印变量类型</span><br><br><span class="hljs-comment"># 自动变量操作</span><br>(gdb) display variable <span class="hljs-comment"># 自动打印指定变量</span><br>(gdb) i/info display<br>(gdb) undisplay no.<br><br><span class="hljs-comment"># 其他操作</span><br>(gdb) set var variable = value  <span class="hljs-comment"># 设置变量的值</span><br>(gdb) until                     <span class="hljs-comment"># 跳出循环</span><br></code></pre></td></tr></table></figure><p>gdb 不输入命名按回车默认执行上一条命令。</p><h2 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h2><h3 id="标准-C-库-IO-函数"><a href="#标准-C-库-IO-函数" class="headerlink" title="标准 C 库 IO 函数"></a>标准 C 库 IO 函数</h3><p>标准 C 库中的IO函数 调用操作系统的 API，可以跨平台。<br>标准 C 库的IO函数带有缓冲区，效率较高。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120301129.png" alt="![](https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120301129.png)"></p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>32位操作系统的虚拟地址空间：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120308467.png" alt="虚拟地址空间"></p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">文件描述符</span><br>0 -&gt; STDIN_FILENO# 标准输入<br>1 -&gt; STDOUT_FILENO# 标准输出<br>2 -&gt; STDERR_FILENO# 标准错误<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208120322763.png" alt="文件描述符"></p><p>文件描述符表是一个数组，默认大小为1024。前三个元素被占用，默认打开，指向当前终端。</p><h3 id="Linux-系统-IO-函数"><a href="#Linux-系统-IO-函数" class="headerlink" title="Linux 系统 IO 函数"></a>Linux 系统 IO 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>; <span class="hljs-comment">// 关闭文件描述符，fd 不再指向任何文件，并可以被再次使用</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span>;<br></code></pre></td></tr></table></figure><p>可使用<code>man</code> 命令查看说明文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man 2 open<br></code></pre></td></tr></table></figure><h4 id="open-系统调用"><a href="#open-系统调用" class="headerlink" title="open 系统调用"></a>open 系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 所需头文件: </span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      <span class="hljs-comment">// flags : 权限标记, Linux 里定义为宏, 在前两个头文件里</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>       <span class="hljs-comment">//</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>          <span class="hljs-comment">// open 的函数声明</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>; <span class="hljs-comment">// 打开一个已存在文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>; <span class="hljs-comment">// 创建一个新的文件</span><br></code></pre></td></tr></table></figure><p>C 没有函数重载, 两个 open 通过可变参数实现: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, ...)</span>;<br></code></pre></td></tr></table></figure><p>打开一个已存在文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 打开一个已存在文件</span><br><span class="hljs-comment">    int open(const char *pathname, int flags);</span><br><span class="hljs-comment">        parameters:</span><br><span class="hljs-comment">            pathname : 要打开的文件路径</span><br><span class="hljs-comment">            flags    : 对文件的操作权限设置和其他设置</span><br><span class="hljs-comment">                必选 : O_RDONLY, O_WRONLY, or O_RDWR. 这三个互斥</span><br><span class="hljs-comment">                可选 : O_APPEND, O_CREAT, O_TRUNC 等 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        return value :</span><br><span class="hljs-comment">            成功返回新的文件描述符, 失败返回 -1 </span><br><span class="hljs-comment">        errno : </span><br><span class="hljs-comment">            属于 Linux 系统函数库, 库里面的全局变量, 记录的是最近的错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    perror函数</span><br><span class="hljs-comment">    # include &lt;stdio.h&gt;</span><br><span class="hljs-comment">    // 打印对应 errno 对应的错误描述</span><br><span class="hljs-comment">    void perror(const char *s);</span><br><span class="hljs-comment">    输出: s: system error message</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      <span class="hljs-comment">// flag : 权限标记, Linux 里定义为宏, 在前两个头文件里</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>       <span class="hljs-comment">//</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>          <span class="hljs-comment">// open 的函数声明</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDONLY); <span class="hljs-comment">// 当前目录不存在 a.txt</span><br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>); <span class="hljs-comment">// 输出 : open: No such file or directory</span><br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件描述符</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个新的文件：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"># include &lt;sys/types.h&gt;      // flags : 权限标记, Linux 里定义为宏, 在前两个头文件里</span><br><span class="hljs-comment"># include &lt;sys/stat.h&gt;       //</span><br><span class="hljs-comment"># include &lt;fcntl.h&gt;          // open 的函数声明</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-comment">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="hljs-comment">    parameters:</span><br><span class="hljs-comment">        pathname : 要打开的文件路径</span><br><span class="hljs-comment">        flags    : 对文件的操作权限设置和其他设置</span><br><span class="hljs-comment">            必选 : O_RDONLY, O_WRONLY, or O_RDWR. 这三个互斥</span><br><span class="hljs-comment">            可选 :  O_APPEND, O_CREAT, O_TRUNC 等 </span><br><span class="hljs-comment">        mode: 八进制数, 表示创建出的文件操作权限, 比如 0775, 0 表示八进制</span><br><span class="hljs-comment">            最终的权限是 mode &amp; ~umask</span><br><span class="hljs-comment">                </span><br><span class="hljs-comment">    return value :</span><br><span class="hljs-comment">        成功返回新的文件描述符, 失败返回 -1 </span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      <span class="hljs-comment">// flag : 权限标记, Linux 里定义为宏, 在前两个头文件里</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>       <span class="hljs-comment">//</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>          <span class="hljs-comment">// open 的函数声明</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0777</span>); <span class="hljs-comment">// 创建 create.txt</span><br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>); <br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件描述符</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    ssize_t read(int fd, void *buf, size_t count);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="hljs-comment">            - buf：需要读取数据存放的地方，数组的地址（传出参数）</span><br><span class="hljs-comment">            - count：指定的数组的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            - 成功：</span><br><span class="hljs-comment">                &gt;0: 返回实际的读取到的字节数</span><br><span class="hljs-comment">                =0：文件已经读取完了</span><br><span class="hljs-comment">            - 失败：-1 ，并且设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span><br><span class="hljs-comment">            - buf：要往磁盘写入的数据，数据</span><br><span class="hljs-comment">            - count：要写的数据的实际的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功：实际写入的字节数</span><br><span class="hljs-comment">            失败：返回-1，并设置errno</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.通过open打开english.txt文件</span><br>    <span class="hljs-type">int</span> srcfd = open(<span class="hljs-string">&quot;english.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(srcfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.创建一个新的文件（拷贝文件）</span><br>    <span class="hljs-type">int</span> destfd = open(<span class="hljs-string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(destfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.频繁的读写操作</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = read(srcfd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>) &#123;<br>        write(destfd, buf, len);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.关闭文件</span><br>    close(destfd);<br>    close(srcfd);<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    标准C库的函数</span><br><span class="hljs-comment">    #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">    int fseek(FILE *stream, long offset, int whence);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Linux系统函数，重置文件指针偏移量</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    off_t lseek(int fd, off_t offset, int whence);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span><br><span class="hljs-comment">            - offset：偏移量，偏移量一旦超出了文件的长度，下一次进行文件IO写入操作文件的时候便会延续偏移量的位置继续写入，进而在文件中间产生了空洞的部分，这部分会以”\0”填充，而从原来的文件结尾到新写入数据间的这段空间就被称为“文件空洞”。</span><br><span class="hljs-comment">            - whence:</span><br><span class="hljs-comment">                SEEK_SET</span><br><span class="hljs-comment">                    设置文件指针的偏移量</span><br><span class="hljs-comment">                SEEK_CUR</span><br><span class="hljs-comment">                    设置偏移量：当前位置 + 第二个参数offset的值</span><br><span class="hljs-comment">                SEEK_END</span><br><span class="hljs-comment">                    设置偏移量：文件大小 + 第二个参数offset的值</span><br><span class="hljs-comment">        返回值：返回当前位置到文件开始位置以字节为单位的偏移量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    作用：</span><br><span class="hljs-comment">        1.移动文件指针到文件头</span><br><span class="hljs-comment">        lseek(fd, 0, SEEK_SET);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        2.获取当前文件指针的位置</span><br><span class="hljs-comment">        lseek(fd, 0, SEEK_CUR);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        3.获取文件长度</span><br><span class="hljs-comment">        lseek(fd, 0, SEEK_END);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">//原始文件内容: hello,world</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;hello.txt&quot;</span>, O_RDWR);<br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 扩展文件的长度</span><br>    <span class="hljs-type">int</span> ret = lseek(fd, <span class="hljs-number">10000000</span>, SEEK_END);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;lseek&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在offset = 10000011处写入一个数据</span><br>    write(fd, <span class="hljs-string">&quot;.&quot;</span>, SEEK_CUR);<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>什么是空洞文件(hole file)？在Linux中，lseek的系统调用是可以改变在文件上面的偏移量的，而且还允许其超出文件的长度。偏移量一旦超出了文件的长度，下一次进行文件IO写入操作文件的时候便会延续偏移量的位置继续写入，进而在文件中间产生了空洞的部分，这部分会以”\0”填充，而从原来的文件结尾到新写入数据间的这段空间就被称为“<strong>文件空洞</strong>”。</p><p>在Linux中，EOF（文件结束符）并不是一个字符，而是在读取到文件末尾的时候返回的一个信号值，也就是-1。</p><p>文件空洞部分实际上是不会占用任何的物理空间的，直到在某个时刻对空洞部分进行写入文件内容的时候才会为它分配对应的空间。但是在空洞文件形成的时候，逻辑上面的文件大小是分配了空洞部分的大小的。</p></blockquote><p>生成元素文件 hello.txt 的拷贝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp hello.txt hello.prev<br></code></pre></td></tr></table></figure><p>编译上述代码后运行。</p><p>使用od命令来查看<code>hello.txt</code>文件的二进制内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">od -c hello.txt<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121756971.png" alt="od -c hello.txt"></p><p>使用ls查看文件的逻辑大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">ls -lh hello.*<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121800438.png" alt="逻辑大小"></p><p>逻辑大小：</p><p>hello.prev: 11 Bytes</p><p>hello.txt: 10000012 Bytes &#x3D; 10000012 &#x2F; 1024 &#x2F; 1024 M &#x3D; 9.6 M</p><p>使用du查看文件实际占用物理块的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -h hello.*<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121800966.png" alt="实际占用物理块"></p><p>文件系统的基本操作单位是数据块，Linux 中的逻辑块大小为 <code>4KB</code>，所以 hello.prev 实际占用的空间为 4k，由于 <code>&quot;hello,world&quot;</code>  和 <code>&quot;.&quot;</code> 在逻辑上不在一个块内，所以 hello.txt 实际占用的空间为 8k，远小于 9.6 M，所以文件空洞部分实际上是不会占用任何的物理空间的。</p><h4 id="stat、lstat"><a href="#stat、lstat" class="headerlink" title="stat、lstat"></a>stat、lstat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int stat(const char *pathname, struct stat *statbuf);</span><br><span class="hljs-comment">        作用：获取一个文件相关的一些信息</span><br><span class="hljs-comment">        参数:</span><br><span class="hljs-comment">            - pathname：操作的文件的路径</span><br><span class="hljs-comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功：返回0</span><br><span class="hljs-comment">            失败：返回-1 设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int lstat(const char *pathname, struct stat *statbuf);</span><br><span class="hljs-comment">        参数:</span><br><span class="hljs-comment">            - pathname：操作的文件的路径</span><br><span class="hljs-comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功：返回0</span><br><span class="hljs-comment">            失败：返回-1 设置errno</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>stat</code>和<code>lstat</code>的区别：当文件是一个符号链接时，<code>lstat</code>返回的是该符号链接本身的信息；而<code>stat</code>返回的是该链接指向的文件的信息。</p><p>stat 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-type">dev_t</span>st_dev;<span class="hljs-comment">// 文件的设备编号</span><br>    <span class="hljs-type">ino_t</span>st_ino;<span class="hljs-comment">// 节点</span><br>    <span class="hljs-type">mode_t</span>st_mode;<span class="hljs-comment">// 文件的类型和存取的权限</span><br>    <span class="hljs-type">nlink_t</span>st_nlink;<span class="hljs-comment">// 连到该文件的硬连接数目</span><br>    <span class="hljs-type">uid_t</span>st_uid;<span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-type">gid_t</span> st_gid;<span class="hljs-comment">// 组ID</span><br>    <span class="hljs-type">dev_t</span>st_rdev;<span class="hljs-comment">// 设备文件的设备编号</span><br>    <span class="hljs-type">off_t</span>st_size;      <span class="hljs-comment">// 文件字节数(文件大小)</span><br>    <span class="hljs-type">blksize_t</span>st_blksize;   <span class="hljs-comment">// 最优的 IO 块大小，Linux 为 4096B</span><br>    <span class="hljs-type">blkcnt_t</span>st_blocks;    <span class="hljs-comment">// 块数（以 512B 为单位，而不是 4096B，实际的物理意义应该是磁盘扇区数）</span><br>    <br>    <span class="hljs-type">time_t</span>st_atime;     <span class="hljs-comment">// 最后一次访问时间</span><br>    <span class="hljs-type">time_t</span>st_mtime;     <span class="hljs-comment">// 最后一次修改时间</span><br>    <span class="hljs-type">time_t</span>st_ctime;     <span class="hljs-comment">// 最后一次改变时间(指属性)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用stat命令查看文件的stat结构体（没有lstat命令）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121836144.png" alt="stat 命令"></p><p>hello.txt : Blocks &#x3D; 8K &#x2F; 512B &#x3D; 16</p><p>hello.prev: Blocks &#x3D; 4K &#x2F; 512B &#x3D; 8</p><p>st_mode 变量（16位）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208121841823.png" alt="st_mode 变量"></p><h4 id="文件属性的操作函数"><a href="#文件属性的操作函数" class="headerlink" title="文件属性的操作函数"></a>文件属性的操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>; <span class="hljs-comment">// 判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> mode)</span>; <span class="hljs-comment">// 修改文件的权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<span class="hljs-comment">// 修改文件所有者或者所在组</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>; <span class="hljs-comment">// 缩减或者扩展文件的尺寸至指定的大小，不会占用实际的物理内存，多余的部分实际上是一个文件空洞</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int access(const char *pathname, int mode);</span><br><span class="hljs-comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 判断的文件路径</span><br><span class="hljs-comment">            - mode:</span><br><span class="hljs-comment">                R_OK: 判断是否有读权限</span><br><span class="hljs-comment">                W_OK: 判断是否有写权限</span><br><span class="hljs-comment">                X_OK: 判断是否有执行权限</span><br><span class="hljs-comment">                F_OK: 判断文件是否存在</span><br><span class="hljs-comment">        返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    int chmod(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        修改文件的权限</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 需要修改的文件的路径</span><br><span class="hljs-comment">            - mode:需要修改的权限值，八进制的数</span><br><span class="hljs-comment">        返回值：成功返回0，失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    int truncate(const char *path, off_t length);</span><br><span class="hljs-comment">        作用：缩减或者扩展文件的尺寸至指定的大小，不会占用实际的物理内存，多余的部分实际上是一个文件空洞</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - path: 需要修改的文件的路径</span><br><span class="hljs-comment">            - length: 需要最终文件变成的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>lseek 和 truncate 的区别</strong></p><p>lseek 修改的是文件偏移量（读写位置），truncate修改的是文件的文件长度（逻辑大小），如果 lseek 文件偏移量大于文件之后不在该位置进行写入，则无法扩展文件长度（逻辑大小）。</p><p>lseek 和 truncate 产生的文件空洞都不会占用实际物理磁盘空间。</p><p>lseek 不进行写入：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208161819566.png" alt="lseek"></p><p>truncate：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208161820442.png" alt="truncate"></p><h4 id="目录的操作函数"><a href="#目录的操作函数" class="headerlink" title="目录的操作函数"></a>目录的操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    int mkdir(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        作用：创建一个目录</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            pathname: 创建的目录的路径</span><br><span class="hljs-comment">            mode: 权限，八进制的数</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功返回0， 失败返回-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int chdir(const char *path);</span><br><span class="hljs-comment">        作用：修改进程的工作目录</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            path : 需要修改的工作目录</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    char *getcwd(char *buf, size_t size);</span><br><span class="hljs-comment">        作用：获取当前工作目录</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span><br><span class="hljs-comment">            - size: 数组的大小</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            返回的指向的一块内存，这个数据就是第一个参数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="目录的遍历函数"><a href="#目录的遍历函数" class="headerlink" title="目录的遍历函数"></a>目录的遍历函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 此目录进入点的inode</span><br>    <span class="hljs-type">ino_t</span> d_ino; <br>    <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>    <span class="hljs-type">off_t</span> d_off;   <br>    <span class="hljs-comment">// d_name 的长度, 不包含NULL字符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> d_reclen; <br>    <span class="hljs-comment">// d_name 所指的文件类型</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_type;   <br>    <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-type">char</span> d_name[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">d_type</span><br><span class="hljs-comment">    DT_BLK - 块设备</span><br><span class="hljs-comment">    DT_CHR - 字符设备</span><br><span class="hljs-comment">    DT_DIR - 目录</span><br><span class="hljs-comment">    DT_LNK - 软连接</span><br><span class="hljs-comment">    DT_FIFO - 管道</span><br><span class="hljs-comment">    DT_REG - 普通文件</span><br><span class="hljs-comment">    DT_SOCK - 套接字</span><br><span class="hljs-comment">    DT_UNKNOWN - 未知</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 打开一个目录</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;dirent.h&gt;</span><br><span class="hljs-comment">    DIR *opendir(const char *name);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - name: 需要打开的目录的名称</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            DIR * 类型，理解为目录流</span><br><span class="hljs-comment">            错误返回NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 读取目录中的数据</span><br><span class="hljs-comment">    #include &lt;dirent.h&gt;</span><br><span class="hljs-comment">    struct dirent *readdir(DIR *dirp);</span><br><span class="hljs-comment">        - 参数：dirp是opendir返回的结果</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            struct dirent，代表读取到的文件的信息</span><br><span class="hljs-comment">            读取到了末尾或者失败了，返回NULL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 关闭目录</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;dirent.h&gt;</span><br><span class="hljs-comment">    int closedir(DIR *dirp);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>读取某个目录下所有的普通文件的个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// #define __USE_MISC </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span>;<br><br><span class="hljs-comment">// 读取某个目录下所有的普通文件的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s path\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> num = getFileNum(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;普通文件的个数为：%d\n&quot;</span>, num);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 用于获取目录下所有普通文件的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * path)</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开目录</span><br>    DIR * dir = opendir(path);<br><br>    <span class="hljs-keyword">if</span>(dir == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;opendir&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> *<span class="hljs-title">ptr</span>;</span><br><br>    <span class="hljs-comment">// 记录普通文件的个数</span><br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>((ptr = readdir(dir)) != <span class="hljs-literal">NULL</span>) &#123;<br><br>        <span class="hljs-comment">// 获取名称</span><br>        <span class="hljs-type">char</span> * dname = ptr-&gt;d_name;<br><br>        <span class="hljs-comment">// 忽略掉. 和..</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dname, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dname, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断是否是普通文件还是目录</span><br>        <span class="hljs-keyword">if</span>(ptr-&gt;d_type == DT_DIR) &#123;<br>            <span class="hljs-comment">// 目录,需要继续读取这个目录</span><br>            <span class="hljs-type">char</span> newpath[<span class="hljs-number">256</span>];<br>            <span class="hljs-built_in">sprintf</span>(newpath, <span class="hljs-string">&quot;%s/%s&quot;</span>, path, dname);<br>            total += getFileNum(newpath);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;<br>            <span class="hljs-comment">// 普通文件</span><br>            total++;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 关闭目录</span><br>    closedir(dir);<br><br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dup、dup2"><a href="#dup、dup2" class="headerlink" title="dup、dup2"></a>dup、dup2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<span class="hljs-comment">// 复制文件描述符，返回最小的未使用的文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<span class="hljs-comment">// 重定向文件描述符</span><br></code></pre></td></tr></table></figure><p>dup 函数示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int dup(int oldfd);</span><br><span class="hljs-comment">        作用：复制一个新的文件描述符</span><br><span class="hljs-comment">        fd=3, int fd1 = dup(fd),</span><br><span class="hljs-comment">        fd指向的是a.txt, fd1也是指向a.txt</span><br><span class="hljs-comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br><br>    <span class="hljs-type">int</span> fd1 = dup(fd); <span class="hljs-comment">// 关闭文件描述符</span><br><br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;dup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);<br><br>    close(fd);<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">// 通过 fd1 向文件中写入 &quot;hello,world&quot;</span><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dup2 函数示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int dup2(int oldfd, int newfd);</span><br><span class="hljs-comment">        作用：重定向文件描述符, 复制文件描述符并指定新的文件描述符为 newfd</span><br><span class="hljs-comment">        调用函数成功后 oldfd 指向 a.txt, newfd 指向 b.txt</span><br><span class="hljs-comment">        如果 newfd 本身和 b.txt 关联，则在复制文件描述符前关闭文件描述符 newfd，使其不再指向 b.txt，然后将其重新指向a.txt</span><br><span class="hljs-comment">        oldfd 必须是一个有效的文件描述符</span><br><span class="hljs-comment">        oldfd 和 newfd值相同，相当于什么都没有做</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);<br><br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;dup2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello, dup2&quot;</span>;<br>    <span class="hljs-type">int</span> len = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);<br><br>    close(fd);<br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;<br><span class="hljs-comment">// 使用 cmd 操作文件文件描述符，如复制文件描述符、设置/获取文件的状态标志等</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    #include &lt;fcntl.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int fcntl(int fd, int cmd, ...);</span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        fd : 表示需要操作的文件描述符</span><br><span class="hljs-comment">        cmd: 表示对文件描述符进行如何操作</span><br><span class="hljs-comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="hljs-comment">                int ret = fcntl(fd, F_DUPFD);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="hljs-comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="hljs-comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="hljs-comment">              可选性：O_APPEND, O)NONBLOCK</span><br><span class="hljs-comment">                O_APPEND 表示追加数据</span><br><span class="hljs-comment">                NONBLOK 设置成非阻塞</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        阻塞和非阻塞：描述的是函数调用的行为。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2.修改或者获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件描述符状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    flag |= O_APPEND;   <span class="hljs-comment">// flag = flag | O_APPEND</span><br><br>    <span class="hljs-comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 升级 gcc-11</title>
    <link href="/posts/334154d9/"/>
    <url>/posts/334154d9/</url>
    
    <content type="html"><![CDATA[<h2 id="ubuntu-更新-gcc、-g-："><a href="#ubuntu-更新-gcc、-g-：" class="headerlink" title="ubuntu 更新 gcc、 g++："></a>ubuntu 更新 gcc、 g++：</h2><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install build-essential manpages-dev software-properties-common<br>sudo add-apt-repository ppa:ubuntu-toolchain-r/test<br>sudo add-apt-repository &#x27;deb http://mirrors.kernel.org/ubuntu hirsute main universe&#x27;<br>sudo apt update &amp;&amp; sudo apt install gcc-11 g++-11<br></code></pre></td></tr></table></figure><p>多版本管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 50 --slave /usr/bin/g++ g++ /usr/bin/g++-11<br><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 10 --slave /usr/bin/g++ g++ /usr/bin/g++-9<br><br></code></pre></td></tr></table></figure><p>设置默认gcc版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --config gcc<br></code></pre></td></tr></table></figure><h2 id="更新gdb-11"><a href="#更新gdb-11" class="headerlink" title="更新gdb-11"></a>更新gdb-11</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install libgmp-dev<br>wget http://ftp.gnu.org/gnu/gdb/gdb-11.1.tar.gz<br>tar -xvzf gdb-11.1.tar.gz<br>./configure<br>sudo make &amp;&amp; sudo make install<br></code></pre></td></tr></table></figure><p>可能要安装textinfo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install texinfo<br></code></pre></td></tr></table></figure><p>替换老版本，新生成的gdb二进制文件会在编译目录gdb-10.2&#x2F;gdb&#x2F;gdb ，将其拷贝到&#x2F;usr&#x2F;bin&#x2F;，替换原来的，也可以将原来的做个备份，以防出问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /usr/local/bin/gdb /usr/local/bin/gdb_bak<br>cp ~/gdb-11.1/gdb/gdb /usr/local/bin/<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>mysql 8 修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/posts/f89cb603/"/>
    <url>/posts/f89cb603/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h1><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><p>二叉搜索树（BST）具备以下特性（规则）：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。</li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉搜索树。</li></ol><p>在BST中最大比较次数为树的高度，树的高度范围为 $[log(n), n]$。 </p><p>当树中每个结点左、右子树高度大致相同时，树高为 $\text{log}(n)$ ，则平均查找长度与 $\text{log}(n)$ 成正比，查找的平均时间复杂度在 $O(\text{log}n)$ 数量级上。</p><p>当树形结构为一个单子树时，此时树高 $n$ ，则平均查找长度为 $(n+1)&#x2F;2$ ，查找的平均时间复杂度在 $O(n)$ 数量级上。</p><p>相同序列构成的不同二叉搜索树：<a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树 - 力扣（LeetCode）</a></p><h2 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h2><p>平衡二叉查找树的出现，主要是为了解决<strong>当二叉树查找树形态结构变成一个链条结构的时候，查找效率变低的问题</strong>，算法由<code>Adel&#39;son-Vel&#39;skii</code>和<code>Landis</code>发明，同时也称<code>AVL</code>树，特性（规则）如下：</p><ol><li><p>它的左子树和右子树都是平衡二叉树；</p></li><li><p>且它的左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。</p></li></ol><p>AVL是严格平衡的BST（平衡因子不超过1）。查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是 $O(\text{log}n)$ 。</p><p>$$<br>balance\  factor &#x3D; height\ of\ left\ subtree - height\ of\ right\ subtree \<br>bf &#x3D; {-1, 0, 1} \<br>|bf| &#x3D; |hl - hr| \le 1 \<br>$$</p><p>AVL 的旋转：</p><ol><li>LL-imbalance：由于在左子树的左子树插入或删除而导致的不平衡，进行LL-Rotation；</li><li>LR-imbalance：由于在左子树的右子树插入或删除而导致的不平衡，进行LR-Rotation；</li><li>RR-imbalance：由于在右子树的右子树插入或删除而导致的不平衡，进行RR-Rotation；</li><li>RL-imbalance：由于在右子树的左子树插入或删除而导致的不平衡，进行RL-Rotation。</li></ol><p>在插入、删除树节点的时候，<strong>AVL树会自动进行调整</strong>。也就是说，AVL树，本质上是<strong>带了平衡功能的二叉查找树</strong>（二叉排序树，二叉搜索树）。AVL在每次插入节点时对树进行检查和调整，AVL的旋转每次只涉及以imbalance节点为根节点的3个节点（如下图）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031408586.png" alt="AVL树的旋转-插入42"></p><p>以 LL-Rotation 和 LR-Rotation 为例（假设图中节点A为第一个 $|bf| \neq 1$ 的节点）：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031412866.png" alt="LL-Rotation"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031413467.png" alt="LR-Rotation"></p><p>给定节点数为 $n$ 的AVL树，最大高度为 $\text{log}(2n)$ ，而不是 $n$。</p><p>平衡二叉搜索树解决二叉搜索树的问题，保证了不会成为线性的链表。<br>左结点小于根节点，右结点大于根节点，并且还规定了左子树和右子树的高度差不得超过1。</p><p>但其仍然存在问题：</p><ol><li>由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。</li><li>每一个节点只能存放一个元素，每个节点只有两个子节点，所以查找时，需要多次磁盘IO（如果数据存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页。）</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>视频：<a href="https://www.youtube.com/watch?v=aZjYr87r1b8">10.2 B Trees and B+ Trees. How they are useful in Databases - YouTube</a></p><p>B 树的基本思想：多级索引</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031643643.png" alt="多级索引"></p><p>一个m阶的B树的规则：</p><ol><li>根结点至少有两个子树（1个索引）；</li><li>每个中间节点都包含 $k-1$ 个元素和 $k$ 个孩子，其中 $m&#x2F;2 \le k \le m$  ；</li><li>每一个叶子节点都包含 $k-1$ 个元素，其中 $m&#x2F;2 \le k \le m$  ；</li><li>所有的叶子结点都位于同一层；</li><li>每个节点中的元素从小到大排列，节点当中 $k-1$ 个元素正好是 $k$ 个孩子包含的元素的值域分划。</li></ol><p>4阶B树，例子：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031545671.png" alt="B树的构建"></p><h2 id="2-3-4-树"><a href="#2-3-4-树" class="headerlink" title="2-3-4 树"></a>2-3-4 树</h2><p>2-3-4 树 是 四阶 B树，它是一种多路查找树，其结构有以下限制：</p><ol><li>所有叶子节点具有相同的深度；</li><li>节点只能是2-节点、3-节点和4-节点之一：<ul><li>2-节点：包含1个元素的节点，有2个子树；</li><li>3-节点：包含2个元素的节点，有3个子树；</li><li>4-节点：包含3个元素的节点，有4个子树。</li></ul></li><li>所有节点必须至少包含一个元素；</li><li>元素始终保持排序顺序 ，整体上保持二叉搜索树的性质，即父节点的值大于左子树所有节点，小于右子树所有节点；</li><li>节点有多个元素时，每个元素必须大于它左边的和左子树中的元素。</li></ol><p>例：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031651195.png" alt="2-3-4树"></p><p>2-3-4树的实现在一些编程语言中较为困难，一般使用其等同的红黑树。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>视频：<a href="https://www.bilibili.com/video/BV1j44y1q7k8?p=1&vd_source=88ba307806f3a95297a7d08a098d6a4b">【完整版】最全最新红黑树讲解，数组、链表、二叉树、AVL树、红黑树哔哩哔哩_bilibili</a></p><h2 id="2-3-4-树和红黑树的等价关系"><a href="#2-3-4-树和红黑树的等价关系" class="headerlink" title="2-3-4 树和红黑树的等价关系"></a>2-3-4 树和红黑树的等价关系</h2><p>2-3-4 树和红黑树的等价关系：</p><ol><li>2-节点对应RB-Tree黑节点；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712340.png" alt="2-节点"></p><ol start="2"><li>3-节点对应RB-Tree上黑下红（分为左倾和右倾两种）；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031712317.png" alt="3-节点"></p><ol start="3"><li>4-节点对应RB-Tree上黑下红。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031713313.png" alt="4-节点"></p><p>2-3-4 树到红黑树的转换：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031756841.png" alt="2-3-4 树到红黑树（左倾）"></p><p>平衡二叉查找树通过严格平衡策略，以牺牲建立查找结构的代价换来了稳定的查找时间复杂度。但是相对来说，在删除方面，时间复杂度稍大。而红黑树不严格控制左、右子树高度或节点数之差小于等于1。</p><h2 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h2><p>红黑树是自平衡（不严格限制）的二叉搜索树， <strong>红黑树的5条规则：</strong></p><ol><li>节点要么是黑色要么是红色；</li><li>根节点是黑色；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>每个红色节点的两个子节点都是黑色（也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点）；</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍，因而，红黑树是相对的接近平衡的二叉树，但是相比平衡二叉树而言，尤其是删除的时间复杂度，有所降低）。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208031616562.png" alt="红黑树"></p><p><strong>分析：</strong></p><ol><li>第2条特性：从 2-3-4 树到红黑树的转换中，根节点要么是2-节点（黑色），要么是3-节点或4-节点分裂出的（上黑）；</li><li>第5条特性：从 2-3-4 树到红黑树的转换中，可以看出2-3-4 树的每个节点中有且仅有一个黑色元素，由于B树中所有的叶子结点都位于同一层，所以从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（2-3-4树的高度+1）。</li></ol><p>红黑树在查找方面和AVL树操作几乎相同。牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。任何不平衡都会在三次旋转之内解决。<br>确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证 $O(\text{log}n)$ 。</p><p>红黑树的通过旋转和染色来自平衡。</p><h2 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h2><p>红黑树的查找与二叉树搜索树的查找一样。</p><h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/166319823">红黑树的原理 (插入+ 删除) 案例分析 - 知乎 (zhihu.com)</a></p><p>向红黑树中插入新的结点。具体做法是：</p><ol><li>将新结点的 color 赋为红色，然后以二叉排序树的插入方法插入到红黑树中去。之所以将新插入的结点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。</li><li>通过颜色调换和树旋转来调整可能会出现两个连续红色节点的冲突。</li></ol><p>插入不同的情况：</p><ol><li>插入根节点；</li><li>插入节点的父节点为黑色；</li><li>插入节点的父节点为红色，叔节点也为红色；</li><li>插入节点的父节点是红色，叔节点是黑色：<ol><li>左左插入</li><li>左右插入</li><li>右右插入</li><li>右左插入</li></ol></li></ol><p>具体操作：</p><ol><li><p>插入根结点：直接染黑。</p></li><li><p>插入节点的父节点为黑色，没有出现两个连续红色节点的冲突，不需要调整。</p></li><li><p>插入节点的父节点为红色，叔节点也为红色，不需要旋转，直接染色，注意递归向上调整。</p><p>分析：插入N之前，N所在的位置必为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点必为 NIL</strong>。插入新节点之后树仍是平衡的，所以不需要旋转。</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032144818.png" alt="case 3"></p><ol start="4"><li><p>插入节点的父节点是红色，叔节点是黑色:</p><ol><li><p>左左插入，左旋</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LL-imbalance，需要进行LL-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032202879.png" alt="case 4-1"></p></li><li><p>左右插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为LR-imbalance，需要进行LR-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032207490.png" alt="case4-2"></p></li><li><p>右右插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RR-imbalance，需要进行RR-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032213353.png" alt="case4-3"></p></li><li><p>右左插入</p><p>分析：插入N之前，N所在的位置为NIL，由于插入之前也是一棵 RB-Tree，则 <strong>B 节点与 U 节点必为 NIL</strong>。插入新节点之后树为RL-imbalance，需要进行RL-Rotation。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208032318044.png" alt="case4-4"></p></li></ol></li></ol><p>总结：根据平衡二叉树正常插入节点之后根据平衡判断是否需要旋转，若不需要旋转，则将 <code>Parent</code> 和 <code>Uncle</code> 染黑，<code>GrandParent</code> 染红，再递归向上调整；若不平衡，则根据情况进行旋转，旋转之后上黑（新的 <code>GrandParent</code> ）下红染色。</p><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><p>参考：<a href="https://www.bilibili.com/video/BV1KA41187v6?vd_source=88ba307806f3a95297a7d08a098d6a4b">红黑树删除_bilibili</a></p><p>删除不同的情况：</p><ol><li>删除叶节点，且叶节点为红色，无需调整；</li><li>删除叶节点，叶节点为黑色，需要调整；</li><li>删除节点非叶节点，若该节点只有一个子节点，则用该子节点替代删除节点；若该节点有两个子节点，则将要删除的节点与其前驱或者后继节点进行替代。此时情况变为1或2（根据实际被删除的节点的颜色决定）。</li></ol><p>情况2若删除后不平衡则需要根据AVL旋转规则旋转后染色，否则直接染色。</p><p>如果不旋转，则将兄弟节点设置为红色，将父节点设置为当前节点递归，直到根节点，或遇到红色节点；如果旋转，则旋转之后 <code>Parent</code> 位置的颜色不变，其他位置根据黑色节点个数进行调整。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/posts/735e5788/"/>
    <url>/posts/735e5788/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022027979.png" alt="概览"></p><p>排序算法主要可根据 <strong>稳定性</strong> 、<strong>就地性</strong> 、<strong>自适应性</strong> 分类。理想的排序算法具有以下特性：</p><ul><li>具有稳定性，即相等元素的相对位置不变化；</li><li>具有就地性，即不使用额外的辅助空间；</li><li>具有自适应性，即时间复杂度受元素分布影响。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>算法步骤：</strong></p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022027854.gif" alt="冒泡排序"></p><p>冒泡排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort1</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort2</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-type">bool</span> swapped = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><br><span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果上一轮没有发生交换，则说明已经有序</span><br><br>swapped = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>swapped = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>算法步骤</strong><br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028501.gif" alt="选择排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-type">int</span> minIdx = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &gt; arr[j]) &#123;<br>minIdx = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>算法步骤：</strong><br>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028731.gif" alt="插入排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> key = arr[i];<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key)<br>&#123;<br>arr[j + <span class="hljs-number">1</span>] = arr[j--];<br>&#125;<br>arr[j + <span class="hljs-number">1</span>] = key;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p><strong>算法步骤：</strong><br>选择一个增量序列 <code>t1, t2, ..., tk</code>，其中 <code>ti &gt; tj, tk = 1</code>；<br>按增量序列个数 <code>k</code>，对序列进行 <code>k</code> 趟排序；<br>每趟排序，根据对应的增量 <code>ti</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022028025.gif" alt="希尔排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 希尔排序，优化版的插入排序</span><br><span class="hljs-comment">// 每次组内排序必须用插入排序或者冒泡排序（优化过的），插入排序和冒泡排序对“基本有序”的序列排序接近O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;T&gt;&amp; array)</span> </span>&#123;<br>    <span class="hljs-type">int</span> gap = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n = array.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (gap &lt; n / <span class="hljs-number">3</span>) <span class="hljs-comment">// 确定分组间隔</span><br>    &#123;<br>        gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (gap &gt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> key = array[i];<br>            <span class="hljs-type">int</span> j = i - gap;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; key &lt; array[j])<br>            &#123;<br>                array[j + gap] = array[j];<br>                j -= gap;<br>            &#125;<br>            array[j + gap] = key;<br>        &#125;<br>        gap = gap / <span class="hljs-number">3</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022029938.gif" alt="归并排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> left ,<span class="hljs-type">int</span> right)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(left &gt;= right)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 划分</span><br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(vec, left, mid);     <span class="hljs-comment">// [l,mid] 有序</span><br>    <span class="hljs-built_in">mergeSort</span>(vec, mid + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// [mid+1,r] 有序</span><br><br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(vec.begin()+left, vec.begin()+right + <span class="hljs-number">1</span>)</span></span>; <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = left; k &lt;= right; ++k)&#123;<br>        <span class="hljs-keyword">if</span>(left + i &gt; mid) &#123;<br>            vec[k] = tmp[j++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left + j &gt; right || tmp[i] &lt;= tmp[j]) <span class="hljs-comment">// &lt;= 稳定</span><br>        &#123;<br>            vec[k] = tmp[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vec[k] = tmp[j++];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022029722.gif" alt="快速排序"></p><p>算法步骤：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partitionVec</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 以 vec[l] 作为基准</span><br>    <span class="hljs-type">int</span> i = l;<br>    <span class="hljs-type">int</span> j = r;<br><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; vec[j] &gt;= vec[l])<br>            --j;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; vec[i] &lt;= vec[l])<br>            ++i;<br>        <span class="hljs-built_in">swap</span>(vec[i], vec[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">swap</span>(vec[l], vec[i]);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 子数组的长度为 1 时终止递归</span><br>    <span class="hljs-keyword">if</span>(l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 哨兵划分</span><br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partitionVec</span>(vec, <span class="hljs-number">0</span>, vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 左右数组递归</span><br>    <span class="hljs-built_in">quickSort</span>(vec, l, pos - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quickSort</span>(vec, pos + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用<strong>堆</strong>这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于<strong>升序排列</strong>（递增数组）；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于<strong>降序排列</strong>（递减数组）。</li></ol><p>堆排序的平均时间复杂度为 $O(n\text{log}n)$。</p><p>算法步骤：</p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022107615.gif" alt="堆排序演示"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022108887.gif" alt="堆排序"></p><p>一般用数组存储堆结构：</p><p>下标为 $i$ 的节点的父节点下标为 $(i-1)&#x2F;2$ ；</p><p>下标为 $i$ 的节点的左子节点下标为 $i \times 2 + 1$ ；</p><p>下标为 $i$ 的节点的右子节点下标为 $i \times 2 + 1$ 。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> parent = start;<br>    <span class="hljs-type">int</span> child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子节点下标</span><br><br>    <span class="hljs-keyword">while</span> (child &lt;= end)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(child + <span class="hljs-number">1</span> &lt;= end &amp;&amp; vec[child] &lt; vec[child + <span class="hljs-number">1</span>])<br>            ++child;<br><br>        <span class="hljs-keyword">if</span> (vec[parent] &gt; vec[child]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">swap</span>(vec[parent], vec[child]);<br>            parent = child;<br>            child = parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(vector&lt;T&gt; &amp;vec)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = vec.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">max_heapify</span>(vec, i, len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化堆，从最后一个根结点开始调整</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">swap</span>(vec[<span class="hljs-number">0</span>], vec[i]); <span class="hljs-comment">// 将跟节点（最大元素）与最后一个元素交换</span><br>        <span class="hljs-built_in">max_heapify</span>(vec, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 将堆的尺寸缩小 1，再进行调整</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="基数排序-1"><a href="#基数排序-1" class="headerlink" title="基数排序"></a>基数排序</h1>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录刷题笔记</title>
    <link href="/posts/9813b472/"/>
    <url>/posts/9813b472/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>题目列表：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>          </div><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><p>常用算法</p><ul><li>二分</li><li>双指针</li><li>滑动窗口</li><li>模拟</li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><table><thead><tr><th>暴力</th><th>$O(n)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(\text{log}n)$</td></tr></tbody></table><p>二分的前提是数组是有序的，二分法每次能排除一半的元素，时间复杂度为 $O(\text{log}n)$。<br>使用二分法是要注意解是否包含在左右边界中，在循环中，区间的定义不能改变（区间的开闭）。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><table><thead><tr><th>暴力</th><th>$O(n^2)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(n)$</td></tr></tbody></table><ul><li>快慢指针（追击）</li><li>相向指针（相遇）</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><table><thead><tr><th>暴力</th><th>$O(n^2)$</th></tr></thead><tbody><tr><td>二分</td><td>$O(n)$</td></tr></tbody></table><p>理解滑动窗口如何移动、窗口起始位置、如何更新窗口大小。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>注意状态更新和数组越界。</p><h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><p>常用技巧：虚拟头结点</p><p>常见题型：</p><ol><li>反转链表<ol><li>迭代</li><li>递归</li></ol></li><li>删除倒数第 $n$个节点、<ol><li>快慢指针</li></ol></li><li>链表相交<ol><li>双指针</li><li>哈希表</li></ol></li><li>环形链表<ol><li>快慢指针</li><li>哈希表</li></ol></li></ol><p>注意nullptr。</p><h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><ol><li>不同的数据通过哈希函数映射到统一索引的现象叫<strong>哈希碰撞</strong>，一般的解决方法有<ol><li>拉链法</li><li>线性探测法</li></ol></li><li>哈希法解决问题一般选择的数据结构：<ol><li>数组</li><li>set</li><li>map</li></ol></li></ol><table><thead><tr><th><strong>集合</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><table><thead><tr><th><strong>映射</strong></th><th><strong>底层实现</strong></th><th><strong>是否有序</strong></th><th><strong>数值是否可以重复</strong></th><th><strong>能否更改数值</strong></th><th><strong>查询效率</strong></th><th><strong>增删效率</strong></th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>$O(\text{log}n)$</td><td>$O(\text{log}n)$</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><ol><li>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</li></ol><h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>双指针</p><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>模拟</p><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>空间复杂度$O(1)$解法：<br>首先扩充数组到每个空格替换成”%20”之后的大小。然后从后向前替换空格，也就是双指针法。</p><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p>空间复杂度$O(1)$解法：</p><ol><li>移除多余空格（快慢指针）</li><li>将整个字符串反转</li><li>将每个单词反转</li></ol><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>空间复杂度$O(1)$解法：</p><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><p>重要<strong>Knuth-Morris-Pratt (KMP) 字符串查找算法</strong><br>暴力算法：$O(m\times n)$<br>KMP算法：$O(m+n)$</p><ol><li><strong>主要思想：</strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li><strong>前缀表：</strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。<br>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪个位置开始重新匹配。</li><li>**最长公共前后缀<br>**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。<br>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。<br><code>aabaa</code>的最长 ~~公共 ~~相同 前后缀为 <code>aa</code>，长度为2。</li><li>模式串与前缀表对应位置的数字表示的是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022020803.png" alt="字符串匹配"></p><p>当<code>s[i]</code>不匹配时，应该回退到前缀表 <code>next[i-1]</code>中记录的下标位继续匹配。</p><ol><li>构造next数组<br>构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：<ol><li>初始化</li><li>处理前后缀不相同的情况：回退</li><li>处理前后缀相同的情况：匹配长度+1</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// j 指向前缀末尾位置(前缀长度)</span><br>    next[<span class="hljs-number">0</span>] = j; <span class="hljs-comment">// next[i] 表示 i(包括i)之前最长相等的前后缀长度（其实就是j）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// i 指向后缀末尾位置，注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        &#125;<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何回退？</strong>举例子:</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022021543.png" alt="KMP回退"></p><p><code>B</code>和<code>C</code>不匹配，发生回退，要找到与后缀 <code>ABA</code>相同部分最长的前缀，其实等同于找到找到左边部分的最长相等前缀，即为<code>n[j-1]</code>。</p><ol><li>使用前缀表进行匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-built_in">getNext</span>(next, needle);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// // 因为next数组里记录的起始位置为-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i就从0开始</span><br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 不匹配</span><br>            j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>            j++; <span class="hljs-comment">// i的增加在for循环里</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == (needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) &#123; <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>            <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>思路：构建<code>next</code>数组，<strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>双指针</li></ol><ul><li>反转字符串</li><li>替换空格，先给数组扩容再从后向前操作</li><li>移除元素，快慢指针</li></ul><p>erase是$O(n)$的操作，放在<code>for</code>循环里会导致 $O(n^2)$的复杂度。</p><ol start="2"><li>反转</li><li>KMP：字符串匹配问题</li></ol><h1 id="五、双指针"><a href="#五、双指针" class="headerlink" title="五、双指针"></a>五、双指针</h1><ol><li>数组<br>移除元素，通过两个指针在一个for循环内完成两个for循环的工作</li><li>字符串<ol><li>反转</li><li>扩充</li><li>移除</li></ol></li><li>链表<ol><li>快慢指针</li></ol></li><li>N数之和<ol><li>排序 + 双指针 + <strong>剪枝（注意剪枝条件）</strong></li></ol></li></ol><h1 id="六、栈和队列"><a href="#六、栈和队列" class="headerlink" title="六、栈和队列"></a>六、栈和队列</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><ol><li><p>C++标准库是有多个版本的，以下为三个最为普遍的STL版本：</p><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol></li><li><p>栈是以底层容器完成其所有的工作，<strong>对外提供统一的接口</strong>，底层容器是可插拔的（也就是说我们可以控制<strong>使用哪种容器</strong>来实现栈的功能）。所以STL中栈往往<strong>不被归类为容器</strong>，而被归类为container adapter（容器适配器）。我们常用的SGI STL，如果没有指定底层实现的话，默认是<strong>以deque为缺省</strong>情况下栈的低层结构。也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></table></figure></li><li><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，SGI STL中队列一样是以deque为缺省情况下的底部结构。所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p></li></ol><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">力扣题目链接</a><br>stkIn：队尾元素<br>stkOut：队首元素</p><ol><li>push() ：直接压入stkIn。</li><li>pop() ：先peek()，再stkOut.pop()。</li><li>peek()：若stkB不为空，直接返回stkOut.top()；否则将stkIn的元素全部压入stkOut中，再返回stkOut.top()。</li><li>empty() ：若stkIn与stkOut均为空则为空。</li></ol><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>deque实现单调栈。</p><h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p>priority_queue 容器适配器定义了一个元素有序排列的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。但是如何定义“优先级”完全取决于我们自己。<br>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Container=std::vector&lt;T&gt;, <span class="hljs-keyword">typename</span> Compare=std::less&lt;T&gt;&gt; <span class="hljs-keyword">class</span> priority_queue;<br><span class="hljs-comment">// less&lt;T&gt; 大顶堆 </span><br><span class="hljs-comment">// greater&lt;T&gt; 小顶堆</span><br></code></pre></td></tr></table></figure><p>priority_queue 实例默认有一个 vector 容器。函数对象类型 less<T> 是一个默认的<strong>排序断言</strong>，定义在头文件 functional中，决定了容器中最大的元素会排在队列前面。functional中定义了  greater<T>，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，<strong>如果指定模板的最后一个参数，就必须提供另外的两个模板类型参数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m.second &gt; n.second; <span class="hljs-comment">// 小顶堆</span><br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; occurrences;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : nums) &#123;<br>            occurrences[v]++;<br>        &#125;<br><br>        <span class="hljs-comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(&amp;cmp)&gt; <span class="hljs-built_in">q</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [num, count] : occurrences) &#123;<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() == k) &#123;<br>                <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">top</span>().second &lt; count) &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">emplace</span>(num, count);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                q.<span class="hljs-built_in">emplace</span>(num, count);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ret.<span class="hljs-built_in">emplace_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>提问：</p><ol><li>C++中stack，queue 是容器么？</li><li>我们使用的stack，queue是属于那个版本的STL？</li><li>我们使用的STL中stack，queue是如何实现的？</li><li>stack，queue 提供迭代器来遍历空间么？</li></ol><p>栈里面的元素在内存中是连续分布的么？</p><ul><li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。</li><li>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，</li></ul><h1 id="七、二叉树"><a href="#七、二叉树" class="headerlink" title="七、二叉树"></a>七、二叉树</h1><h2 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h2><p><strong>一、二叉树的种类</strong></p><ol><li>满二叉树<ol><li>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</li><li>每层的节点数为$2^{k-1}$。</li><li>深度为$k$的满二叉树节点个数为$2^0+2^1+ \cdots + 2^{k-1} &#x3D; 2^k -1$。</li></ol></li><li>完全二叉树<ol><li>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</li><li>若最底层为第 h 层，则该层包含 $[1,2^{h-1}]$  个节点。</li></ol></li><li>二叉搜索树<br>二叉搜索树是一个有序树：<ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ol></li><li>平衡搜索二叉树<ol><li>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：<ol><li>它是一棵空树或它的<strong>左右两个子树的高度差的绝对值不超过1。</strong></li><li>左右两个子树都是一棵平衡二叉树。</li></ol></li><li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（具体来说是红黑树）</strong>，所以map、set的增删操作时间时间复杂度是$logn(0)$。unordered_map、unordered_set，unordered_map、unordered_map底层实现是<strong>哈希表</strong>。</li></ol></li></ol><p><strong>二、二叉树的存储方式</strong></p><ol><li>链式存储（指针）</li><li>顺序存储（数组）<ol><li>对于完全二叉树，如果父节点的数组下标是 $i$，那么它的左孩子就是 $2i+1$，右孩子就是 $2i+2$。</li></ol></li></ol><p><strong>三、二叉树的遍历方式</strong></p><ol><li>深度优先（前中后指<strong>中间节点的遍历顺序</strong>）<ol><li>前序遍历（迭代、递归）</li><li>中序遍历（迭代、递归）</li><li>后续遍历（迭代、递归）</li></ol></li><li>广度优先<ol><li>层次遍历（迭代）</li></ol></li></ol><p><strong>DFS两种实现</strong></p><ol><li>递归三要素：<ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol></li><li>迭代：<ol><li>前序：处理顺序与访问顺序一致<ol><li>先处理根结点</li><li>right入栈、left入栈<strong>（空节点不入栈，出栈顺序中左右）</strong></li></ol></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(root);<br><br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>中序：处理顺序与访问顺序不一致</p><ol><li>根结点入栈、left（不为空）入栈</li><li>弹栈访问数据</li><li>right（不为空）入栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode* cur = root;<br><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> || !stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            stk.<span class="hljs-built_in">emplace</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>后序：处理顺序与访问顺序一致</p><ol><li>right入栈、left入栈<strong>（空节点不入栈，出栈顺序左右中）</strong></li><li>弹栈访问数据</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>    stk.<span class="hljs-built_in">emplace</span>(root);<br>    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* cur = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) stk.<span class="hljs-built_in">emplace</span>(cur-&gt;right);<br>    &#125; <br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BFS实现：</strong><br>队列</p><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>比较<code>leftNode-&gt;left</code>与<code>rightNode-&gt;right</code>、<code>leftNode-&gt;right</code>与<code>rightNode-&gt;left</code>。</p><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><blockquote><p>类似题目：剑指 Offer 07. 重建二叉树</p></blockquote><p>后序遍历的顺序为：左右中<br>后序遍历<code>postorder</code>的最后一个元素为当前根节点<code>root</code>，在中序遍历搜索<code>root</code>的索引，可将中序遍历<code>inorder</code>划分为<code>[leftTree | root | rightTree]</code>，随即可求出<code>leftTree</code>和<code>rightTree</code>的长度，根据子树长度可将后序遍历划分为<code>leftTree | rightTree | root</code>。由于构建二叉树时确定的是<code>postorder</code>中的<code>root</code>位置和子树长度，所以右子树的根节点为<code>root-1</code>，左子树的根节点为<code>root - 1 - rightLen</code>。<br>递归构建二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-comment">// inorder 根结点左侧为左子树，右侧为右子树</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>            dict[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bulid</span>(inorder, postorder, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">bulid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[i]);<br>        <span class="hljs-type">int</span> rootIdx = dict[postorder[i]];  <br>        root-&gt;left = <span class="hljs-built_in">bulid</span>(inorder, postorder, i - <span class="hljs-number">1</span> - (r - rootIdx), l, rootIdx - <span class="hljs-number">1</span>); <span class="hljs-comment">// (r - rootIdx) 为右子树长度</span><br>        root-&gt;right = <span class="hljs-built_in">bulid</span>(inorder, postorder, i - <span class="hljs-number">1</span>, rootIdx + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同理，前序遍历是构建二叉树时确定的是<code>preorder</code>中的<code>root</code>位置和子树长度，所以左子树的根节点为<code>root+1</code>，左子树的根节点为<code>root + 1 + leftLen</code>。</p><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><ol><li>二叉树的理论基础<ol><li>二叉树的种类</li><li>存储方式：链式、顺序</li><li>遍历方式</li><li>定义方式</li></ol></li><li>二叉树的遍历方式<ol><li>深度（递归、迭代）</li><li>广度（队列）</li></ol></li><li>求二叉树的属性<ol><li>是否对称</li><li>深度</li><li>节点数</li><li>平衡（优先递归，迭代效率低）</li><li>路径（回溯）</li><li>左下角的值</li></ol></li><li>二叉树的修改与构造<ol><li>翻转</li><li>构造（优先递归）</li><li>合并</li></ol></li><li>求二叉搜索树的属性<ol><li>中序遍历，有序数组</li></ol></li><li>二叉树公共祖先问题<ol><li>优先递归</li><li>搜索树可以迭代</li></ol></li></ol><h1 id="八、回溯算法"><a href="#八、回溯算法" class="headerlink" title="八、回溯算法"></a>八、回溯算法</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><ol><li>回溯的效率<br>回溯法并不是什么高效的算法。因为回溯的<strong>本质是穷举</strong>，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些<strong>剪枝</strong>的操作，但也改不了回溯法就是穷举的本质。</li><li>回溯解决的问题<ol><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ol></li><li>理解回溯<br>回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度构成的树的深度</strong>。</li><li>回溯模板<br>回溯三部曲：<ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022022275.png" alt="回溯"></p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>递归的返回值<ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 </li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</li></ul></li></ol><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p>方法一：回溯</p><ol><li>记录映射关系（字典序排序）</li><li>回溯<ol><li>终止条件</li><li>避免死循环</li><li>遇到符合条件的路径及时返回</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ticketNum = tickets.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(ticketNum == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> tickets[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(vector&lt;string&gt; t : tickets) &#123;<br>            targets[t[<span class="hljs-number">0</span>]][t[<span class="hljs-number">1</span>]] ++;<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-built_in">recur</span>(<span class="hljs-string">&quot;JFK&quot;</span>, ticketNum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    unordered_map&lt;string, map&lt;string,<span class="hljs-type">int</span>&gt;&gt; targets;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; from, <span class="hljs-type">int</span> ticketNum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; to : targets[from]) &#123; <span class="hljs-comment">// 必须是引用</span><br>            <span class="hljs-keyword">if</span>(to.second &gt; <span class="hljs-number">0</span>) &#123;<br>                -- to.second;<br>                res.<span class="hljs-built_in">emplace_back</span>(to.first);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">recur</span>(to.first, ticketNum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>                ++ to.second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：<strong>Hierholzer 算法</strong><br>化简题意：给定一个 $n$个点 $m$ 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。<br>这种「一笔画」问题与<strong>欧拉图</strong>或者<strong>半欧拉图</strong>有着紧密的联系，下面给出定义：</p><ul><li>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路；</li><li>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路；</li><li>具有欧拉回路的无向图称为欧拉图；</li><li>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</li></ul><blockquote><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><ul><li>对于无向图 $G$，$G$ 是欧拉图当且仅当 $G$是连通的且没有奇度顶点。</li><li>对于无向图 $G$，$G$是半欧拉图当且仅当 $G$是连通的且 $G$中恰有 $0$个或 $2$ 个奇度顶点。</li><li>对于有向图 $G$，$G$ 是欧拉图当且仅当 $G$ 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</li><li>对于有向图 $G$，$G$ 是半欧拉图当且仅当<ul><li>如果将 $G$中的所有有向边退化为无向边时，那么 $G$ 的所有顶点属于同一个强连通分量；</li><li>最多只有一个顶点的出度与入度差为$1$；</li><li>最多只有一个顶点的入度与出度差为$1$；</li><li>所有其他顶点的入度和出度相同。</li></ul></li></ul></blockquote><p><strong>Hierholzer 算法</strong>用于在连通图中寻找欧拉路径，其流程如下：</p><ol><li>从起点出发，进行深度优先搜索。</li><li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li><li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li></ol><p>注意到只有那个入度与出度差为$1$ 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。<br>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。<br>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;&gt; vec; <span class="hljs-comment">// string-&gt;priority_queue 小顶堆</span><br><br>vector&lt;string&gt; stk;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; curr)</span> </span>&#123; <span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-keyword">while</span> (vec.<span class="hljs-built_in">count</span>(curr) &amp;&amp; vec[curr].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 映射表中存在当前出发点，且目的节点数不为0</span><br>string tmp = vec[curr].<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//字典序大的先入栈，逆序后字典序最小</span><br>vec[curr].<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 移除当前边</span><br><span class="hljs-built_in">dfs</span>(<span class="hljs-built_in">move</span>(tmp));<br>&#125;<br>stk.<span class="hljs-built_in">emplace_back</span>(curr); <span class="hljs-comment">// 遇到死胡同入栈</span><br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : tickets) &#123;<br>vec[it[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(it[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 构建映射表</span><br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br><br><span class="hljs-built_in">reverse</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> stk;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h1><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022023286.png" alt="摆动序列"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                result++;<br>                preDiff = curDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022024794.png" alt="跳跃游戏II"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightmost = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nextStepMost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(rightmost &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> step;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            nextStepMost = <span class="hljs-built_in">max</span>(nextStepMost, i + nums[i]);<br>            <span class="hljs-keyword">if</span>(nextStepMost &gt;= n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ++ step;<br>            <span class="hljs-keyword">if</span>(rightmost &lt;= i) &#123;<br>                ++ step;<br>                rightmost = nextStepMost;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 记录最低价格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 情况二：相当于买入</span><br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br><br>            <span class="hljs-comment">// 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）</span><br>            <span class="hljs-keyword">if</span> (prices[i] &gt;= minPrice &amp;&amp; prices[i] &lt;= minPrice + fee) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出</span><br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice + fee) &#123;<br>                result += prices[i] - minPrice - fee;<br>                minPrice = prices[i] - fee; <span class="hljs-comment">// 情况一，这一步很关键</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-comment">// 0 无覆盖； 1：存在摄像头； 2: 不需要摄像头(被覆盖或空子树)</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 空子树</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 左右子树为空 或者 左右子树被覆盖但是没有相机</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// </span><br>            result++; <span class="hljs-comment">//左右子树中有一个未被覆盖</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//安装摄像头</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 左右子树均被覆盖，且至少存在一个摄像头</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="十、动态规划"><a href="#十、动态规划" class="headerlink" title="十、动态规划"></a>十、动态规划</h1><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022025304.png" alt="动态规划"></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h1 id="十一、单调栈"><a href="#十一、单调栈" class="headerlink" title="十一、单调栈"></a>十一、单调栈</h1><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/posts/3687adfb/"/>
    <url>/posts/3687adfb/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是C-11"><a href="#什么是C-11" class="headerlink" title="什么是C++11"></a>什么是C++11</h2><p>C++11标准为C++编程语言的第三个官方标准，正式名叫ISO&#x2F;IEC 14882:2011 - Information technology – Programming languages – C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO&#x2F;IEC 14882:2003 - Programming languages – C++成为C++语言新标准。</p><p>C++11是对目前C++语言的扩展和修正， C++11不仅包含核心语言的新机能，而且扩展了C++的标准程序库（STL） ，并入了大部分的C++ Technical Report 1（TR1） 程序库(数学的特殊函数除外)。</p><p>C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、 decltype，和模板的大量改进。</p><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。从这个意义上讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型。</p><p>注意：</p><ol><li>定义变量时必须初始化；</li><li>不支持函数形参（C++11）；</li><li>不能作为自定义类型的成员变量；</li><li>不能作为模板实例化时的参数；</li><li>不能出现在顶级数组类型。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>)</span> </span>&#123;&#125;  <span class="hljs-comment">// 2: auto函数参数，有些编译器无法通过编译</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">str</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> var = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 3: auto非静态成员变量，无法通过编译</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> a;     <span class="hljs-comment">// 1: 无法推导，无法通过编译</span><br>    vector&lt;<span class="hljs-keyword">auto</span>&gt; b = &#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 4: auto模板参数（实例化时），无法通过编译</span><br>    <span class="hljs-keyword">auto</span> c[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 5: auto数组，无法通过编译</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code>可以从一个变量或表达式中得到其类型。</p><h3 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h3><p>返回类型后置：在函数名和参数列表后面指定返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> T1 &amp; t1, <span class="hljs-type">const</span> T2 &amp; t2)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t1 * t2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t1 * t2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="易用性的改进"><a href="#易用性的改进" class="headerlink" title="易用性的改进"></a>易用性的改进</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>类内成员初始化</li><li>初始化列表</li><li>使用列表初始化可以防止类型收窄</li></ol><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>使用基于范围的for循环，其for循环迭代的范围必须是可确定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span><span class="hljs-comment">//形参中数组是指针变量，无法确定元素个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e: a) <span class="hljs-comment">// err, 编译失败</span><br>    &#123;<br>        cout &lt;&lt; e;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">func</span>(a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><p>C&#x2F;C++提供了调试工具<code>assert</code>，这是一个宏，用于在<strong>运行阶段</strong>对断言进行检查，如果条件为真，执行程序，否则调用<code>abort()</code>。</p><p>C++ 11新增了关键字<code>static_assert</code>，可用于在<strong>编译阶段</strong>对断言进行测试。</p><p>静态断言的好处：</p><ul><li><p>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</p></li><li><p>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</p></li></ul><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>C++11 使用<code>noexcept</code>替代<code>throw()</code>代表此函数不能抛出异常，如果抛出，就会异常。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code>是为了解决原来C++中<code>NULL</code>的二义性问题而引进的一种新的类型，因为<code>NULL</code>实际上代表的是0。</p><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>C++ 11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明请类型枚举非常简单，只需要在enum后加上使用class或struct。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Old</span>&#123;Yes, No&#125;;          <span class="hljs-comment">// old style</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">New</span>&#123;Yes, No&#125;;    <span class="hljs-comment">// new style</span><br><span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">New2</span>&#123;Yes, No&#125;;  <span class="hljs-comment">// new style</span><br></code></pre></td></tr></table></figure><p>“传统”的C++枚举类型有一些缺点：它会在一个代码区间中抛出枚举类型成员（<strong>如果在相同的代码域中的两个枚举类型具有相同名字的枚举成员，这会导致命名冲突</strong>），它们会被隐式转换为<strong>整型</strong>，并且不可以指定枚举的底层数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;Ok, Error&#125;;<br>    <span class="hljs-comment">//enum Status2&#123;Ok, Error&#125;;//err, 导致命名冲突, Status已经有成员叫Ok, Error</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++11中，强类型枚举解决了这些问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Status</span> &#123;Ok, Error&#125;;<br>    <span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">Status2</span>&#123;Ok, Error&#125;;<br> <br>    <span class="hljs-comment">//Status flag2 = Ok; // err，必须使用强类型名称</span><br>    Status flag3 = Status::Ok;<br> <br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">char</span> &#123; C1 = <span class="hljs-number">1</span>, C2 = <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//指定枚举的底层数据类型</span><br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">D</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123; D1 = <span class="hljs-number">1</span>, D2 = <span class="hljs-number">2</span>, Dbig = <span class="hljs-number">0xFFFFFFF0</span>U &#125;;<br> <br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(C::C1) &lt;&lt; endl;   <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::D1) &lt;&lt; endl;     <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::Dbig) &lt;&lt; endl;   <span class="hljs-comment">// 4</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</p><p>这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算。</p><p><code>constexpr</code>函数的限制：</p><ul><li><p>函数中只能有一个return语句（有极少特例）</p></li><li><p>函数必须返回值（不能是void函数）</p></li><li><p>在使用前必须已有定义（不能先声明）</p></li><li><p>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式</p></li></ul><p>常量表达式的构造函数有以下限制：</p><ul><li>函数体必须为空</li><li>初始化列表只能由常量表达式来赋值</li></ul><h3 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h3><p>用户自定义字面值，或者叫“自定义后缀”更直观些，主要作用是简化代码的读写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _mm(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x / <span class="hljs-number">1000</span>; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _m(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)  &#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _km(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">1000</span>; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_mm &lt;&lt; endl; <span class="hljs-comment">//0.001</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_m  &lt;&lt; endl; <span class="hljs-comment">//1</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_km &lt;&lt; endl; <span class="hljs-comment">//1000</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 C++ 11 标准，只有下面参数列表才是合法的，最后四个对于字符串相当有用，第二个参数会自动推断为字符串的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> <span class="hljs-type">const</span> *<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span><br><span class="hljs-type">long</span> <span class="hljs-type">double</span><br><span class="hljs-type">char</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">wchar_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char16_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char32_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br></code></pre></td></tr></table></figure><h3 id="原生字符串字面值"><a href="#原生字符串字面值" class="headerlink" title="原生字符串字面值"></a>原生字符串字面值</h3><p>原生字符串字面值(raw string literal)使用户书写的字符串“所见即所得”。C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用括号左右标识，就可以声明该字符串字面量为原生字符串了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">R&quot;(hello,\n</span><br><span class="hljs-string">         world)&quot;</span> &lt;&lt; endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的改进"><a href="#类的改进" class="headerlink" title="类的改进"></a>类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">double</span> d, <span class="hljs-type">int</span> i) &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">float</span> f, <span class="hljs-type">int</span> i, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* c) &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::A; <span class="hljs-comment">// 继承构造函数</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ExtraInterface</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量</p></li><li><p>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</p></li><li><p>一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数</p></li></ul><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>和继承构造函数类似，委托构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。</p><p> 如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这<strong>必须通过初始化列表进行操作</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Info</span>() : <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>) &#123; &#125;    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">Info</span>(i, <span class="hljs-string">&#x27;a&#x27;</span>) &#123; &#125; <span class="hljs-comment">// 既是目标构造函数，也是委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">char</span> e): <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>, e) &#123; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">char</span> e): <span class="hljs-built_in">type</span>(i), <span class="hljs-built_in">name</span>(e) &#123; <span class="hljs-comment">/* 其它初始化 */</span> &#125; <span class="hljs-comment">// 目标构造函数</span><br>    <span class="hljs-type">int</span>  type;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="继承控制"><a href="#继承控制" class="headerlink" title="继承控制"></a>继承控制</h3><p>C++11之前，一直没有继承控制关键字，禁用一个类的进一步衍生比较麻烦。</p><p>C++ 11添加了两个继承控制关键字：<code>final</code>和<code>override</code>。</p><ul><li><p>final阻止类的进一步派生和虚函数的进一步重写</p></li><li><p>override确保在派生类中声明的函数跟基类的虚函数有相同的签名</p></li></ul><h3 id="类默认函数的控制"><a href="#类默认函数的控制" class="headerlink" title="类默认函数的控制"></a>类默认函数的控制</h3><ol><li><code>=default</code><ul><li>编译器将为显式声明的 <code>=default</code>函数自动生成函数体</li><li>仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数</li><li>函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义</li></ul></li><li><code>=delete</code><ul><li>在函数声明后加上<code>=delete</code>，就可将该函数禁用</li><li>可用于禁用类的某些转换构造函数，从而避免不期望的类型转换</li><li>禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象</li></ul></li></ol><h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><h3 id="右尖括号的改进"><a href="#右尖括号的改进" class="headerlink" title="右尖括号的改进"></a>右尖括号的改进</h3><p>在C++98&#x2F;03的泛型编程中，模板实例化有一个很繁琐的地方，就是连续两个右尖括号<code>&gt;&gt;</code>会被编译解释成右移操作符，而不是模板参数表的形式，需要一个空格进行分割，以避免发生编译时的错误。</p><p>在实例化模板时会出现连续两个右尖括号，同样<code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>表达式转换时也会遇到相同的情况。C++98标准是让程序员在<code>&gt;&gt;</code>之间填上一个空格，在C++11中，这种限制被取消了。在C++11标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出<code>&gt;&gt;</code>是一个右移操作符还是模板参数表的结束标记。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">//std::is_same</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">using</span> uint = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// CPP11</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> UINT;<br><span class="hljs-keyword">using</span> sint = <span class="hljs-type">int</span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//std::is_same 判断类型是否一致</span><br>    <span class="hljs-comment">//这个结构体作用很简单，就是两个一样的类型会返回true</span><br>    cout &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; endl; <span class="hljs-comment">// 1</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><p>C++11之前，类模板是支持默认的模板参数，却不支持函数模板的默认模板参数。类模板的默认模板参数必须从右往左定义，数模板的默认模板参数则没这个限定。</p><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>在C++11之前，类模板和函数模板只能含有固定数量的模板参数。C++11增强了模板功能，允许模板定义中包含0到任意个模板参数，这就是可变参数模板。</p><p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在<code>typename</code>或<code>class</code>后面带上省略号<code>...</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//可变参数的模板函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ... T&gt; <span class="hljs-comment">//T叫模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T... args)</span><span class="hljs-comment">//args叫函数参数包</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">250</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>省略号<code>...</code>的作用有两个：</p><ul><li>声明一个参数包，这个参数包中可以包含0到任意个模板参数 </li><li>在模板定义的右边，可以将参数包展开成一个一个独立的参数</li></ul><p>应用：</p><ol><li>函数的递归调用</li><li>类的递归继承</li></ol><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><p>左值引用是对一个左值进行引用的类型，右值引用则是对一个右值进行引用的类型。</p><p>左值引用和右值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须<strong>立即进行初始化</strong>。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个<strong>别名</strong>。</p><p>左值引用是具名变量值的别名，而右值引用则是<strong>不具名（匿名）变量</strong>的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;a = <span class="hljs-number">2</span>;       <span class="hljs-comment">// 左值引用绑定到右值，编译失败, err</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 非常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = b; <span class="hljs-comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;e = c; <span class="hljs-comment">// 常量左值引用绑定到常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 常量左值引用绑定到右值，编程通过, ok</span><br></code></pre></td></tr></table></figure><p><code>const 类型 &amp;</code>为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。</p><p>右值引用，使用<code>&amp;&amp;</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp; r1 = <span class="hljs-number">22</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> &amp;&amp; r2 = x + y;<br>T &amp;&amp; a = <span class="hljs-built_in">ReturnRvalue</span>();<br></code></pre></td></tr></table></figure><p>通常情况下，右值引用是不能够绑定到任何的左值的。</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</p><p>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。</p><p>通过转移语义，临时对象中的资源能够转移其它的对象里。</p><h4 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//移动构造函数</span><br>    <span class="hljs-comment">//参数是非const的右值引用</span><br>    <span class="hljs-built_in">MyString</span>(MyString &amp;&amp; t)<br>    &#123;<br>        str = t.str; <span class="hljs-comment">//拷贝地址，没有重新申请内存</span><br>        len = t.len;<br> <br>        <span class="hljs-comment">//原来指针置空，必须修改</span><br>        t.str = <span class="hljs-literal">NULL</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>和拷贝构造函数类似，有几点需要注意：</p><ul><li>参数（右值）的符号必须是右值引用符号，即<code>&amp;&amp;</code>。</li><li>参数（右值）不可以是常量，因为我们需要修改右值。</li><li>参数（右值）的资源链接和标记必须修改，否则，右值的析构函数就会释放资源，转移到新对象的资源也就无效了。</li></ul><p>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。转移赋值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>        <br>    <span class="hljs-comment">//移动赋值函数</span><br>    <span class="hljs-comment">//参数为非const的右值引用</span><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(MyString &amp;&amp;tmp)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(&amp;tmp == <span class="hljs-keyword">this</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//先释放原来的内存</span><br>        len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">delete</span> [] str;<br><br>        <span class="hljs-comment">//无需重新申请堆区空间</span><br>        len = tmp.len;<br>        str = tmp.str; <span class="hljs-comment">//地址赋值</span><br>        tmp.str = <span class="hljs-literal">NULL</span>;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;移动赋值函数\n&quot;</span>;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>   ...<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="标准库函数-std-move"><a href="#标准库函数-std-move" class="headerlink" title="标准库函数 std::move()"></a>标准库函数 std::move()</h3><p>如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用。标准库提供了函数 <code>std::move()</code>，这个函数以非常简单的方式将左值引用转换为右值引用。</p><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward()"></a>完美转发 std::forward()</h3><p>完美转发适用于这样的场景：<strong>需要将一组参数原封不动的传递给另一个函数</strong>。</p><p>“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：<strong>左值／右值和 const&#x2F;non-const</strong>。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样。在泛型函数中，这样的需求非常普遍。</p><p>C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。</p><p>C++11中的引用折叠规则：</p><table><thead><tr><th>TR的类型定义</th><th>声明v的类型</th><th>v的实际类型</th></tr></thead><tbody><tr><td>T &amp;</td><td>TR</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;&amp;</td><td>T &amp;</td></tr><tr><td>T  &amp;&amp;</td><td>TR</td><td>T  &amp;&amp;</td></tr><tr><td>T &amp;&amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T  &amp;&amp;</td><td>TR &amp;&amp;</td><td>T  &amp;&amp;</td></tr></tbody></table><p><strong>一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用。</strong></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>C++11中有<code>unique_ptr</code>、<code>shared_ptr</code>与<code>weak_ptr</code>等智能指针(smart pointer)，定义在<code>&lt;memory&gt;</code>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><code>unique_ptr</code>持有对对象的独有权，同一时刻只能有一个<code>unique_ptr</code>指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p><p><code>unique_ptr</code>指针本身的生命周期：从<code>unique_ptr</code>指针创建时开始，直到离开作用域。</p><p>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用<code>delete</code>操作符，用户可指定其他操作)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;   <span class="hljs-comment">// 无法复制的unique_ptr</span><br>    <span class="hljs-comment">//unique_ptr&lt;int&gt; up2 = up1;        // err, 不能通过编译</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">move</span>(up1);    <span class="hljs-comment">// 现在p3是数据的唯一的unique_ptr</span><br>    up3.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 显式释放内存</span><br>    up1.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 不会导致运行时错误</span><br>    <br>    up4.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">44</span>)); <span class="hljs-comment">//&quot;绑定&quot;动态对象</span><br>    <br>    up4 = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价</span><br>    <br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">55</span>))</span></span>;<br>    <span class="hljs-type">int</span> *p = up5.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//只是释放控制权，不会释放内存</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//释放堆区资源</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><code>shared_ptr</code>允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个<code>shared_ptr</code>共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数2</span><br>    <br>    sp1.<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">//显式让引用计数减1</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下<code>shared_ptr</code>可以正常运转，但是在循环引用的场景下，<code>shared_ptr</code>无法正确释放内存。循环引用，顾名思义，<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>，在表示双向关系时，是很可能出现这种情况的，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Father&gt; father_;<br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son = <span class="hljs-built_in">make_shared</span>&lt;Son&gt;();<br>    <span class="hljs-keyword">auto</span> father = <span class="hljs-built_in">make_shared</span>&lt;Father&gt;();<br>    son-&gt;father_ = father;<br>    father-&gt;son_ = son;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Son<br>Father<br>son: 2<br>father: 2</p></blockquote><p>可以看到，程序分别执行了Son和Father的构造函数，但是没有执行析构函数，出现了内存泄漏。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><code>weak_ptr</code>是为配合<code>shared_ptr</code>而引入的一种智能指针来协助<code>shared_ptr</code>工作，它可以从一个<code>shared_ptr</code>或另一个<code>weak_ptr</code>对象构造，<strong>它的构造和析构不会引起引用计数的增加或减少</strong>。没有重载 <code>*</code> 和<code> -&gt;</code> 但可以使用<code>lock</code>获得一个可用的<code>shared_ptr</code>对象</p><p><code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存，而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>share_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值<code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp = sp1; <span class="hljs-comment">// 指向shared_ptr&lt;int&gt;所指对象</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印计数器 2</span><br><br>    sp1.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    sp2.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决循环引用的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    SharedPtr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    WeakPtr&lt;Father&gt; father_;  <span class="hljs-comment">// 将SharedPtr改为WeakPtr</span><br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();  <span class="hljs-comment">// 创建一个Son对象，返回指向Son对象的指针son_</span><br>    <span class="hljs-keyword">auto</span> father_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Father</span>();  <span class="hljs-comment">// 创建一个Father对象，返回指向Father对象的指针father_</span><br>    <span class="hljs-function">SharedPtr&lt;Son&gt; <span class="hljs-title">son</span><span class="hljs-params">(son_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：son.counter=1, son.weakref=0</span><br>    <span class="hljs-function">SharedPtr&lt;Father&gt; <span class="hljs-title">father</span><span class="hljs-params">(father_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：father.counter=1, father.weakref=0</span><br>    son.resource-&gt;father_ = father;  <span class="hljs-comment">// 调用WeakPtr赋值函数：father.counter=1, father.weakref=1</span><br>    father.resource-&gt;son_ = son;  <span class="hljs-comment">// 调用SharedPtr赋值函数：son.counter=2, son.weakref=0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h2><p>闭包有很多种定义，一种说法是，闭包是带有上下文的函数。即有状态的函数。</p><p>那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。</p><p>函数是代码，状态是一组变量，将代码和一组变量捆绑 (bind) ，就形成了闭包。</p><p>闭包的状态捆绑，必须发生在运行时。</p><h3 id="仿函数：重载-operator"><a href="#仿函数：重载-operator" class="headerlink" title="仿函数：重载 operator()"></a>仿函数：重载 operator()</h3><p>仿函数实现闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFunctor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> tmp) : <span class="hljs-built_in">round</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; <span class="hljs-keyword">return</span> tmp + round; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> round;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> round = <span class="hljs-number">2</span>;<br>    <span class="hljs-function">MyFunctor <span class="hljs-title">f</span><span class="hljs-params">(round)</span></span>;<span class="hljs-comment">//调用构造函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">//operator()(int tmp)</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对象，或者实现了opetator()的对象。</p><p>C++11中，新增加了一个<code>std::function</code>类模板，它是对C++中现有的可调用实体的一种类型安全的包裹。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//普通全局函数</span><br>    cout &lt;&lt; __func__ &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">foo_func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//类中静态函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//仿函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//绑定一个普通函数</span><br>    function&lt; <span class="hljs-type">void</span>(<span class="hljs-type">void</span>) &gt; f1 = func;<br>    <span class="hljs-built_in">f1</span>();<br> <br>    <span class="hljs-comment">//绑定类中的静态函数</span><br>    function&lt; <span class="hljs-type">int</span>(<span class="hljs-type">int</span>) &gt; f2 = Foo::foo_func;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">111</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">//绑定一个仿函数</span><br>    Bar obj;<br>    f2 = obj;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">222</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     运行结果：</span><br><span class="hljs-comment">        func</span><br><span class="hljs-comment">        foo_func(111) -&gt;: 111</span><br><span class="hljs-comment">        operator()(222) -&gt;: 222</span><br><span class="hljs-comment">    */</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::function</code>对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与<code>NULL</code>或者<code>nullptr</code>进行比较。</p><h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p><code>std::bind</code>是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。</p><p>C++98中，有两个函数<code>bind1st</code>和<code>bind2nd</code>，它们分别可以用来绑定<code>functor</code>的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得<code>bind1st</code>和<code>bind2nd</code>的可用性大大降低。</p><p>在C++11中，提供了<code>std::bind</code>，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>C++11中的lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。<br>lambda表达式的基本构成：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022009099.png" alt="lambda表达式"></p><ol><li><p>函数对象参数</p><p><code>[]</code>，标识一个lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义lambda为止时lambda所在作用范围内可见的局部变量（包括lambda所在类的this）。函数对象参数有以下形式：</p><ul><li>空。没有使用任何函数对象参数。</li><li>&#x3D;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>&amp;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量)。</li><li>this。函数体内可以使用lambda所在类中的成员变量。</li><li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>&amp;a。将a按引用进行传递。</li><li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li><li>&#x3D;，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul></li><li><p>操作符重载函数参数<br>标识重载的<code>()</code>操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p></li><li><p>可修改标示符<br><code>mutable</code>声明，这部分可以省略。按值传递函数对象参数时，加上<code>mutable</code>修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p></li><li><p>错误抛出标示符</p><p><code>exception</code>声明，这部分也可以省略。</p></li><li><p>函数返回值</p><p><code>-&gt;返回值类型</code>，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p></li><li><p>是函数体<br><code>&#123;&#125;</code>，标识函数的实现，这部分不能省略，但函数体可以为空。</p></li></ol><p>除去在语法层面上的不同，lambda和仿函数有着相同的内涵——都可以捕获一些变量作为初始化状态，并接受参数进行运行。</p><p>而事实上，仿函数是编译器实现lambda的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式。</p><p>lambda表达式的类型在C++11中被称为<strong>“闭包类型”</strong>，每一个lambda表达式则会产生一个**临时对象(右值)**。因此，严格地将，lambda函数并非函数指针。</p><p>不过C++11标准却允许lambda表达式向函数指针的转换，但提前是<strong>lambda函数没有捕获任何变量</strong>，且函数指针所示的函数原型，必须跟lambda函数函数有着相同的调用方式。</p><p>lambda表达式的价值在于，就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在C++11之前，C&#x2F;C++一直是一种顺序的编程语言。顺序是指所有指令都是串行执行的，即在相同的时刻，有且仅有单个CPU的程序计数器执行代码的代码段，并运行代码段中的指令。而C&#x2F;C++代码也总是对应地拥有一份操作系统赋予进程的包括堆、栈、可执行的（代码）及不可执行的（数据）在内的各种内存区域。</p><p>而在C++11中，一个相当大的变化就是引入了多线程的支持。这使得C&#x2F;C++语言在进行线程编程时，不比依赖第三方库。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>侯捷 C++11/14 笔记</title>
    <link href="/posts/bea73fec/"/>
    <url>/posts/bea73fec/</url>
    
    <content type="html"><![CDATA[<h2 id="Variadic-Template"><a href="#Variadic-Template" class="headerlink" title="Variadic Template"></a>Variadic Template</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>可变参数模板。</p><ol><li><p>谈的是模板Templates：</p><ul><li>函数模板 </li><li>类模板</li></ul></li><li><p>变化的是模板参数：</p><ul><li>参数个数：利用参数个数逐一递减的特性，实现递归函数的调用，使用函数模板完成。</li><li>参数类型：利用参数个数逐一递减以致参数类型也逐一递减的特性，实现递归继承或递归复合，以类模板完成。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;                <span class="hljs-comment">//这里的...是关键字的一部分：模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; firstArg, <span class="hljs-type">const</span> Types&amp;... args)</span>     <span class="hljs-comment">//这里的...要写在自定义类型Types后面：函数参数类型包</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; firstArg &lt;&lt; endl;<br>    <span class="hljs-built_in">print</span>(args...);                                     <span class="hljs-comment">//这里的...要写在变量args后面：函数参数包</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>注意三种不同的<code>...</code>的应用环境，这些都是<strong>语法规则</strong>，所以记住即可。</p></li><li><p>还要注意的是，在可变模板参数内部可以使用<code>sizeof...(args)</code>得到实参的个数。</p></li><li><p>如果同时定义了：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*......*/</span>&#125;<br></code></pre></td></tr></table></figure><p>该函数重载了<code>void print()</code>，<code>void print(const T&amp; firstArg, const Types&amp;... args)</code> 是其特化版本，编译器会优先调用特化版本。 </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>实现函数的 递归调用</p><p> 举了一个unordered容器中hash函数的计算例子：万用的哈希函数，函数入口<code>return hash_val(c.fname, c.lname, c.no)</code>;</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerHash</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(c.fname, c.lname, c.no);<br>        <span class="hljs-comment">// 2-1-1-...-1-3</span><br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val, <span class="hljs-type">const</span> Types&amp;... args)</span></span>&#123;<br>    <span class="hljs-built_in">hash_combine</span>(seed, val);<br>    <span class="hljs-built_in">hash_val</span>(seed, args);<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt; <span class="hljs-comment">// 2</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">hash_val</span>(seed, args...);<br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 3</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val)</span></span>&#123;<br>    <span class="hljs-built_in">hash_conbine</span>(seed, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022007091.png" alt="递归调用"></p><ol><li>实现递归继承</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Values&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;<br><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;&gt; &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>&lt;Head, Tail...&gt;<br>    : <span class="hljs-keyword">private</span> tuple&lt;Tail...&gt;                  <span class="hljs-comment">//注意这里的私有继承</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> tuple&lt;Tail...&gt; inherited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">tuple</span>() &#123;&#125;<br>    <span class="hljs-built_in">tuple</span>(Head v, Tail... vtail)<br>        :<span class="hljs-built_in">m_head</span>(v), <span class="hljs-built_in">inherited</span>(vtail...) &#123;&#125;<br><br>    <span class="hljs-function">Head <span class="hljs-title">head</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_head; &#125;<br>    <span class="hljs-function">inherited&amp; <span class="hljs-title">tail</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;       <span class="hljs-comment">//这里涉及派生类到基类的类型转换</span><br><br><span class="hljs-keyword">protected</span>:<br>    Head m_head;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022008946.png" alt="递归继承"></p><h2 id="模板表达式中的空格"><a href="#模板表达式中的空格" class="headerlink" title="模板表达式中的空格"></a>模板表达式中的空格</h2><p>C++11可以去掉模块表达式前面的空格。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>标准库允许使用nullptr取代0或者NULL来对指针赋值。</p><ul><li>nullptr 是个新关键字</li><li>nullptr 可以被自动转换为各种 pointer 类型，但不会被转换为任何整数类型</li><li>nullptr的类型为std::nullptr_t，定义于 <cstddef> 头文件中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 调用 f(int).</span><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">NULL</span>);     <span class="hljs-comment">// 如果定义NULL为0，则调用 f(int)，否则具有二义性</span><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 调用 f(void *).</span><br></code></pre></td></tr></table></figure><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><ol><li>C++11 auto可以进行自动类型推导。<ul><li><strong>C语言</strong>默认的局部变量是auto类型的</li><li><strong>C++11</strong> auto可以进行自动类型推导</li></ul></li><li>使用auto的场景：类型太长或者类型太复杂</li></ol><h2 id="一致性初始化（uniform-initialization）"><a href="#一致性初始化（uniform-initialization）" class="headerlink" title="一致性初始化（uniform initialization）"></a>一致性初始化（uniform initialization）</h2><p>C++11之前初始化时存在多个版本 <code>&#123;&#125;，（），=</code>。让使用者使用时比较混乱，C++11提供一种万用的初始化方法，就是使用大括号<code>&#123;&#125;</code>。</p><p>原理解析：当编译器看到大括号包起来的东西<code>&#123;t1,t2...tn&#125;</code>时，会生成一个<code>initializer_list&lt;T&gt;</code>（<code>initializer_list</code>关联至一个<code>array&lt;T,n&gt;</code>）。调用函数（例如构造函数<code>ctor</code>）时该<code>array</code>内的元素可被编译器分解<strong>逐一传给函数</strong>；元素逐一分解传递给函数进行初始化。</p><p>但是如果调用函数自身提供了<code>initializer_list&lt;T&gt;</code>参数类型的构造函数时，则不会分解而是直接传过去。直接整包传入进行初始化。所有的容器都可以接受这样的参数。</p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer_list"></a>Initializer_list</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i;      <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span> j&#123;&#125;;    <span class="hljs-comment">// j = 0</span><br><span class="hljs-type">int</span>* p;     <span class="hljs-comment">// 未初始化</span><br><span class="hljs-type">int</span>* q&#123;&#125;;   <span class="hljs-comment">// q = nullptr</span><br></code></pre></td></tr></table></figure><ol><li><p><code>initializer_list&lt;T&gt;</code>使用举例：</p><ul><li><code>initializer_list&lt;T&gt;</code>是一个<code>class</code>（类模板），这个必须类型要一致，跟模板不定的参数类型相比，模板不定的参数类型可以都不一样。</li><li><code>initializer_list&lt;T&gt;</code>类似于容器的使用方法</li></ul></li><li><p><code>initializer_list</code>源码剖析：</p><ul><li><code>initializer_list&lt;T&gt;</code>背后有<code>array</code>数组支撑，<code>initializer_list</code>关联一个<code>array&lt;T,n&gt;</code></li><li><code>initializer_list&lt;T&gt;</code>包含一个指向<code>array</code>的指针，它的拷贝只是一个浅拷贝，比较危险，两个指针指向同一个内存。</li></ul></li><li><p>initializer_list在STL中的使用：</p><ul><li>所有容器都接受指定任意数量的值用于构造或赋值或者<code>insert()</code>或<code>assign()</code>。</li><li>算法<code>max()</code>和<code>min()</code>也接受任意参数。</li></ul></li></ol><h2 id="explict"><a href="#explict" class="headerlink" title="explict"></a>explict</h2><p><code>explicit</code>关键字一直存在，只能作用在构造函数中，目的是阻止编译器进行不应该允许的构造函数进行隐式转换。声明为<code>explicit</code>的构造函数不能进行隐式转换，只能允许使用者明确调用构造函数。</p><p>C++11之前，只有<code>non-explicit one argument</code>的构造函数才能进行隐式转换，2.0之后支持<code>more than one argument</code>的构造函数的隐式转换。 </p><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (decl : coll) &#123;<br>    statement<br>&#125;<br><br><span class="hljs-comment">// 例子</span><br>vector&lt;<span class="hljs-type">double</span>&gt; vec;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:  vec) &#123;...&#125;;     <span class="hljs-comment">// 赋值，无法改变容器的内容</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; elem:  vec) &#123;...&#125;;    <span class="hljs-comment">// 引用</span><br></code></pre></td></tr></table></figure><p>基于范围的<code>for</code>循环对于<code>explicit</code>类型申明的转换是不可以的。</p><h2 id="x3D-default-x3D-delete"><a href="#x3D-default-x3D-delete" class="headerlink" title="&#x3D; default, &#x3D; delete"></a>&#x3D; default, &#x3D; delete</h2><p>在 C++ 中，如果自定义了 big-five 函数，编译器就不会再生成默认的相关函数，但是如果我们在后边加上<code>= default</code> 关键字，就可以重新获得并使用编译器为我们生成的默认函数（显式缺省:告知编译器即使自己定义了也要生成函数默认的缺省版本）；</p><p><code>=delete</code>关键字相对于上面来说则是相反的，<code>=delete</code>表示不要这个函数，就是说这个函数已经删除了不能用了，一旦别人使用就会报错（显式删除：告知编译器不生成函数默认的缺省版本)，引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p><p>补充：</p><p>1、编译器提供的默认函数：</p><p>C++中，当我们设计与编写一个类时，若不显著申明，则类会默认为我们提供如下几个函数：</p><ol><li>构造函数(<code>A()</code>)</li><li>析构函数（<code>~A()</code>）</li><li>拷贝构造函数(<code>A(A&amp;)</code>)</li><li>拷贝赋值函数（<code>A&amp; operator=(A&amp;)</code>）</li><li>移动构造函数（<code>A(A&amp;&amp;)</code>）</li><li>移动赋值函数（<code>A&amp; operator=(A&amp;&amp;)</code>）</li></ol><p>注意：拷贝函数如果涉及指针就要区分浅拷贝（指针只占4字节，浅拷贝只把指针所占的那4个字节拷贝过去）和深拷贝（不仅要拷贝指针所占的字节，还要把指针所指的东西也要拷贝过去）；</p><p>默认提供全局的默认操作符函数：</p><ol><li><code>operator</code></li><li><code>operator &amp;</code></li><li><code>operator &amp;&amp;</code></li><li><code>operator *</code></li><li><code>operator-&gt;</code></li><li><code>operator-&gt;*</code></li><li><code>operator new</code></li><li><code>operator delete</code></li></ol><p><strong>2、何时需要自定义big-three(构造函数、拷贝构造、拷贝赋值)&#x2F;big-five(新增移动构造函数、移动赋值函数)？</strong></p><p>如果类中带有<code>pointer member</code>（指针成员），那我们就可以断定必须要给出 big-three ；<br>如果不带，绝大多与情况下就不必给出 big-three 。</p><p>3、<code>default</code>、<code>delete</code>关键字使用示例</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022012705.png" alt="=default, =delete"></p><p>在c++中，如果你自定义了big-five函数，编译器就不会再为你生成默认的相关函数，但是如果我们在后边加上<code>= default</code>关键字，就可以重新获得并使用编译器为我们生成的默认函数（显式缺省:告知编译器即使自己定义了也要生成函数默认的缺省版本）；</p><p><code>=delete</code>关键字相对于上面来说则是相反的，<code>=delete</code>表示不要这个函数，就是说这个函数已经删除了不能用了，一旦别人使用就会报错（显式删除：告知编译器不生成函数默认的缺省版本)，引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022013341.png" alt="image-20220802201319128"></p><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;<br><br><span class="hljs-comment">//使用</span><br>Vec&lt;<span class="hljs-type">int</span>&gt; coll;<br></code></pre></td></tr></table></figure><p>Alias Template 无法特化。</p><p>应用实例(引出模板模板参数)</p><p>考虑这样一种需求，假设我们需要实现一个函数<code>test_moveable(容器对象，类型对象)</code>，从而能实现传入任意的容器和类型，都能将其组合为一个新的东西：容器&lt;类型&gt;，这样的话我们的函数应该怎么设计呢？</p><p>（1）解法一：函数模板(无法实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_moveable</span><span class="hljs-params">(Container cntr, T elem)</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;T&gt; c;            <span class="hljs-comment">//[Error] &#x27;Container&#x27; is not a template</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>        c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">T</span>());<br>    <br>    <span class="hljs-built_in">output_static_data</span>(<span class="hljs-built_in">T</span>());<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>    c1.<span class="hljs-built_in">swap</span>(c2);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）解法二：函数模板+iterator+traits(可以实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_moveable</span><span class="hljs-params">(Container c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> iterator_traits&lt;<span class="hljs-keyword">typename</span> Container::iterator&gt;::value_type Valtype;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>        c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Valtype</span>());<br>    <br>    <span class="hljs-built_in">output_static_data</span>(*(c.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>    <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>    c1.<span class="hljs-built_in">swap</span>(c2);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是可以达到效果的，但是却改变了函数签名，使用的时候我们需要这样调用：<code>test_moveable(list&lt;int&gt;())</code>，和我们开始设计的是不一样的。那么，有没有 template 语法能够在模板接受一个 template 参数 Container 时，当 Container 本身又是一个 class template ，能取出 Container 的template 参数？例如收到一个<code>vector&lt;string&gt;</code>，能够取出其元素类型<code>string</code>？那么这就引出了<strong>模板模板参数</strong>的概念。也就是下面的解法三。</p><p>（3）解法三：模板模板参数 + alias template(可以实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>          <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 模板模板参数中的T可以不写，默认就是前面的T</span><br>              <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>         &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XCls</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    Container&lt;T&gt; c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">XCLs</span>()<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; ++i)<br>            c.<span class="hljs-built_in">insert</span>(c.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">T</span>());<br> <br>        <span class="hljs-built_in">output_static_data</span>(<span class="hljs-built_in">T</span>());<br>        <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c1</span><span class="hljs-params">(c)</span></span>;<br>        <span class="hljs-function">Container&lt;T&gt; <span class="hljs-title">c2</span><span class="hljs-params">(std::move(c))</span></span>;<br>        c1.<span class="hljs-built_in">swap</span>(c2);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用时会报错</span><br>XCls&lt;MyString, vector&gt; c1;        <span class="hljs-comment">//[Error] vector的实际类型和模板中的Container&lt;T&gt;类型不匹配</span><br></code></pre></td></tr></table></figure><p>这是因为 <code>vector</code> 其实有<strong>两个模板参数</strong>，虽然第二个有默认值，我们平时也可以像<code>vector&lt;int&gt;</code>这样用。但是在模板中直接这样写类型是不匹配的（ <code>Container</code> 只有一个模板参数 ）。所以这里就用到了我们一开始提到的模板别名，只要传入的是<code>vector</code>的模板别名就可以了，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//不得在function body之内声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;<br> <br>XCls&lt;MyString, Vec&gt; c1;<br></code></pre></td></tr></table></figure><h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>类型别名类似于typedef。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">//相当于</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><code>using</code> 的用法：</p><ol><li>打开命令空间或者命令空间的成员</li><li>类似第一种，打开类的成员</li><li>类型别名和模板别名（C++ 11开始支持）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> std::cin;                 <span class="hljs-comment">//1</span><br><span class="hljs-keyword">using</span> _Base::_M_alloacte;       <span class="hljs-comment">//2</span><br><span class="hljs-keyword">using</span> func = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="noexpect"><a href="#noexpect" class="headerlink" title="noexpect"></a>noexpect</h2><p>保证该函数不会丢出异常，可以在后面加上条件,也就是说在某种条件满足情况下，不会抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> noexpect</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexpect</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>一般异常处理流程</strong>：当程序发生异常时会将异常信息上报返回给调用者，如果有异常处理则处理，如果该调用者没有处理异常则会接着上报上一层，若到了最上层都没有处理，就会调用<code>std::terminate()-&gt;std::abort()</code>，然后终止程序。</p><div class="note note-warning">            <p>移动构造函数和移动赋值函数。如果构造函数没有<code>noexcept</code>，<code>vector</code>将不敢使用它。</p>          </div><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p><code>override</code>用于明确要重写父类的虚函数上，相当于告诉编译器这个函数就是要重写父类虚函数这样一个意图，让编译器帮忙检查，而没有这个关键字，编译器是不会帮你检查的。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022015702.png" alt="override"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><code>final</code>新增两种功能：</p><ol><li>禁止基类被继承</li><li>禁止虚函数被重写</li></ol><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="decltype-定义"><a href="#decltype-定义" class="headerlink" title="decltype 定义"></a>decltype 定义</h3><p>引入新关键字<code>decltype</code>可以让编译器找出表达式的类型，为了区别<code>typeof</code>，以下做一个概念区分：</p><ul><li><code>typeof</code>是一个一元运算，放在一个运算数之前，运算数可以是任意类型，非常依赖平台，已过时，由<code>decltype</code>代替；理解为：我们根据<code>typeof()</code>括号里面的变量，自动识别变量类型并返回该类型；</li><li><code>typedef</code>：定义一种类型的别名，而不只是简单的宏替换；</li><li><code>define</code>：简单的宏替换；</li><li><code>typeid()</code> 返回变量类型的字符串，用于<code>print</code>变量类型。</li></ul><h3 id="decltype-用法"><a href="#decltype-用法" class="headerlink" title="decltype 用法"></a>decltype 用法</h3><ol><li>用来声明函数的返回值类型，一种新的指定函数返回值类型的方式；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Add</span><span class="hljs-params">(T1 x, T2 y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x + y)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>模板之间的应用</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022016392.png" alt="模板之间的应用"></p><ol start="3"><li><p>用来求 lambda 表达式的类型</p><p>lambda 是匿名的函数对象或仿函数，每一个都是独一无二的；如果需要声明一个这种对象的话，需要用模板或者 auto ；如果需要他的 type ，可以使用 decltype ；lambda 没有默认构造函数和析构函数。</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022017251.png" alt="lambda表达式"></p><h2 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h2><h3 id="lambda-语法以及调用方式"><a href="#lambda-语法以及调用方式" class="headerlink" title="lambda 语法以及调用方式"></a>lambda 语法以及调用方式</h3><p>定义： lambda 是一组功能的组合定义， lambda 可以定义为内联函数，可以被当做一个参数或者一个对象，类似于仿函数。</p><p>最简单的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">[] &#123;<br>    statements<br>&#125;;<br><br><span class="hljs-keyword">auto</span> l = [] &#123;<br>    statements<br>&#125;;<br><br><span class="hljs-built_in">l</span>(); <br></code></pre></td></tr></table></figure><p>完整形式：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022019028.png" alt="lambda表达式"></p><table><thead><tr><th></th><th>含义</th></tr></thead><tbody><tr><td>[]</td><td>lambda 导入器，取用外部变量</td></tr><tr><td>()</td><td>类似函数参数</td></tr><tr><td>mutable</td><td>[]中的导入数据是否可变</td></tr><tr><td>throwSpec</td><td>抛出异常</td></tr><tr><td>retType</td><td>类似函数返回值</td></tr><tr><td>{}</td><td>类似函数体</td></tr></tbody></table><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022017584.png" alt="image-20220802201742502"></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022018597.png" alt="image-20220802201822504"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++项目笔记——MyTinySTL(1)概述</title>
    <link href="/posts/135304f3/"/>
    <url>/posts/135304f3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/ww1820/MyTinySTL">ww1820&#x2F;MyTinySTL: A tiny STL in C++11，练手项目 (github.com)</a></p></blockquote><h2 id="STL（Standard-Template-Library）"><a href="#STL（Standard-Template-Library）" class="headerlink" title="STL（Standard Template Library）"></a>STL（Standard Template Library）</h2><ul><li>C++ Standard Library，C++ 标准库<ul><li>C++ Standard Template Library，C++ 标准模板库</li></ul></li></ul><p>STL 是 <strong>C++ 标准库的一部分</strong>，不用单独安装。. C++ STL 借助模板（Template）把常用的 <strong>数据结构</strong> 及其<strong>算法</strong>都实现了一遍，并且做到了数据结构和算法的<strong>分离</strong>（GP <strong>vs.</strong> OOP）。</p><p>C++标准库以头文件的形式呈现：</p><ul><li>新式C++头文件不带<code>.h</code> 后缀，如<code>#include&lt;vector&gt;</code></li><li>旧式C++头文件带<code>.h</code> 后缀，如<code>#include&lt;stdio.h&gt;</code></li><li>新式头文件内的组件封装于<code>namespace std</code></li><li>旧式头文件内的组件不封装于<code>namespace std</code></li></ul><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><ol><li>分配器（Allocators）：内存管理。</li><li>迭代器（Iterators）：泛化的指针，算法通过迭代器访问容器中的数据。</li><li>容器（Containers）：封装了大量常用的数据结构。</li><li>算法（Algorithms）：定义了一些常用算法，处理数据。</li><li>仿函数（Functors）：具有函数特质的对象（重载<code>operator()</code>的类）。</li><li>适配器（Adapters）：修改接口。</li></ol><p><img src="https://aweiii.coding.net/p/blog/d/img/git/raw/main/posts/STLComponents.png" alt="STLComponents"></p><h2 id="容器的分类与结构"><a href="#容器的分类与结构" class="headerlink" title="容器的分类与结构"></a>容器的分类与结构</h2><ul><li>顺序容器：<ul><li>Array：长度固定的数组，存储空间连续，支持随机访问</li><li>Vector：动态数组，存储空间连续，支持随机访问</li><li>Deque：双端队列，存储空间分段连续，支持随机访问</li><li>List：双向链表，存储空间不连续，不支持随机访问</li><li>Forward-List：单向链表，存储空间不连续，不支持随机访问</li></ul></li><li>关联容器：红黑树实现，有序。Multi的key可以重复<ul><li>Set&#x2F;MultiSet</li><li>Map&#x2F;MultiMap</li></ul></li><li>无序容器：哈希表（Separate Chaining）实现<ul><li>Unoedered Set&#x2F;MultiSet</li><li>Unoedered Map&#x2F;MultiMap</li></ul></li></ul><p><img src="https://aweiii.coding.net/p/blog/d/img/git/raw/main/posts/p1.png" alt="容器的分类与结构"></p><div class="note note-warning">            <ol><li><p>C++ Primer 中指出  <code>string</code> 是与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</p></li><li><p>deque由<strong>若干段</strong>连续空间串接而成，一旦有必要在deque的头部或尾端增加新的空间，便配置一段定量连续的空间，串接在deque的头部或尾端。deque的最大任务，就是在这些分段连续的空间上维护其整体连续的假象，并提供随机存取的接口。</p><p>deque首次插入一个元素，默认会动态分配512字节空间，当这512字节空间用完后，它会再动态分配自己另外的512字节空间，然后<strong>虚拟地</strong>连在一起。<strong>deque的随机访问和遍历性能比vector差。</strong></p></li></ol>          </div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="主要文件结构"><a href="#主要文件结构" class="headerlink" title="主要文件结构"></a>主要文件结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs stylus">MyTinySTL<br>│      alloc<span class="hljs-selector-class">.h</span>       <span class="hljs-comment">// 分配器</span><br>│      allocator<span class="hljs-selector-class">.h</span>   <br>│      construct<span class="hljs-selector-class">.h</span><br>│      uninitialized<span class="hljs-selector-class">.h</span><br>│      memory<span class="hljs-selector-class">.h</span><br>│      iterator<span class="hljs-selector-class">.h</span>    <span class="hljs-comment">// 迭代器</span><br>│      type_traits<span class="hljs-selector-class">.h</span> <span class="hljs-comment">// 萃取器</span><br>│      list<span class="hljs-selector-class">.h</span>        <span class="hljs-comment">// 容器</span><br>│      vector<span class="hljs-selector-class">.h</span><br>│      deque<span class="hljs-selector-class">.h</span><br>│      rb_tree<span class="hljs-selector-class">.h</span><br>│      set<span class="hljs-selector-class">.h</span><br>│      map<span class="hljs-selector-class">.h</span><br>│      hashtable<span class="hljs-selector-class">.h</span><br>│      unordered_map<span class="hljs-selector-class">.h</span><br>│      unordered_set<span class="hljs-selector-class">.h</span><br>│      astring<span class="hljs-selector-class">.h</span><br>│      basic_string<span class="hljs-selector-class">.h</span><br>│      queue<span class="hljs-selector-class">.h</span><br>│      stack<span class="hljs-selector-class">.h</span><br>│      algo<span class="hljs-selector-class">.h</span> <span class="hljs-comment">// 算法</span><br>│      algobase<span class="hljs-selector-class">.h</span><br>│      algorithm<span class="hljs-selector-class">.h</span><br>│      numeric<span class="hljs-selector-class">.h</span><br>│      heap_algo<span class="hljs-selector-class">.h</span><br>│      set_algo<span class="hljs-selector-class">.h</span><br>│      functional<span class="hljs-selector-class">.h</span>  <span class="hljs-comment">//仿函数</span><br>│      exceptdef<span class="hljs-selector-class">.h</span>   <span class="hljs-comment">//其他</span><br>│      util<span class="hljs-selector-class">.h</span><br>│<br>└─Test            <span class="hljs-comment">// 测试文件</span><br>    │  test<span class="hljs-selector-class">.cpp</span>      <span class="hljs-comment">// 程序入口</span><br>    │  algorithm_performance_test<span class="hljs-selector-class">.h</span><br>    │  algorithm_test<span class="hljs-selector-class">.h</span><br>    │  deque_test<span class="hljs-selector-class">.h</span><br>    │  list_test<span class="hljs-selector-class">.h</span><br>    │  map_test<span class="hljs-selector-class">.h</span><br>    │  queue_test<span class="hljs-selector-class">.h</span><br>    │  set_test<span class="hljs-selector-class">.h</span><br>    │  stack_test<span class="hljs-selector-class">.h</span><br>    │  string_test<span class="hljs-selector-class">.h</span><br>    │  test<span class="hljs-selector-class">.h</span><br>    │  unordered_map_test<span class="hljs-selector-class">.h</span><br>    │  unordered_set_test<span class="hljs-selector-class">.h</span><br>    │  vector_test<span class="hljs-selector-class">.h</span><br>    │  CMakeLists<span class="hljs-selector-class">.txt</span><br>    │  README.md<br></code></pre></td></tr></table></figure><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mystl::test;<br><br>  std::cout.<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">//算法测试: 包含了 mystl 的 81 个算法测试 algorithm_test.h</span><br>  <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>  <span class="hljs-comment">// 仅仅针对 sort, binary_search 做了性能测试 algorithm_performance_test.h</span><br>  algorithm_performance_test::<span class="hljs-built_in">algorithm_performance_test</span>();<br>  <span class="hljs-comment">// vector test : 测试 vector 的接口与 push_back 的性能</span><br>  vector_test::<span class="hljs-built_in">vector_test</span>();<br>  <span class="hljs-comment">// list test : 测试 list 的接口与 insert, sort 的性能</span><br>  list_test::<span class="hljs-built_in">list_test</span>();<br>  <span class="hljs-comment">// deque test : 测试 deque 的接口和 push_front/push_back 的性能</span><br>  deque_test::<span class="hljs-built_in">deque_test</span>();<br>  <span class="hljs-comment">// queue test : 测试 queue, priority_queue 的接口和它们 push 的性能</span><br>  queue_test::<span class="hljs-built_in">queue_test</span>();<br>  queue_test::<span class="hljs-built_in">priority_test</span>();<br>  <span class="hljs-comment">// stack test : 测试 stack 的接口 和 push 的性能</span><br>  stack_test::<span class="hljs-built_in">stack_test</span>();<br>  <span class="hljs-comment">// map test : 测试 map, multimap 的接口与它们 insert 的性能</span><br>  map_test::<span class="hljs-built_in">map_test</span>();<br>  map_test::<span class="hljs-built_in">multimap_test</span>();<br>  <span class="hljs-comment">// set test : 测试 set, multiset 的接口与它们 insert 的性能</span><br>  set_test::<span class="hljs-built_in">set_test</span>();<br>  set_test::<span class="hljs-built_in">multiset_test</span>();<br>  <span class="hljs-comment">// unordered_map test : 测试 unordered_map, unordered_multimap 的接口与它们 insert 的性能</span><br>  unordered_map_test::<span class="hljs-built_in">unordered_map_test</span>();<br>  unordered_map_test::<span class="hljs-built_in">unordered_multimap_test</span>();<br>  <span class="hljs-comment">// unordered_set test : 测试 unordered_set, unordered_multiset 的接口与它们 insert 的性能</span><br>  unordered_set_test::<span class="hljs-built_in">unordered_set_test</span>();<br>  unordered_set_test::<span class="hljs-built_in">unordered_multiset_test</span>();<br>  <span class="hljs-comment">// string test : 测试 string 的接口和 insert 的性能</span><br>  string_test::<span class="hljs-built_in">string_test</span>();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_MSC_VER) &amp;&amp; defined(_DEBUG)</span><br>  _CrtDumpMemoryLeaks();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// check memory leaks</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于宏的两点：</p><ol><li><p>特殊符号 <code>#</code> 和 <code>##</code> </p><p><code>#</code> ： 预处理时，将<code>#</code>后连接的实参字符串化</p><p><code>##</code> ：一种分隔连接方式，它的作用是先分隔，然后进行强制连接。在普通的宏定义中，预处理器一般把空格解释成分段标志，对于每一段和前面比较，相同的就被替换。但是这样做的结果是，被替换段之间存在一些空格。如果我们不希望出现这些空格，就可以通过添加一些<code>##</code>来替代空格。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE1(type,name)   type name_##type##_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE2(type,name)   type name##_##type##_type</span><br><br><span class="hljs-built_in">TYPE1</span>(<span class="hljs-type">int</span>, c); <span class="hljs-comment">// int 　name_int_type; (因为##号将后面分为 name_ 、type 、 _type三组，替换后强制连接)</span><br><span class="hljs-built_in">TYPE2</span>(<span class="hljs-type">int</span>, d); <span class="hljs-comment">// int 　d_int_type;    (因为##号将后面分为 name、_、type 、_type四组，替换后强制连接)</span><br></code></pre></td></tr></table></figure></li><li><p>宏定义中的<code>do&#123; &#125;while(0)</code></p><p>使用do{…}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 测试案例的类名，替换为 test_case_TEST</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TESTCASE_NAME(testcase_name) \</span><br><span class="hljs-meta">    testcase_name##_TEST</span><br><br><span class="hljs-comment">// 使用宏定义掩盖复杂的测试样例封装过程，把 TEXT 中的测试案例放到单元测试中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYTINYSTL_TEST_(testcase_name)                        \</span><br><span class="hljs-meta">class TESTCASE_NAME(testcase_name) : public TestCase &#123;        \</span><br><span class="hljs-meta">public:                                                       \</span><br><span class="hljs-meta">    TESTCASE_NAME(testcase_name)(const char* case_name)       \</span><br><span class="hljs-meta">        : TestCase(case_name) &#123;&#125;;                             \</span><br><span class="hljs-meta">    virtual void Run();                                       \</span><br><span class="hljs-meta">private:                                                      \</span><br><span class="hljs-meta">    static TestCase* const testcase_;                         \</span><br><span class="hljs-meta">&#125;;                                                            \</span><br><span class="hljs-meta">                                                              \</span><br><span class="hljs-meta">TestCase* const TESTCASE_NAME(testcase_name)                  \</span><br><span class="hljs-meta">    ::testcase_ = UnitTest::GetInstance()-&gt;RegisterTestCase(  \</span><br><span class="hljs-meta">        new TESTCASE_NAME(testcase_name)(#testcase_name));    \</span><br><span class="hljs-meta">void TESTCASE_NAME(testcase_name)::Run()</span><br><br><span class="hljs-comment">// 简单测试的宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST(testcase_name) \</span><br><span class="hljs-meta">  MYTINYSTL_TEST_(testcase_name)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Run()后边没有写实现，是为了用宏定义将测试用例放入到 Run 的实现里，例如：</span><br><span class="hljs-comment">TEST(AddTestDemo)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">EXPECT_EQ(3, Add(1, 2));</span><br><span class="hljs-comment">EXPECT_EQ(2, Add(1, 1));</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">上述代码将 &#123; EXPECT_EQ(3, Add(1, 2)); EXPECT_EQ(2, Add(1, 1)); &#125; 接到 Run() 的后面</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>预处理阶段，上述代码在<code>TEST</code> 处展开后，<code>TEST</code> 后面<code>&#123;...&#125;</code> 的内容将拼接到 <code>Run()</code> 后，成为<code>Run()</code> 的实现。</p><p><code>MYTINYSTL_TEST_(testcase_name)</code> 展开后声明一个名为 <code>testcase_name_TEST</code> 的类（<code>testcase_name</code> 是形参），13行声明了一个静态指针常量成员，指向一个测试用例，16行对该静态成员进行定义，并将其加入到用例集合中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/qq_40571533/article/details/102558371?spm=1001.2014.3001.5502">MyTinySTL阅读笔记—概述_xiaoxiao涛的博客-CSDN博客_mytinystl源码分析</a></p><p>[2] <a href="https://github.com/Alinshans/MyTinySTL">Alinshans&#x2F;MyTinySTL: Achieve a tiny STL in C++11 (github.com)</a></p><p>[3] <a href="https://github.com/Alinshans/MyTinySTL/wiki">Home · Alinshans&#x2F;MyTinySTL Wiki (github.com)</a></p><p>[4] <a href="https://www.cnblogs.com/Anker/p/3418792.html">C语言宏高级用法 总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中虚函数、虚继承内存模型</title>
    <link href="/posts/3e911f6d/"/>
    <url>/posts/3e911f6d/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>转自：<a href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p>          </div><blockquote><p>C++中虚函数、虚继承的内存模型是一个经典问题，其实现依赖于编译器，但其主要原理大体相同。本文以问题导向的方式，详细介绍了g++中虚函数和虚继承的内存模型及其原理。</p></blockquote><h1 id="1-多态类型"><a href="#1-多态类型" class="headerlink" title="1 多态类型"></a>1 多态类型</h1><p>在C++中，多态类型是指声明或者继承了至少一个虚函数的类型，反之则为非多态类型。<br>对于非多态类型的变量，其类型信息都可以在编译时确定。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br>...<br><br>A a;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>();  <span class="hljs-comment">// 可以在编译时确定a的类型为A</span><br>a.<span class="hljs-built_in">foo</span>();     <span class="hljs-comment">// 可以在编译时确定A::foo在内存中的地址</span><br><span class="hljs-built_in">sizeof</span>(a);   <span class="hljs-comment">// 尽管A为空，但由于需要在内存中确定a的地址，因此A类型对象所占空间为1个字节</span><br></code></pre></td></tr></table></figure><p>而对于多态类型，一些信息必须延迟到运行时才可以确定，例如它的实际类型、所调用的虚函数的地址等。下面的这个例子中，类型<code>B</code>继承了声明有虚函数的类型<code>A</code>，因此<code>A</code>和<code>B</code>都是多态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 声明虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-comment">// 隐式继承了虚函数</span><br>&#125;;<br><br>...<br><br>B b&#123;&#125;;<br>A&amp; a_rb = b; <span class="hljs-comment">// 将b绑定到A的左值引用a_rb上</span><br><br><span class="hljs-built_in">typeid</span>(<span class="hljs-keyword">decltype</span>(a_rb)).<span class="hljs-built_in">name</span>(); <span class="hljs-comment">// decltype产生的是编译时即可确定的声明类型，因此为A</span><br><span class="hljs-built_in">typeid</span>(a_rb).<span class="hljs-built_in">name</span>()；  <span class="hljs-comment">// 由于a_rb是多态类型的glvalue，typeid在运行时计算，因此为B</span><br><br>a_rb.<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// 这里调用的是B中的foo，其函数地址是运行时确定的</span><br><span class="hljs-built_in">sizeof</span>(b);   <span class="hljs-comment">// 这里的sizeof是编译器决定的，通常为8 (64位)</span><br></code></pre></td></tr></table></figure><h1 id="2-虚函数的内存模型"><a href="#2-虚函数的内存模型" class="headerlink" title="2 虚函数的内存模型"></a>2 虚函数的内存模型</h1><p>我们可以用基类型<code>A</code>的引用或者指针持有实际类型为派生类<code>B</code>的对象，这意味着，编译时我们无法通过其声明类型来确定其实际类型，也就无法确定应该调用哪个具体的虚函数。考虑到程序中的每个函数都在内存中有着唯一的地址，我们可以将具体函数的地址作为成员变量，存放在对象之中，这样就可以在运行时，通过访问这个成员变量，获取到实际类型虚函数的地址。</p><h2 id="2-1-单继承内存模型"><a href="#2-1-单继承内存模型" class="headerlink" title="2.1 单继承内存模型"></a>2.1 单继承内存模型</h2><p>现代的C++编译器都采用了<strong>表格驱动</strong>的对象模型。具体来说，对于每一个多态类型，其所有的虚函数的地址都以一个表格的方式存放在一起，每个函数的偏移量在基类型和导出类型中均相同，这使得虚函数相对于表格首地址的偏移量在可以在编译时确定。虚函数表格的首地址储存在每一个对象之中，称为虚(表)指针(vptr)或者虚函数指针(vfptr)，这个虚指针始终位于对象的起始地址。使用多态类型的引用或指针调用虚函数时，首先通过虚指针和偏移量计算出虚函数的地址，然后进行调用。<br>例如，有如下所示的类型<code>A</code>和<code>B</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;; <span class="hljs-comment">// 重写f0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>它们的对象模型和虚表模型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br> <span class="hljs-function">object                                            A <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 - vptr_A --------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 - <span class="hljs-type">int</span> ax                                    |    <span class="hljs-title">A::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +--------------+</span><br><span class="hljs-function">                                                   |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function"></span><br><span class="hljs-function">struct B</span><br><span class="hljs-function"> object                                         </span><br><span class="hljs-function">     <span class="hljs-number">0</span> - struct A                                  B VTable (不完整)</span><br><span class="hljs-function">     <span class="hljs-number">0</span> -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     <span class="hljs-number">8</span> -   int ax                                  |    B::f0()   |</span><br><span class="hljs-function">    <span class="hljs-number">12</span> - int bx                                    +--------------+</span><br><span class="hljs-function">sizeof(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>注意到，由于<code>B</code>重写了方法<code>f0()</code>，因此它的虚表在同样的位置，将<code>A::f0()</code>覆盖为<code>B::f0()</code>。当发生<code>f0()</code>函数调用时，对于实际类型为<code>A</code>的对象，其VTable偏移量为<code>offset0</code>的位置为<code>A::f0()</code>， 对于实际类型为<code>B</code>的对象，对应位置为<code>B::f0()</code>，这样就实现了运行时虚函数函数地址的正确选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>B b;<br>A &amp;a_ra = a;<br>A &amp;a_rb = b;<br>a_ra.<span class="hljs-built_in">f0</span>(); <span class="hljs-comment">// call (a_ra-&gt;vptr_A + offset0) --&gt; A::f0()</span><br>a_rb.<span class="hljs-built_in">f0</span>(); <span class="hljs-comment">// call (a_rb-&gt;vptr_A + 0ffset0) --&gt; B::f0()</span><br></code></pre></td></tr></table></figure><p>在以上的例子中，<code>B</code>中虚函数都已经在<code>A</code>中声明过，如果类型<code>B</code>中出现了基类型<code>A</code>中没有的虚函数，新的虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。例如<code>B</code>中新增加了函数<code>f2()</code>，虚函数表变化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br> object                                         <br>     <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                                  <span class="hljs-function">B <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 -   <span class="hljs-type">int</span> ax                                  |    <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function">    12 - <span class="hljs-type">int</span> bx                                    +--------------+</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function">                                                   |    B::f2()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time Type Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前，所示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                                          <span class="hljs-function">B <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function"> object                                            +--------------+</span><br><span class="hljs-function">     0 - <span class="hljs-keyword">struct</span> A                                  |  RTTI <span class="hljs-keyword">for</span> B  |</span><br><span class="hljs-function">     0 -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 -   <span class="hljs-type">int</span> ax                                  |    <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function">    12 - <span class="hljs-type">int</span> bx                                    +--------------+</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function">                                                   |    B::f2()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>现在的虚表中，不仅含有函数地址，还含有RTTI的地址，之后还会加入许多新项目。虚表中的每一项都称作一个实体(entity)。<br>上述的解决方案，可以很好的处理单链继承的情况。在单链继承中，每一个派生类型都包含了其基类型的数据以及虚函数，这些虚函数可以按照继承顺序，依次排列在同一张虚表之中，因此只需要一个虚指针即可。并且由于每一个派生类都包含它的直接基类，且没有第二个直接基类，因此其数据在内存中也是线性排布的，这意味着实际类型与它所有的基类型都有着相同的起始地址。例如，<code>B</code>继承<code>A</code>，<code>C</code>继承<code>B</code>，它们的定义和内存模型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">int</span> cx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>内存模型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                      C VTable（不完整)<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                                              +------------+<br>object                                                | RTTI <span class="hljs-keyword">for</span> C |<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                            +-------&gt; +------------+<br>    <span class="hljs-number">0</span> -   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                          |         |   C::<span class="hljs-built_in">f0</span>()  |<br>    <span class="hljs-number">0</span> -     vptr_A -------------------------+         +------------+<br>    <span class="hljs-number">8</span> -     <span class="hljs-type">int</span> ax                                    |   B::<span class="hljs-built_in">f1</span>()  |<br>   <span class="hljs-number">12</span> -   <span class="hljs-type">int</span> bx                                      +------------+<br>   <span class="hljs-number">16</span> - <span class="hljs-type">int</span> cx                                        |   C::<span class="hljs-built_in">f2</span>()  |<br><span class="hljs-built_in">sizeof</span>(C): <span class="hljs-number">24</span>    align: <span class="hljs-number">8</span>                             +------------+<br></code></pre></td></tr></table></figure><p>从上图可以看出，使用一个类型<code>A</code>或<code>B</code>的引用持有实际类型为<code>C</code>的对象，它的起始地址仍然指向<code>C</code>的起始地址，这意味着单链继承的情况下，动态向下转换和向上转换时，不需要对this指针的地址做出任何修改，只需要对其重新“解释”。<br>然而，并非所有派生类都是单链继承的，它们的起始地址和其基类的起始地址不一定始终相同。</p><h2 id="2-2-多继承内存模型"><a href="#2-2-多继承内存模型" class="headerlink" title="2.2 多继承内存模型"></a>2.2 多继承内存模型</h2><p>假设类型<code>C</code>同时继承了两个独立的基类<code>A</code>和<code>B</code>， 它们的定义关系如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-type">int</span> bx;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">int</span> cx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>与单链继承不同，由于<code>A</code>和<code>B</code>完全独立，它们的虚函数没有顺序关系，即<code>f0</code>和<code>f1</code>有着相同对虚表起始位置的偏移量，不可以顺序排布。 并且<code>A</code>和<code>B</code>中的成员变量也是无关的，因此基类间也不具有包含关系。这使得<code>A</code>和<code>B</code>在<code>C</code>中必须要处于两个不相交的区域中，同时需要有两个虚指针分别对它们虚函数进行索引。 其内存布局如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                <span class="hljs-function">C <span class="hljs-title">Vtable</span> <span class="hljs-params">(<span class="hljs-number">7</span> entities)</span></span><br><span class="hljs-function">                                                +--------------------+</span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> C                                        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span>  |</span><br><span class="hljs-function">object                                          +--------------------+</span><br><span class="hljs-function">    0 - <span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-params">(primary base)</span>                 |     RTTI <span class="hljs-keyword">for</span> C     |</span><br><span class="hljs-function">    0 -   vptr_A -----------------------------&gt; +--------------------+       </span><br><span class="hljs-function">    8 -   <span class="hljs-type">int</span> ax                                |       <span class="hljs-title">C::f0</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   16 - <span class="hljs-keyword">struct</span> B                                +--------------------+</span><br><span class="hljs-function">   16 -   vptr_B ----------------------+        |       <span class="hljs-title">C::f1</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   24 -   <span class="hljs-type">int</span> bx                       |        +--------------------+</span><br><span class="hljs-function">   28 - <span class="hljs-type">int</span> cx                         |        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">-16</span>)</span>|</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(C)</span>: <span class="hljs-number">32</span>    align: <span class="hljs-number">8</span>              |        +--------------------+</span><br><span class="hljs-function">                                       |        |     RTTI for C     |</span><br><span class="hljs-function">                                       +------&gt; +--------------------+</span><br><span class="hljs-function">                                                |    Thunk C::f1()   |</span><br><span class="hljs-function">                                                +--------------------+</span><br></code></pre></td></tr></table></figure><p>在上图所示的布局中，<code>C</code>将<code>A</code>作为主基类，也就是将它虚函数“并入”<code>A</code>的虚函数表之中，并将<code>A</code>的虚指针作为<code>C</code>的内存起始地址。<br>而类型<code>B</code>的虚指针<code>vptr_B</code>并不能直接指向虚表中的第4个实体，这是因为<code>vptr_B</code>所指向的虚表区域，在格式上必须也是一个完整的虚表。因此，需要为<code>vptr_B</code>创建对应的虚表放在虚表A的部分之后 。<br>在上图中，出现了两个“新”的实体，一个是<code>offset_to_top</code>，另一个是<code>Thunk</code>。<br>在多继承中，由于不同的基类起点可能处于不同的位置，因此当需要将它们转化为实际类型时，<code>this</code>指针的偏移量也不相同。由于实际类型在编译时是未知的，这要求偏移量必须能够在运行时获取。实体<code>offset_to_top</code>表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让<code>this</code>指针加上这个偏移量即可得到实际类型的地址。需要注意的是，由于一个类型即可以被单继承，也可以被多继承，因此即使只有单继承，实体<code>offset_to_top</code>也会存在于每一个多态类型之中。<br>而实体<code>Thunk</code>又是什么呢？如果不考虑这个<code>Thunk</code>，这里应该存放函数<code>C::f1()</code>的地址。然而，dump虚表可以看到，<code>Thunk C::f1()</code>和<code>C::f1()</code>的地址并不一样。<br>为了弄清楚<code>Thunk</code>是什么，我们首先要注意到，如果一个类型<code>B</code> 的引用持有了实际类型为<code>C</code>的变量，这个引用的起始地址在<code>C+16</code>处。当它调用由类型<code>C</code>重写的函数<code>f1()</code>时，如果直接使用<code>this</code>指针调用<code>C::f1()</code>会由于<code>this</code>指针的地址多出16字节的偏移量导致错误。 因此在调用之前，this指针必须要被调整至正确的位置 。这里的<code>Thunk</code>起到的就是这个作用：首先将<code>this</code>指针调整到正确的位置，即减少16字节偏移量，然后再去调用函数<code>C::f1()</code>。</p><h2 id="2-3-构造与析构过程"><a href="#2-3-构造与析构过程" class="headerlink" title="2.3 构造与析构过程"></a>2.3 构造与析构过程</h2><p>在多态类型的构造和析构过程中，所调用的虚函数并不是最终的实际类型的对应函数，而是当前已经创建了的(或尚未析构的)类型的对应函数。这句话比较绕口，我们通过一个例子来说明。如下所示的两个类型<code>A</code>和<code>B</code>， 它们在构造和析构时都会调用对应的虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B\n&quot;</span>; &#125;<br><br>    <span class="hljs-built_in">B</span>() &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br><br>    ~<span class="hljs-built_in">B</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f0</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">// 输出：ABBA</span><br></code></pre></td></tr></table></figure><p>运行上述程序，可以得到输出“ABBA”，表明程序依次调用了<code>A::A()</code>、<code>B::B()</code>、<code>B::~B()</code>、<code>A::~A()</code>。直观上理解，在构造<code>A</code>时，<code>B</code>中的数据还没有创建，因此B重写的虚函数当然不可使用，因此应该调用<code>A</code>中的版本；反过来，析构的时候，由于<code>B</code>先析构，在<code>B</code>析构之后，<code>B</code>中的函数当然也不可用，因此也应该调用<code>A</code>中的版本。<br>在程序运行中，这一过程是通过动态的修改对象的虚指针实现的。<br>根据C++中继承类的构造顺序，首先基类<code>A</code>被构造。在构造<code>A</code>时， 对象自身的虚指针指向<code>A</code>的虚表。由于<code>A</code>的虚表中，<code>f0()</code>的位置保存着<code>A::f0()</code>的地址，因此<code>A::f0()</code>被调用。在<code>A</code>的构造结束后，<code>B</code>的构造启动，此时虚指针被修改为指向<code>B</code>的虚表。析构过程与此相反。</p><h1 id="3-虚继承内存模型"><a href="#3-虚继承内存模型" class="headerlink" title="3 虚继承内存模型"></a>3 虚继承内存模型</h1><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。<br>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p><h2 id="3-1-菱形继承的内存模型"><a href="#3-1-菱形继承的内存模型" class="headerlink" title="3.1 菱形继承的内存模型"></a>3.1 菱形继承的内存模型</h2><p>下面展示了一个经典的菱形虚继承关系，为了避免重复包含<code>A</code>中的成员，类型<code>B</code>和<code>C</code>分别虚继承<code>A</code>。类型<code>D</code>继承了<code>B</code>和<code>C</code>。依据其继承方式的不同，<code>D</code>中的<code>B</code>、<code>C</code>的偏移量可以在编译时确定，而<code>A</code>的偏移量在运行时确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/****************************/</span><br>&#123;                                     <span class="hljs-comment">/*                          */</span><br>    <span class="hljs-type">int</span> bx;                           <span class="hljs-comment">/*             A            */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*           v/ \v          */</span><br>&#125;;                                    <span class="hljs-comment">/*           /   \          */</span> <br>                                      <span class="hljs-comment">/*          B     C         */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/*           \   /          */</span><br>&#123;                                     <span class="hljs-comment">/*            \ /           */</span><br>    <span class="hljs-type">int</span> cx;                           <span class="hljs-comment">/*             D            */</span> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*                          */</span><br>&#125;;                                    <span class="hljs-comment">/****************************/</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-type">int</span> dx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先对类型<code>A</code>的内存模型进行分析。由于虚继承影响的是子类，不会对父类造成影响，因此A的内存布局和虚表都没有改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                   A VTable<br>                                                   +------------------+<br>                                                   | <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>) |<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                                           +------------------+<br> object                                            |    RTTI <span class="hljs-keyword">for</span> A    |<br>     <span class="hljs-number">0</span> - vptr_A --------------------------------&gt;  +------------------+<br>     <span class="hljs-number">8</span> - <span class="hljs-type">int</span> ax                                    |      A::<span class="hljs-built_in">f0</span>()     |<br><span class="hljs-built_in">sizeof</span>(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +------------------+<br>                                                   |      A::<span class="hljs-built_in">bar</span>()    |<br>                                                   +------------------+<br></code></pre></td></tr></table></figure><p>类型<code>B</code>类和类型<code>C</code>没有本质的区别，因此只分析类型<code>B</code>。下图为类型B的内存模型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          B VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">16</span>)  |<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>                                  +---------------------+<br>object                                    |      RTTI <span class="hljs-keyword">for</span> B     |<br>    <span class="hljs-number">0</span> - vptr_B -------------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> - <span class="hljs-type">int</span> bx                            |       B::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_A --------------+          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> ax               |          +---------------------+         |<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-16</span>) |o----+   |<br>                               |          +---------------------+     |   |<br>                               |          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-16</span>) |     |   |<br>                               |          +---------------------+     |   |<br>                               |          |      RTTI <span class="hljs-keyword">for</span> B     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+</span><br></code></pre></td></tr></table></figure><p>对于形式类型为<code>B</code>的引用，在编译时，无法确定它的基类<code>A</code>它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为<strong>vbase_offset</strong>，位于<strong>offset_to_top</strong>上方。<br>除此之外，如果在<code>B</code>中调用<code>A</code>声明且<code>B</code>没有重写的函数，由于<code>A</code>的偏移量无法在编译时确定，而这些函数的调用由必须在<code>A</code>的偏移量确定之后进行， 因此这些函数的调用相当于使用<code>A</code>的引用调用。也因此，当使用虚基类<code>A</code>的引用调用重载函数时 ，每一个函数对<code>this</code>指针的偏移量调整都可能不同，它们被记录在镜像位置的<code>vcall_offset</code>中。例如，调用<code>A::bar()</code>时，<code>this</code>指针指向的是<code>vptr_A</code>，正是函数所属的类<code>A</code>的位置，因此不需要调整，即<code>vcall_offset(0)</code>；而<code>B::f0()</code>是由类型<code>B</code>实现的， 因此需要将<code>this</code>指针向前调整<code>16</code>字节。<br>对于类型<code>D</code>，它的虚表更为复杂，但虚表中的实体我们都已熟悉。 以下为<code>D</code>的内存模型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          D VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">32</span>)  |<br>                                          +---------------------+<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>                                  |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br>object                                    +---------------------+<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> (primary base)           |      RTTI <span class="hljs-keyword">for</span> D     |<br>    <span class="hljs-number">0</span> -   vptr_B  ----------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> -   <span class="hljs-type">int</span> bx                          |       D::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_C  ------------------+     |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">16</span>)  |<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> cx                    |     +---------------------+<br>   <span class="hljs-number">28</span> - <span class="hljs-type">int</span> dx                      |     |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-16</span>) |<br>   <span class="hljs-number">32</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> (<span class="hljs-keyword">virtual</span> base)     |     +---------------------+<br>   <span class="hljs-number">32</span> -   vptr_A --------------+    |     |      RTTI <span class="hljs-keyword">for</span> D     |<br>   <span class="hljs-number">40</span> -   <span class="hljs-type">int</span> ax               |    +---&gt; +---------------------+<br><span class="hljs-built_in">sizeof</span>(D): <span class="hljs-number">48</span>    align: <span class="hljs-number">8</span>      |          |       D::<span class="hljs-built_in">f0</span>()       |<br>                               |          +---------------------+<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>                               |          +---------------------+         |<br>                               |          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-32</span>) |o----+   |<br>                               |          +---------------------+     |   |<br>                               |          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-32</span>) |     |   |<br>                               |          +---------------------+     |   |<br>                               |          |      RTTI <span class="hljs-keyword">for</span> D     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">D::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+ </span><br></code></pre></td></tr></table></figure><h2 id="3-2-析构过程"><a href="#3-2-析构过程" class="headerlink" title="3.2 析构过程"></a>3.2 析构过程</h2><p>与非虚继承相似，通过虚继承产生的派生类在构造和析构时，所调用的虚函数只是当前阶段的的虚表中对应的函数。一个问题也就由此产生，由于在虚基类的不同的派生类中，虚基类相对于该类型的偏移量是可以不同的，如果直接使用2.3中的方法，直接用继承虚基类的类型自身的虚表作为构建该类时使用的虚表，会由于偏移量的不同，导致无法正确获取虚基类中的对象。<br>这个描述比较抽象拗口，我们通过3.1中的菱形继承的例子进行解释。四个类型<code>A</code>，<code>B</code>，<code>C</code>和<code>D</code>的继承关系如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/****************************/</span><br>&#123;                                     <span class="hljs-comment">/*                          */</span><br>    <span class="hljs-type">int</span> bx;                           <span class="hljs-comment">/*             A            */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;             <span class="hljs-comment">/*           v/ \v          */</span><br>&#125;;                                    <span class="hljs-comment">/*           /   \          */</span><br>                                      <span class="hljs-comment">/*          B     C         */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A           <span class="hljs-comment">/*           \   /          */</span><br>&#123;                                     <span class="hljs-comment">/*            \ /           */</span><br>    <span class="hljs-type">int</span> cx;                           <span class="hljs-comment">/*             D            */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;              <span class="hljs-comment">/*                          */</span><br>&#125;;                                    <span class="hljs-comment">/****************************/</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br>    <span class="hljs-type">int</span> dx;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>观察实际类型为<code>B</code>和实际类型为<code>D</code>对象的内存布局可以发现，如果实际类型为<code>B</code>，虚基类A对B的首地址的偏移量为16；若实际类型为<code>D</code>，则其中A对B首地址的偏移量为32。这明显与<code>B</code>自身的虚表冲突。如果构建<code>D::B</code>时还采用的是<code>B</code>自身的虚表，会由于偏移量的不同导致错误。<br>这一问题的解决方法其实很粗暴，那就是在对象构造、析构阶段，会用到多少种虚表，会用到多少种虚指针就生成多少种虚指针。在构造或析构时，“按需分配”。<br>例如，这里的类型<code>D</code>是类型<code>B</code>和<code>C</code>的子类，而<code>B</code>和<code>C</code>虚继承了类型<code>A</code>。 这种继承关系会导致<code>D</code>内部含有的<code>B</code>(称作<code>B-in-D</code>)、<code>C</code>(称作<code>C-in-D</code>)的虚表与<code>B</code>、<code>C</code>的虚表不同。 因此，这需要生成两张新的虚表，即<code>B-in-D</code>和<code>C-in-D</code>的虚表。<br>由于<code>B-in-D</code>也是<code>B</code>类型的一种布局，<code>B</code>的一个虚表对应两个虚指针，分别是<code>vptr_B</code>和<code>vptr_A</code>，因此它也有两个着两个虚指针。在构造或析构<code>D::B</code>时，其对象的内存布局和虚表布局如图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                          B-in-D VTable<br>                                          +---------------------+<br>                                          |   <span class="hljs-built_in">vbase_offset</span>(<span class="hljs-number">32</span>)  |<br>                                          +---------------------+<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> (Constructing/Deconstructing B)  |   <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">0</span>)  |<br>object                                    +---------------------+<br>    <span class="hljs-number">0</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> (primary base)           |      RTTI <span class="hljs-keyword">for</span> B     |<br>    <span class="hljs-number">0</span> -   vptr_B -----------------------&gt; +---------------------+<br>    <span class="hljs-number">8</span> -   <span class="hljs-type">int</span> bx                          |       B::<span class="hljs-built_in">f0</span>()       |<br>   <span class="hljs-number">16</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>                          +---------------------+<br>   <span class="hljs-number">16</span> -   vptr_C                          |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">0</span>)   |x--------+<br>   <span class="hljs-number">24</span> -   <span class="hljs-type">int</span> cx                          +---------------------+         |<br>   <span class="hljs-number">28</span> - <span class="hljs-type">int</span> dx                            |   <span class="hljs-built_in">vcall_offset</span>(<span class="hljs-number">-32</span>) |o----+   |<br>   <span class="hljs-number">32</span> - <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> (<span class="hljs-keyword">virtual</span> base)           +---------------------+     |   |<br>   <span class="hljs-number">32</span> -   vptr_A --------------+          |  <span class="hljs-built_in">offset_to_top</span>(<span class="hljs-number">-32</span>) |     |   |<br>   <span class="hljs-number">40</span> -   <span class="hljs-type">int</span> ax               |          +---------------------+     |   |<br><span class="hljs-built_in">sizeof</span>(D): <span class="hljs-number">48</span>    align: <span class="hljs-number">8</span>      |          |      RTTI <span class="hljs-keyword">for</span> B     |     |   |<br>                               +--------&gt; +---------------------+     |   |<br>                                          |     <span class="hljs-function">Thunk <span class="hljs-title">B::f0</span><span class="hljs-params">()</span>   |o----+   |</span><br><span class="hljs-function">                                          +---------------------+         |</span><br><span class="hljs-function">                                          |       <span class="hljs-title">A::bar</span><span class="hljs-params">()</span>      |x--------+</span><br><span class="hljs-function">                                          +---------------------+</span><br></code></pre></td></tr></table></figure><p>同样的，在<code>C-in-D</code>中也会有两个虚指针，分别是<code>vptr_C</code>和<code>vptr_A</code>。此外，在最终的<code>D</code>中还有三个虚指针，总计7个不同的虚指针，它们指向3张虚表的7个不同位置。因此编译器为类型D总共生成了3个不同的虚表，和7个不同的虚指针。将这7个虚指针合并到一个表中，这个表就是**虚表的表(Virtual Table Table, VTT)**。显然，只有当一个类的父类是继承了虚基类的类型时，编译器才会为它创建VTT。<br>在构造和析构过程中，子类的构造函数或析构函数向基类传递一个合适的、指向VTT某个部分指针，使得父类的构造函数或析构函数获取到正确的虚表。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ul><li>虚函数地址通过虚指针索引的虚函数表在运行时确定；</li><li>虚表中不仅储存了虚函数的地址，还储存了类型<code>RTTI</code>的地址、距实际类型首地址偏移量等信息；</li><li>虚函数的调用可能涉及到<code>this</code>指针的变更，需要<code>Thunk</code>等方式实现；</li><li>对于虚基类的派生类，虚基类的偏移量由实际类型决定，因此在<strong>运行时才可以确定虚基类的地址</strong>；</li><li>在多态类型的构造和析构过程中，通过修改虚指针使其指向不同的虚表，可以实现在不同的阶段调用不同的虚函数；</li><li>对于虚继承的情况，由于同一类型虚表的虚表在不同具体类型中可以不同，在构造和析构时，需要通过<code>VTT</code>传递正确的虚表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>类相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/4a17b156/"/>
    <url>/posts/4a17b156/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
