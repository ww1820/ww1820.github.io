<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/blog.png"><link rel="icon" href="/img/blog.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="AWei"><meta name="keywords" content=""><meta name="description" content="基础篇执行一条 SQL 查询语句，期间发生了什么？ 可以看到， MySQL 的架构共分为两层：Server 层和存储引擎层  Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Se"><meta property="og:type" content="article"><meta property="og:title" content="八股文之MySQL"><meta property="og:url" content="https://ww1820.github.io/posts/16cd74ae/index.html"><meta property="og:site_name" content="AWei&#39;s Blog"><meta property="og:description" content="基础篇执行一条 SQL 查询语句，期间发生了什么？ 可以看到， MySQL 的架构共分为两层：Server 层和存储引擎层  Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Se"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210101600980.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102310217.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102113656.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102119127.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102126394.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210111436369.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210111848399.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210112254292.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210121750342.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/10b513008ea35ee880c592a88adcb12f.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160030935.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160028739.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160036008.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160103206.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160129608.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160129286.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160131969.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160203129.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162105929.jpeg"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162107541.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162114087.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162114080.png"><meta property="article:published_time" content="2022-10-16T13:36:20.000Z"><meta property="article:modified_time" content="2022-10-16T13:42:15.524Z"><meta property="article:author" content="AWei"><meta property="article:tag" content="八股文"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210101600980.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>八股文之MySQL | AWei&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"ww1820.github.io",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AWei&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="八股文之MySQL"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-16 21:36" pubdate>2022年10月16日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 26k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 217 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">八股文之MySQL</h1><div class="markdown-body"><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210101600980.png" srcset="/img/loading.gif" lazyload alt="查询语句执行流程"></p><p>可以看到， MySQL 的架构共分为两层：<strong>Server 层</strong>和<strong>存储引擎层</strong></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， <strong>InnoDB 成为了 MySQL 的默认存储引擎</strong>。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><ol><li><p>连接器</p><ol><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都<strong>基于此时读取到的权限</strong>；</li></ol></li><li><p>查询缓存</p><p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个<strong>查询缓存</strong>是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p><strong>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。</strong></p><p>所以，<strong>MySQL 8.0 版本直接将查询缓存删掉了</strong>，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p><p>这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 <strong>server 层的查询缓存</strong>，并不是 Innodb 存储引擎中的 buffer poll。</p></li><li><p>解析SQL</p><ol><li>词法分析，识别关键字，构建SQL语法树</li><li>语法分析，根据词法分析的结果与语法规则，检查SQL语句语法</li></ol><p><strong>这一步不检查表或者字段是否存在。</strong></p></li><li><p>执行SQL</p><ol><li>预处理阶段（处理器）<ol><li>检查SQL查询语句中的表或者字段是否存在</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ol></li><li>优化阶段（优化器）<ol><li><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li><li>要想知道优化器选择了哪个索引，可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的<strong>执行计划</strong>，然后执行计划中的 key 就表示执行过程中使用了哪个索引。如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会<strong>全表扫描</strong>（type &#x3D; ALL），这种查询扫描的方式是效率最低档次的 。</li></ol></li><li>执行阶段（执行器）<ol><li>主键索引查询</li><li>全表扫描</li><li>索引下推：索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</li></ol></li></ol></li></ol><h2 id="如何查看-MySQL-服务被多少个客户端连接了？"><a href="#如何查看-MySQL-服务被多少个客户端连接了？" class="headerlink" title="如何查看 MySQL 服务被多少个客户端连接了？"></a>如何查看 MySQL 服务被多少个客户端连接了？</h2><p>执行<code>show processlist</code> 命令查看。</p><h2 id="空闲连接会一直占用着吗？"><a href="#空闲连接会一直占用着吗？" class="headerlink" title="空闲连接会一直占用着吗？"></a>空闲连接会一直占用着吗？</h2><p>MySQL 定义了空闲连接的最大空闲时长，由 <code>wait_timeout</code> 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会<strong>自动将它断开</strong>。</p><p>也可以<strong>手动断开</strong>空闲的连接，使用的是 kill connection + id 的命令。</p><p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在<strong>发起下一个请求的时候</strong>，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><h2 id="MySQL-的连接数有限制吗？"><a href="#MySQL-的连接数有限制吗？" class="headerlink" title="MySQL 的连接数有限制吗？"></a>MySQL 的连接数有限制吗？</h2><p>MySQL 服务支持的最大连接数由 <strong>max_connections</strong> 参数控制，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 短连接</span><br>连接 mysql 服务（TCP 三次握手）<br>执行sql<br>断开 mysql 服务（TCP 四次挥手）<br><br><span class="hljs-comment">// 长连接</span><br>连接 mysql 服务（TCP 三次握手）<br>执行sql<br>执行sql<br>执行sql<br>....<br>断开 mysql 服务（TCP 四次挥手）<br></code></pre></td></tr></table></figure><p>使用长连接的好处就是<strong>可以减少建立连接和断开连接的过程</strong>，所以一般是<strong>推荐使用长连接</strong>。</p><p>但是，使用长连接后可能会<strong>占用内存增多</strong>，因为 MySQL 在执行查询过程中<strong>临时使用内存管理连接对象</strong>，这些<strong>连接对象资源只有在连接断开时才会释放</strong>。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会<strong>被系统强制杀掉</strong>，这样会发生 MySQL 服务异常重启的现象。</p><h2 id="怎么解决长连接占用内存的问题？"><a href="#怎么解决长连接占用内存的问题？" class="headerlink" title="怎么解决长连接占用内存的问题？"></a>怎么解决长连接占用内存的问题？</h2><p>有两种解决方式。</p><ol><li><strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</li><li><strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，注意这是<strong>接口函数</strong>不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，<strong>达到释放内存的效果</strong>。这个过程<strong>不需要重连和重新做权限验证</strong>，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="MyISAM和-InnoDB-的区别"><a href="#MyISAM和-InnoDB-的区别" class="headerlink" title="MyISAM和 InnoDB 的区别"></a>MyISAM和 InnoDB 的区别</h2><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44298615/article/details/110306417">MyISAM和 InnoDB的选择</a></p><ol><li><p>外键</p><p>InnoDB支持外键，而MyISAM是不支持的。如果将InnoDB类型的表转换为MyISAM类型的话，是会转换失败的。</p></li><li><p>索引</p><p>InnoDB是聚集索引，使用B+树作为索引结构。必须要有主键，通过主键索引效率会很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键过大的话，索引也要增大。<br>MyISAM是非聚集索引，它的<strong>索引与数据文件是分开的</strong>。InnoDB的<strong>索引与数据文件是绑在一块进行存储的</strong>。</p></li><li><p>存储文件</p><p>InnoDB是聚集索引。而MyISAM是非聚集索引，它的索引与数据文件是分开存储的，MyISAM在硬盘上的文件：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102310217.png" srcset="/img/loading.gif" lazyload alt="MyISAM表"></p><ol><li>.frm文件是存储的表的框架结构，它的名字与表的名字是一样的。无论是MyISAM还是InnoDB，都有这个文件</li><li>MYD文件存放的是表的<strong>数据</strong></li><li>MYI文件存放的是表的<strong>索引</strong></li></ol><p>MyISAM是非聚集索引，就是把<strong>索引与表中的数据分开存储</strong>了。<strong>聚集索引将数据与索引放在一个文件中</strong>。InnoDB的存储文件有：</p><ol><li>.frm，与MyISAM一样，都是存放的表的框架结构。</li><li>ibd</li></ol></li><li><p>事务</p><p>InnoDB支持事务，而且5.5版本之后，MySQL默认的存储引擎就是InnoDB了。而MyISAM不支持事务</p></li><li><p>全文索引</p><p>在MySQL5.7版本之前，InnoDB是不支持全文索引的，在5.7版本之后，InnoDB就支持索引了。MyISAM则是支持全文索引</p></li><li><p>是否存储表中行数</p><p>InnoDB不保存表的具体行数，比如在执行select count(*) from table时，会进行全表扫描。而MyISAM中内置了一个计数器，这个计数器存放了表中的行数，在查询表中的行数时，直接从计数器中获取即可。</p></li><li><p>锁的支持</p><p>InnoDB支持行锁、表锁，默认是<strong>行锁</strong>。MyISAM支持<strong>表锁</strong>。表锁指的是<strong>锁住的是整张表</strong>。在InnoDB中，它的行锁<strong>锁的是索引</strong>，而不是对整行数据进行加锁，如果在访问数据的时候，<strong>如果访问没有命中索引，也无法使用行锁，那么InnoDB就会退化到表锁</strong>。</p></li><li><p>是否有唯一索引</p><p>InnoDB必须要有唯一索引（如主键id），而MyISAM可以没有。InnoDB推荐自增id作为主键，因为索引的底层数据结构为B+树，使用自增的id的话，<strong>能够避免B+树的频繁合并与重排</strong>。</p></li><li><p>数据的删除</p><p>InnoDB删除数据时是一行一行进行删除的，而MyISAM删除数据时则是重新建表。</p></li></ol><h2 id="如何选择哪种存储引擎？"><a href="#如何选择哪种存储引擎？" class="headerlink" title="如何选择哪种存储引擎？"></a>如何选择哪种存储引擎？</h2><p>1、如果要支持事务，那么肯定是要选择InnoDB的，毕竟MyISAM是不支持事务的。而过不要求事务的话，可以考虑MyISAM。<br>2、如果在使用的时候，读操作占用了大多数，那么MyISAM是比较合适的，如果读写的比例差不多，那么InnoDB更合适<br>3、系统崩溃后，MyISAM恢复的速度是要比InnoDB慢的，<br>4、5.5版本后，默认的存储引擎就是InnoDB了，所以，大部分情况下，InnoDB是够用的。</p><h2 id="向表中新增20条数据，删除3条数据后，重启数据库，再新增一条数据，那么这条数据的id是多少呢？"><a href="#向表中新增20条数据，删除3条数据后，重启数据库，再新增一条数据，那么这条数据的id是多少呢？" class="headerlink" title="向表中新增20条数据，删除3条数据后，重启数据库，再新增一条数据，那么这条数据的id是多少呢？"></a>向表中新增20条数据，删除3条数据后，重启数据库，再新增一条数据，那么这条数据的id是多少呢？</h2><p>从InnoDB与MyISAM两种存储引擎方面来说。如果是InnoDB的话，因为InnoDB是将数据存放到内存中，重启数据库会导致最大ID丢失，再新增数据的时候，会从当前最大值还是累加，所以InnoDB此时的id为18.<br>MyISAM将数据信息存放到文件中，再重启数据库的时候，重新读取文件获取文件中数据的最大值，在此基础上进行操作即可，所以MyISAM引擎的话是21。</p><h1 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><p>所谓的存储引擎，说白了就是<strong>如何存储数据</strong>、<strong>如何为存储的数据建立索引</strong>和<strong>如何更新</strong>、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 <strong>InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎</strong>。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><ol><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ol><p><strong>一、按「数据结构」分类</strong></p><p>MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102113656.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，<strong>B+Tree 索引类型</strong>也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用<strong>主键</strong>作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个<strong>不包含 NULL 值的唯一列</strong>作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个<strong>隐式自增 id</strong> 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><p><strong>主键索引的 B+Tree 如图所示：</strong></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102119127.png" srcset="/img/loading.gif" lazyload alt="主键索引 B+Tree"></p><p>数据库的索引和数据都是存储在<strong>硬盘</strong>的，我们可以把<strong>读取一个节点当作一次磁盘 I&#x2F;O 操作</strong>。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I&#x2F;O 操作。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p><p><strong>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下</strong>：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 <strong>B+Tree 的叶子节点</strong>里；</li><li>二级索引的 B+Tree 的<strong>叶子节点存放的是主键值，而不是实际数据</strong>。</li></ul><p><strong>通过二级索引查询的过程如下：</strong></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210102126394.png" srcset="/img/loading.gif" lazyload alt="回表"></p><ol><li>先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值</li><li>再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。</li></ol><p><strong>二、按「物理存储」分类</strong></p><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p><p>因为表的数据都是存放在聚集索引的叶子节点里，所以 <strong>InnoDB 存储引擎一定会为表创建一个聚集索引</strong>，且<strong>由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个</strong>。</p><p><strong>三、按「字段特性」分类</strong></p><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><ol><li><p>主键索引 <code>PRIMARY KEY</code></p><p>主键索引就是建立在<strong>主键字段</strong>上的索引，通常<strong>在创建表的时候一起创建，一张表最多只有一个主键索引</strong>，索引列的值<strong>不允许有空值</strong>。</p></li><li><p>唯一索引 <code>UNIQUE KEY</code></p><p>唯一索引建立在 <strong>UNIQUE</strong> 字段上的索引，一张表<strong>可以有多个唯一索引</strong>，索引列的值必须唯一，但是<strong>允许有空值</strong>。</p></li><li><p>普通索引 <code>INDEX</code></p><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p></li><li><p>前缀索引 <code>INDEX(column_name(length))</code></p></li></ol><p><strong>四、按「字段个数」分类</strong></p><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在<strong>单列</strong>上的索引称为单列索引，比如主键索引；</li><li>建立在<strong>多列</strong>上的索引称为联合索引；</li></ul><p>联合索引的非叶子节点用<strong>多个字段</strong>的值作为 B+Tree 的 key 值。当在联合索引查询数据时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p><strong>联合索引失效</strong>的情况：</p><ol><li><strong>在没有遵循最左匹配原则的情况下</strong>，无法利用到联合索引。</li><li>联合索引的最左匹配原则，在遇到范围查询（&gt;、&lt;、between、like 包括like ‘x%’这种）的时候，就会<strong>停止匹配</strong>，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。</li></ol><p>在情况2中，联合索引的 B+Tree 找到第一个满足条件的主键值后，还需要判断其他条件是否满足：</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><p>当查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。区分度计算公式：<br>$$<br>区分度 &#x3D; \frac{distinct(column)}{count(*)}<br>$$<br>MySQL查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p><h2 id="什么时候不需要创建索引"><a href="#什么时候不需要创建索引" class="headerlink" title="什么时候不需要创建索引"></a>什么时候不需要创建索引</h2><p>索引最大的好处是<strong>提高查询速度</strong>，但是索引也是有缺点的，比如：</p><ol><li>需要占用<strong>物理空间</strong>，数量越大，占用空间越大；</li><li><strong>创建</strong>索引和<strong>维护</strong>索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的<strong>增删改的效率</strong>，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行<strong>动态维护</strong>。</li></ol><p><strong>什么时候适用索引？</strong></p><ol><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ol><p><strong>什么时候不需要创建索引？</strong></p><ol><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是<strong>快速定位</strong>，如果<strong>起不到定位的字段通常是不需要创建索引的</strong>，因为索引是会占用物理空间的。</li><li>字段中存在<strong>大量重复数据</strong>，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li><strong>表数据太少</strong>的时候，不需要创建索引；</li><li><strong>经常更新</strong>的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ol><h2 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h2><p>常见的四种方法：<strong>前缀索引优化、覆盖索引优化、主键索引设置为自增、索引设置为<code>NOT NULL</code>、防止索引失效</strong>。</p><ol><li><p>前缀索引优化</p><p>前缀索引顾名思义就是使用某个字段中字符串的<strong>前几个字符</strong>建立索引。</p><p>使用前缀索引是<strong>为了减小索引字段大小</strong>，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>前缀索引有一定的局限性，例如：</p><ul><li><code>order by</code> 无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul></li><li><p>覆盖索引优化</p><p>覆盖索引是指 SQL 中 <strong>query 的所有字段</strong>，在索引 B+Tree 的<strong>叶子节点上都能找得到的那些索引</strong>，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以<strong>避免回表</strong>的操作。</p><p>假设我们只需要查询商品的名称、价格，可以建立一个联合索引，即 <code>(商品ID, 名称, 价格)</code> 作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就<strong>减少了大量的 I&#x2F;O 操作</strong>。</p></li><li><p>主键索引最好是自增的</p><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，<strong>每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中</strong>。</p><ol><li><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会<strong>按顺序添加</strong>到当前索引节点的位置，<strong>不需要移动已有的数据</strong>，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</li><li><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是<strong>随机的</strong>，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不<strong>移动其它数据</strong>来满足新数据的插入，甚至需要从一个页面<strong>复制数据</strong>到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</li></ol><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p></li><li><p>索引最好设置为 <code>NOT NULL</code></p><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>索引列存在 NULL 就会导致<strong>优化器</strong>在做索引选择的时候更加复杂，更加<strong>难以优化</strong>，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会<strong>占用物理空间</strong>，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式<code>COMPACT</code>，会用 1 字节空间存储 NULL 值列表。</li></ul></li><li><p>防止索引失效</p><p><strong>发生索引失效的情况：</strong></p><ol><li>当我们使用<strong>左</strong>或者<strong>左</strong>右<strong>模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中<strong>对索引列做了计算、函数、类型转换</strong>操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要<strong>遵循最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR <strong>前的条件列是索引列</strong>，而在 OR <strong>后的条件列不是索引列</strong>，那么索引会失效。</li></ol></li></ol><h2 id="MySQL查询优化中扫描方式（Access-Paths）"><a href="#MySQL查询优化中扫描方式（Access-Paths）" class="headerlink" title="MySQL查询优化中扫描方式（Access Paths）"></a>MySQL查询优化中扫描方式（Access Paths）</h2><ol><li><p>const（system）</p><p>常量访问，当通过表的**”主键”<strong>或”非空唯一索引”进行</strong>“常量等值匹配”<strong>访问表中数据时，访问类型就是const。此访问类型</strong>只会执行一次<strong>，</strong>查询最多只会查询出1条数据<strong>，因此在复杂的SQL中</strong>会被优先执行并直接替换为常量**，然后再执行SQL的其他部分，以提升效率。</p></li><li><p>eq_ref</p><p>等值引用，当<strong>表之间</strong>通过等值连接(连接条件是&#x3D;)访问时，且使用**”主键”<strong>或</strong>“非空唯一索引”**访问被驱动表时，访问类型即是eq_ref，这是效率最高的连接访问方式。</p></li><li><p>ref</p><p>普通引用，当<strong>表之间</strong>同过等值(连接条件是&#x3D;或&lt;&#x3D;&gt;)访问时，使用<strong>普通索引</strong>（未使用”主键”或”非空唯一索引”）访问被驱动表时，访问类型即是ref，这是效率比较高的连接访问方式。</p></li><li><p>ref_or_null</p><p>这种访问方式<strong>和ref类似</strong>，只是MySQL在判断连接值时会<strong>额外做一步判断连接条件上的值是否包含null</strong>。这种连接类型大部分是在<strong>处理子查询的场景</strong>中使用。</p></li><li><p>fulltext</p><p>全文索引访问，全文索引是一种特殊的索引类型，<strong>只能建立在char，varchar或text类型的数据上</strong>，用来在大量的文本中匹配某种模式（大文本比like匹配快很多）。全文索引使用下面的语法进行查询，共3种检索方式，这里不详细叙述。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">MATCH (col1,col2,...) AGAINST (expr [search_modifier])<br></code></pre></td></tr></table></figure><ol start="6"><li><p>index_merge</p><p>索引合并，MySQL通过对同一个表中的多个索引进行范围扫描（range），再将各个扫描结果集合计，得到最终结果集。注意参与索引合并的索引必须来自同一个表，<strong>不能跨表</strong>。此访问方法在同时使用多个索引时常用。</p><p>index_merge的算法有3种算法：</p><ul><li>index_merge intersection算法取多个索引范围扫描<strong>交集</strong>，在多个索引条件使用 and 连接时使用。</li><li>index_merge union算法是取多个范围扫描<strong>并集</strong>，在多个索引条件使用 or 连接时使用。</li><li>index_merge sort-union算法和union类似，唯一的区别是sort-union算法要<strong>先取回所有的结果后排序</strong>，再将结果返回给客户端。</li></ul></li><li><p>unique_subquery</p><p><strong>唯一</strong>子查询，在某些子查询场景替换eq_ref访问方法。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">value IN (SELECT primary_key FROM single_table WHERE some_expr)<br></code></pre></td></tr></table></figure><ol start="8"><li><p>index_subquery</p><p>和unique_subquery类似，某些场景替换in子查询，只是在查询中使用的是非唯一索引。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">value IN (SELECT key_column FROM single_table WHERE some_expr)<br></code></pre></td></tr></table></figure><ol start="9"><li><p>range</p><p>索引范围扫描，根据搜索条件扫描一个范围区间的索引，此访问方法非常常见，在where条件中使用&#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, LIKE, or IN() 这些操作符均会使用索引范围扫描。</p><p><strong>这一级往上，索引的作用越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。</p></li><li><p>index</p><p>索引全扫描，和全表扫描（ALL）类似，只是这个扫描的是<strong>整个索引树</strong>。一般在两种场景下会使用此访问方法：</p><ol><li>索引覆盖，即<strong>索引中包含了 select 域中需要的所有信息</strong>，此时只需要扫描索引就可以满足查询，<strong>不再需要回表操作</strong>。</li><li>全表扫描时，需要<strong>按某个索引排序</strong>。</li></ol></li><li><p>all</p><p>人人都熟悉的全表扫描，大部分情况下是<strong>效率最低</strong>的访问方法（当表中数据较少时，全表扫扫描性能也可能优于索引，因为<strong>索引大部分是二次访问，随机读取</strong>，全表扫描是<strong>顺序读取</strong>）。特别当表中数据量较大时，使用全表扫描往往会消耗大量系统资源，严重时导致系统挂起。</p></li></ol><h2 id="explain-查看执行计划中的字段"><a href="#explain-查看执行计划中的字段" class="headerlink" title="explain 查看执行计划中的字段"></a>explain 查看执行计划中的字段</h2><ul><li>possible_keys 字段表示可能用到的索引；</li><li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li><li>key_len 表示索引的长度；</li><li>rows 表示扫描的数据行数；</li><li>type 表示数据扫描类型。</li></ul><p><strong>type 字段</strong>就是描述了找到所需数据时使用的扫描方式是什么。除了type，也要关注 extra 几个重要的参考指标：</p><ul><li>Using filesort ：当查询语句中包含 group by 操作，而且<strong>无法利用索引完成排序操作</strong>的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li><li>Using temporary：使了用<strong>临时表</strong>保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li><li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，<strong>避免了回表操作</strong>，效率不错。</li></ul><h2 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h2><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是<strong>以页为单位</strong>，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>数据页包括七个部分，结构如下图：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210111436369.png" srcset="/img/loading.gif" lazyload alt="数据页"></p><p>这7个部分的作用如下：</p><ol><li>文件头（File Header）：文件头，表示页的信息；</li><li>页头（Page Header）：页头，表示页；</li><li>最小和最大记录（Infimum+Supremum）：两个虚拟的伪记录，分别表示页中的最小记录和最大记录；</li><li>用户记录（User Records）：存储行记录的内容；</li><li>空闲空间（Free Space）：页中还没有被使用的空间；</li><li>页目录（Page Directory）：存储用户记录的相对位置，对记录起到索引作用；</li><li>文件尾（File Tailer）：校验页是否完整。</li></ol><p><strong>文件头</strong>中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向链表：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210111848399.png" srcset="/img/loading.gif" lazyload alt="双向链表"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><p>数据页的主要作用是<strong>存储记录</strong>，也就是数据库的数据，<strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，页目录与记录的关系如下图：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210112254292.png" srcset="/img/loading.gif" lazyload alt="image-20221011225439224"></p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组<strong>一共有多少条记录</strong>，作为 <strong>n_owned 字段</strong></li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为<strong>槽（slot）</strong>，<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>因为记录都是单向链表串起来的，在槽内查找某个记录的时间复杂度是 O(n) ，所以InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h2 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h2><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210121750342.png" srcset="/img/loading.gif" lazyload alt="B+树"></p><p>通过上图，我们看出 B+ 树的<strong>特点</strong>：</p><ol><li>只有<strong>叶子节点（最底层的节点）才存放了数据</strong>，非叶子节点（其他上层节）仅用来存放<strong>目录项</strong>作为索引。</li><li>非叶子节点分为不同层次，<strong>通过分层来降低每一层的搜索量</strong>；</li><li>所有节点<strong>按照索引键大小排序</strong>，构成一个双向链表，便于范围查询；</li></ol><p>我们再看看 B+ 树如何实现<strong>快速查找</strong>主键为 6 的记录，以上图为例子：</p><ol><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ol><p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h2 id="聚簇索引和二级索引的区别"><a href="#聚簇索引和二级索引的区别" class="headerlink" title="聚簇索引和二级索引的区别"></a>聚簇索引和二级索引的区别</h2><p>索引可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是<strong>实际数据</strong>，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是<strong>主键值</strong>，而不是实际数据。</li></ul><p>因为表的数据都是存放在<strong>聚簇索引的叶子节点里</strong>，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><h2 id="InnoDB-是如何创建聚簇索引的"><a href="#InnoDB-是如何创建聚簇索引的" class="headerlink" title="InnoDB 是如何创建聚簇索引的"></a>InnoDB 是如何创建聚簇索引的</h2><p>InnoDB 在创建聚簇索引时，会<strong>根据不同的场景选择不同的列作为索引</strong>：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是<strong>二级索引的叶子节点存放的是主键值，不是实际数据</strong>。</p><h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而<strong>磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大</strong>。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作，因为磁盘 I&#x2F;O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在<strong>尽可能少的磁盘的 I&#x2F;O</strong> 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能<strong>高效地执行范围查找</strong>；</li></ul><h2 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h2><ol><li><p>单点查询</p><p>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。</p><p>B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。</p><p><strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少</strong>。</p></li><li><p>插入和删除的效率</p><p>B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快；B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。</p><p>因此，<strong>B+ 树的插入和删除效率更高</strong>。</p></li><li><p>范围查询</p><p>B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p><p>因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>。</p><p>而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过<strong>树的遍历</strong>来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</p><p>因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。</p></li></ol><h2 id="B-Tree-相比于-B-树、二叉树或-Hash-索引结构的优势"><a href="#B-Tree-相比于-B-树、二叉树或-Hash-索引结构的优势" class="headerlink" title="B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势"></a>B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势</h2><ol><li><p>B+Tree vs 二叉树</p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， <strong>d 值是大于100的</strong>，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p><p>而<strong>二叉树的每个父节点的儿子节点个数只能是 2 个</strong>，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此<strong>二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多</strong>。</p></li><li><p>B+Tree vs B Tree</p><p>B+Tree 只在<strong>叶子节点存储数据</strong>，而 B 树 的<strong>非叶子节点也要存储数据</strong>，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是<strong>双链表连接</strong>，适合 MySQL 中<strong>常见的基于范围的顺序查找</strong>，而 B 树无法做到这一点。</p></li><li><p>B+Tree vs Hash</p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 <strong>Hash 表不适合做范围查询，它更适合做等值的查询</strong>，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p></li></ol><h2 id="MySQL-单表不要超过-2000W-行？"><a href="#MySQL-单表不要超过-2000W-行？" class="headerlink" title="MySQL 单表不要超过 2000W 行？"></a>MySQL 单表不要超过 2000W 行？</h2><p>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。</p><h2 id="索引失效有哪些？"><a href="#索引失效有哪些？" class="headerlink" title="索引失效有哪些？"></a>索引失效有哪些？</h2><ol><li><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</p><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p></li><li><p>当我们在查询条件中对索引列使用函数，就会导致索引失效。</p><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p></li><li><p>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</p><p>原因同上。</p></li><li><p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>（”10” → 10）。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</p></li><li><p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</p></li><li><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p></li></ol><h2 id="MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="MySQL 使用 like “%x“，索引一定会失效吗？"></a>MySQL 使用 like “%x“，索引一定会失效吗？</h2><p>使用左模糊匹配（like “%xx”）并不一定会走全表扫描，关键还是看数据表中的字段。</p><p>如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type&#x3D;all），而是走全扫描二级索引树(type&#x3D;index)。</p><p>再说一个相似，联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树(type&#x3D;index)</p><h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p><code>count()</code> 函数性能比较：</p><p>count(*) &#x3D; count(1) &gt; count(主键字段) &gt; count(字段)</p><ol><li><p><strong>count() 是什么</strong></p><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数<strong>指定的参数不为 NULL</strong> 的记录有多少个。</p></li><li><p><strong>count(主键字段) 执行过程</strong></p><p>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。</p><p>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</p><ol><li>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。</li><li>如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样<strong>遍历二级索引的 I&#x2F;O 成本比遍历聚簇索引的 I&#x2F;O 成本小</strong>，因此「优化器」优先选择的是二级索引。</li></ol></li><li><p><strong>count(1) 执行过程</strong></p><p>InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p><p>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是<strong>不需要读取记录中的字段值</strong>，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。</p><p>如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。</p></li><li><p><strong>count(*) 执行过程</strong></p><p>当使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p></li><li><p><strong>count(字段) 执行过程</strong></p><p>count(字段)会采用全表扫描的方式来计数，所以它的执行效率是比较差的。</p></li></ol><p>上述案例都是基于 <strong>Innodb 存储引擎</strong>来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。</p><p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1)复杂度，这是因为<strong>每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值</strong>，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。</p><p>而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。</p><h2 id="如何优化-count"><a href="#如何优化-count" class="headerlink" title="如何优化 count(*)"></a>如何优化 count(*)</h2><ol><li><p>近似值</p><p>如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。可以使用show table status 或者 explain 命令来表进行估算。</p><p>执行 explain 命令效率是很高的，因为它并不会真正的去查询。</p></li><li><p>额外表保存计数值</p><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p><p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p></li></ol><h2 id="针对针对下面这条-SQL，你怎么通过索引来提高查询效率呢？"><a href="#针对针对下面这条-SQL，你怎么通过索引来提高查询效率呢？" class="headerlink" title="针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？"></a>针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from order where status = 1 order by create_time asc<br></code></pre></td></tr></table></figure><ol><li>单独给 status 建立一个索引就可以了。</li><li>更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</li></ol><p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。</p><h1 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ol><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性（Consistency）</strong>：是指<strong>事务操作前和操作后</strong>，数据满足完整性约束，数据库保持一致性状态。</li><li><strong>隔离性（Isolation）</strong>：数据库允许<strong>多个并发事务同时对其数据进行读写和修改的能力</strong>，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的<strong>修改就是永久的</strong>，即便系统故障也不会丢失。</li></ol><h2 id="InnoDB-引擎通过什么技术来保证事务ACID的特性"><a href="#InnoDB-引擎通过什么技术来保证事务ACID的特性" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务ACID的特性"></a>InnoDB 引擎通过什么技术来保证事务ACID的特性</h2><ol><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ol><h2 id="并行事务会引发什么问题"><a href="#并行事务会引发什么问题" class="headerlink" title="并行事务会引发什么问题"></a>并行事务会引发什么问题</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。在同时处理多个事务的时候，可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。</p><h2 id="什么是脏读"><a href="#什么是脏读" class="headerlink" title="什么是脏读"></a>什么是脏读</h2><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p><p>如图，事务B读到事务A修改后的数据，但是事务A还未提交，发生了回滚操作，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/10b513008ea35ee880c592a88adcb12f.png" srcset="/img/loading.gif" lazyload alt="脏读"></p><h2 id="什么是不可重复读"><a href="#什么是不可重复读" class="headerlink" title="什么是不可重复读"></a>什么是不可重复读</h2><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160030935.png" srcset="/img/loading.gif" lazyload alt="不可重复读"></p><h2 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h2><p><strong>当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，就意味着发生了「幻读」现象。</strong></p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160028739.png" srcset="/img/loading.gif" lazyload alt="幻读"></p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL 标准提出了四种隔离级别来规避脏读、不可重复读、幻读的现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ol><li><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（serializable ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ol><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160036008.png" srcset="/img/loading.gif" lazyload alt="不同的隔离级别并发事务时可能发生的现象"></p><p>举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160103206.png" srcset="/img/loading.gif" lazyload alt="图片"></p><p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p><ol><li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li><li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li><li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li><li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li></ol><h2 id="四种隔离级别具体是如何实现的？"><a href="#四种隔离级别具体是如何实现的？" class="headerlink" title="四种隔离级别具体是如何实现的？"></a>四种隔离级别具体是如何实现的？</h2><ol><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View</strong> 来实现的，它们的区别在于创建 Read View 的<strong>时机</strong>不同，可以把 Read View 理解成一个数据快照。「读提交」隔离级别是在<strong>「每个语句执行前」</strong>都会重新生成一个 Read View，而「可重复读」隔离级别是<strong>「启动事务时」</strong>生成一个 Read View，然后整个事务期间都在用这个 Read View。</li></ol><h2 id="讲一讲-Read-View-在-MVCC-里是如何工作的"><a href="#讲一讲-Read-View-在-MVCC-里是如何工作的" class="headerlink" title="讲一讲 Read View 在 MVCC 里是如何工作的"></a>讲一讲 Read View 在 MVCC 里是如何工作的</h2><p>Read View 有四个重要的字段：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160129608.png" srcset="/img/loading.gif" lazyload alt="Read View"></p><ol><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ol><p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160129286.png" srcset="/img/loading.gif" lazyload alt="隐藏列"></p><ol><li>trx_id，当一个事务对某条聚簇索引记录<strong>进行改动</strong>时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ol><p>在创建 Read View 后，记录中的 trx_id 可以划分这三种情况：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160131969.png" srcset="/img/loading.gif" lazyload alt="img"></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ol><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：<ol><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ol></li></ol><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong>。</p><h2 id="MySQL是如何避免幻读的？"><a href="#MySQL是如何避免幻读的？" class="headerlink" title="MySQL是如何避免幻读的？"></a>MySQL是如何避免幻读的？</h2><ol><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决幻读的。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li></ol><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p><p>情景一：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210160203129.png" srcset="/img/loading.gif" lazyload alt="情景一"></p><p>情景二：</p><ol><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ol><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><h1 id="锁篇"><a href="#锁篇" class="headerlink" title="锁篇"></a>锁篇</h1><h2 id="MySQL-有哪些锁？"><a href="#MySQL-有哪些锁？" class="headerlink" title="MySQL 有哪些锁？"></a>MySQL 有哪些锁？</h2><ol><li><p>全局锁：FTWRL</p><p>执行以下语句之后，使用全局锁，<strong>整个数据库就处于只读状态</strong>了，这时其他线程执行对数据的增删改或者对表结构的更改操作操作，都会被阻塞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock<br></code></pre></td></tr></table></figure><p>释放全局锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables<br></code></pre></td></tr></table></figure><p>会话断开也会释放全局锁。</p><ol><li><p><strong>全局锁的应用场景</strong></p><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p></li><li><p><strong>全局锁的缺点</strong></p><p>业务只能读数据，而不能更新数据，这样会造成<strong>业务停滞</strong>。</p></li><li><p>备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p></li></ol></li><li><p>表级锁</p><ol><li><p>表锁</p><p>对学生表（t_student）加表锁，可以使用下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br></code></pre></td></tr></table></figure><p>表锁除了会限制别的线程的读写外，<strong>也会限制本线程</strong>接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p></li><li><p>元数据锁（MDL）</p><p>当对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p></li><li><p>意向锁</p><p>意向锁的使用场景：</p><ol><li>在使用 InnoDB 引擎的表里对某些<strong>记录</strong>加上「共享锁」之前（行锁），需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些<strong>纪录</strong>加上「独占锁」之前（行锁），需要先在表级别加上一个「意向独占锁」；</li></ol><p>当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p></li><li><p>AUTO-INC锁</p><p>在为某个字段声明 <code>AUTO_INCREMENT</code> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过以下两种方式实现</p><ol><li><p>AUTO-INC 锁实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p></li><li><p>一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p></li></ol><p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ol><li>当 innodb_autoinc_lock_mode &#x3D; 0，采用 AUTO-INC 锁；</li><li>当 innodb_autoinc_lock_mode &#x3D; 2，采用轻量级锁；</li><li>当 innodb_autoinc_lock_mode &#x3D; 1，默认值，两种锁混用，如果能够<strong>确定插入记录的数量就采用轻量级锁</strong>，不确定时就采用 AUTO-INC 锁。</li></ol><p>AUTO-INC 锁在对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。轻量级锁是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p></li></ol></li><li><p>行级锁</p><p>InnoDB 引擎支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><ol><li>Record Lock，记录锁，锁住的是一条记录。记录锁是有 S 锁（共享）和 X 锁（独占）之分</li><li>Gap Lock，间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</li><li>Next Lock，临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。<strong>如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</li><li>插入意向锁，一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。可以看成一种特殊的间隙锁。</li></ol></li></ol><h2 id="MySQL-是怎么加锁的？"><a href="#MySQL-是怎么加锁的？" class="headerlink" title="MySQL 是怎么加锁的？"></a>MySQL 是怎么加锁的？</h2><p>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p><p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。</p><ol><li><p>唯一索引等值查询</p><ol><li>当查询的记录是存在的，在用「唯一索引等值进行查询」时，next-key lock 会退化成「记录锁」。</li><li>当查询的记录是不存在的，在用「唯一索引等值进行查询」时，next-key lock 会退化成「间隙锁」。</li></ol></li><li><p>唯一索引范围查询</p><p>先生成next-key lock，再看是否退化。</p></li><li><p>非唯一索引等值查询</p><ol><li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li><li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li></ol></li><li><p>非唯一索引范围查询</p><p>生成next-key lock，并且不会退化。</p></li></ol><p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p><ol><li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。</li><li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li></ol><h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><p>当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 <code>select ... from</code>语句，其他语句都会被锁住不能执行，业务会因此停滞。</p><p>但并不是update 语句的 where 带上索引就能避免全表记录加锁，<strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。</p><h2 id="字节面试：加了什么锁，导致死锁的？"><a href="#字节面试：加了什么锁，导致死锁的？" class="headerlink" title="字节面试：加了什么锁，导致死锁的？"></a>字节面试：加了什么锁，导致死锁的？</h2><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162105929.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>过程分析：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162107541.png" srcset="/img/loading.gif" lazyload alt="img"></p><ol><li><p>Time 1 阶段加锁分析</p><p>唯一索引等值查询，且记录不存在，此时事务 A 在主键索引上加的是间隙锁，锁范围是$$(20, 30)$$。</p></li><li><p>Time 2 阶段加锁分析</p><p>同样，唯一索引等值查询，且记录不存在，此时事务 B 在主键索引上加的是间隙锁，锁范围是$$(20, 30)$$。</p><p><strong>间隙锁的意义只在于阻止区间被插入</strong>，因此是可以共存的。<strong>一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁</strong>，共享（S型）和排他（X型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。</p></li><li><p>Time 3 阶段加锁分析</p><p>事务 A 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 B 生成的间隙锁（范围 $$(20, 30)$$）中插入了一条记录，所以事务 A 的插入操作生成了一个插入意向锁。<strong>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的</strong>。</p></li><li><p>Time 4 阶段加锁分析</p><p>事务 B 在生成插入意向锁时而导致被阻塞，这是因为事务 B 向事务 A 生成的范围为 $$(20, 30)$$ 的间隙锁插入了一条记录，而插入意向锁和间隙锁是冲突的，所以事务 B 在获取插入意向锁时就陷入了等待状态。</p></li></ol><p>事务 A 和事务 B 在执行完后 update 语句后都持有范围为 $$(20, 30)$$ 的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p><h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ol><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p><p>当发生超时后，就出现下面这个提示：</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162114087.png" srcset="/img/loading.gif" lazyload alt="图片"></p><ol start="2"><li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p><p>当检测到死锁后，就会出现下面这个提示：</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210162114080.png" srcset="/img/loading.gif" lazyload alt="图片"></p><p>上面这个两种策略是「当有死锁发生时」的避免方式。</p><p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一下来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p><h1 id="日志篇"><a href="#日志篇" class="headerlink" title="日志篇"></a>日志篇</h1><h2 id="undo-log、redo-log、binlog-有什么用？"><a href="#undo-log、redo-log、binlog-有什么用？" class="headerlink" title="undo log、redo log、binlog 有什么用？"></a>undo log、redo log、binlog 有什么用？</h2><ol><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>。</li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/" class="category-chain-item">八股文</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">#八股文</a></div></div><div class="license-box my-3"><div class="license-title"><div>八股文之MySQL</div><div>https://ww1820.github.io/posts/16cd74ae/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>AWei</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月16日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年10月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/947f1ab2/" title="八股文之计算机网络"><span class="hidden-mobile">八股文之计算机网络</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>