<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/blog.png"><link rel="icon" href="/img/blog.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="AWei"><meta name="keywords" content=""><meta name="description" content="编译内存相关编译与链接 为什么需要编译 我们常见的 C&#x2F;C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为机器可执行的二进制指令，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂。   编译的过程    编译预处理：引入头文件，去除注释，处理条件编译指令，宏替换，添加行号 编译：对预处理后的文件进行词法分析、语法分析、语义分析、符号汇总、汇编代码的生成，"><meta property="og:type" content="article"><meta property="og:title" content="八股文之C++基础语法"><meta property="og:url" content="https://ww1820.github.io/posts/4abcf3b2/index.html"><meta property="og:site_name" content="AWei&#39;s Blog"><meta property="og:description" content="编译内存相关编译与链接 为什么需要编译 我们常见的 C&#x2F;C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为机器可执行的二进制指令，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂。   编译的过程    编译预处理：引入头文件，去除注释，处理条件编译指令，宏替换，添加行号 编译：对预处理后的文件进行词法分析、语法分析、语义分析、符号汇总、汇编代码的生成，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921568.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921950.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921968.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922436.jpeg"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922827.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922970.png"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091923258.png"><meta property="article:published_time" content="2022-10-09T11:39:59.000Z"><meta property="article:modified_time" content="2022-10-10T13:54:33.517Z"><meta property="article:author" content="AWei"><meta property="article:tag" content="C++"><meta property="article:tag" content="八股文"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921568.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>八股文之C++基础语法 | AWei&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"ww1820.github.io",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AWei&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="八股文之C++基础语法"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-09 19:39" pubdate>2022年10月9日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 37k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 312 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">八股文之C++基础语法</h1><div class="markdown-body"><h1 id="编译内存相关"><a href="#编译内存相关" class="headerlink" title="编译内存相关"></a>编译内存相关</h1><h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><ol><li>为什么需要编译<ol><li>我们常见的 C&#x2F;C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为<strong>机器可执行的二进制指令</strong>，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂。</li></ol></li><li>编译的过程</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921568.png" srcset="/img/loading.gif" lazyload alt="image.png"></p><ol><li><strong>编译预处理</strong>：引入头文件，去除注释，处理条件编译指令，宏替换，添加行号</li><li><strong>编译</strong>：对预处理后的文件进行<strong>词法分析、语法分析、语义分析、符号汇总、汇编代码的生成，代码优化</strong>。简单来说就是将.cpp源文件翻译成汇编代码</li><li><strong>汇编</strong>：将汇编代码翻译成机器指令，一个.cpp文件生成一个.o文件</li><li><strong>链接</strong>：单独的.o文件可能无法执行，因为一个程序可能由多个源文件组成。链接的目的是为了将多个目标文件链接成一个整体，从而生成一个可被操作系统加载执行的ELF文件</li><li><strong>动态链接与静态链接</strong><ol><li>静态链接：在链接生成可执行文件时，将所有外部调用函数拷贝到最终的可执行文件中，该程序被执行时，运行所需的全部代码都会装入到该进程的虚拟空间中。<ol><li>命名规则：<ol><li>Linux：.a</li><li>Windows：.lib</li></ol></li></ol></li><li>动态链接：代码生成可执行文件时，该程序调用的部分程序被放到动态链接库或共享对象的某个目标文件中，链接程序只在最终的可执行文件中<strong>记录了共享对象的名字等一些信息</strong>，最终生成的ELF文件中并<strong>不包含这些调用程序的二进制指令</strong>。在程序执行时，当需要调用这部分程序时，操作系统会从将这些动态链或者共享对象进行加载，并将全部内容会被映射到该进行运行的虚拟地址的空间。动态链接库采用了延迟绑定技术。<ol><li>命名规则：<ol><li>Linux：.so</li><li>Windows：.dll</li></ol></li></ol></li><li>二者的优缺点：<ol><li>静态链接<ol><li>缺点：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个<strong>副本</strong>，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）</li><li>优点：执行的时候运行速度<strong>快</strong>，因为可执行程序具备了程序运行的所有内容</li></ol></li><li>动态链接<ol><li>缺点：动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失</li><li>优点：节省内存、更新方便</li></ol></li><li>静态链接是由<strong>链接器</strong>完成的，动态链接最终是由<strong>操作系统</strong>来完成链接的功能</li></ol></li></ol></li></ol><p>补充：<a target="_blank" rel="noopener" href="https://aweiii.work/posts/bb4cd573/#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93">静态库和动态库</a></p><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><ol><li>ELF文件</li></ol><p>可执行与可链接格式 (Executable and Linkable Format) 是一种用于<strong>可执行文件、目标代码、共享库和核心转储 （core dump）</strong>的标准文件格式。<br>其文件构成如下：<br><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921950.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>ELF文件内部是分段存储的 ：</p><ul><li>.text section：代码段，存放机器代码，只读</li><li>.rodata section：只读数据段，文字常量</li><li>.data section：数据段，存放已初始化的全局&#x2F;静态变量、常量</li><li>.bss section：未初始化的全局变量，仅是占位符，不占据任何磁盘空间，区分.data和.bss是为了空间效率</li></ul><ol start="2"><li>内存分区：</li></ol><p>C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局&#x2F;静态存储区、常量存储区、代码区。</p><ul><li><strong>栈</strong>：栈中主要存放函数的<strong>局部变量、函数参数、返回地址</strong>等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。</li><li><strong>堆</strong>：动态申请的内存空间，就是由 <strong>malloc</strong> 函数或者 <strong>new</strong> 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，<strong>如果进程结束后还没有释放，操作系统会自动回收</strong>。</li><li><strong>全局区&#x2F;静态存储区</strong>：主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li><li><strong>常量存储区</strong>：.rodata 段，存放的是常量，不允许修改，程序运行结束自动释放。</li><li><strong>代码区</strong>：.text 段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li></ul><p>补充：</p><ol><li>static变量存放在全局数据区&#x2F;静态存储区</li><li>全局const存放在.rodata段，局部const存放在栈区</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091921968.png" srcset="/img/loading.gif" lazyload alt="image.png"></p><h2 id="程序栈帧"><a href="#程序栈帧" class="headerlink" title="程序栈帧"></a>程序栈帧</h2><p>程序中函数的调用过程：<br>每次在调用函数时，会按照<strong>从右向左的顺序</strong>依次将函数调用参数压入到栈中，并在栈中压入<strong>返回地址</strong>与<strong>当前的栈帧基地址rbp</strong>，然后跳转到调用函数内部，pc 跳转函数内部执行该函数的指令。</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922436.jpeg" srcset="/img/loading.gif" lazyload alt="程序栈帧"></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ol><li><strong>申请方式不同</strong><ul><li>栈由系统自动分配</li><li>堆是程序员申请和释放的</li></ul></li><li><strong>申请后系统响应</strong><ul><li>分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出</li><li>申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上</li></ul></li><li>栈在内存中是<strong>连续的</strong>一块空间（向低地址扩展）最大容量是<strong>系统预定好</strong>的，堆在内存中的空间（向高地址扩展）是<strong>不连续</strong>的</li><li><strong>申请效率</strong>：<ul><li>栈是有系统自动分配，申请效率高，但程序员无法控制</li><li>堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片</li></ul></li><li><strong>存放内容</strong>：<ul><li>栈中存放的是局部变量，函数的参数</li><li>堆中存放的内容由程序员控制</li></ul></li></ol><p><strong>补充：</strong></p><ol><li><p><strong>你觉得堆快一点还是栈快一点？</strong></p><p>毫无疑问是栈快一点。<br>因为<strong>操作系统会在底层对栈提供支持</strong>，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。<br>而<strong>堆的操作是由C&#x2F;C++函数库提供</strong>的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p></li><li><p>Linux下非编译器决定栈带下，而是有OS决定的，Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置），即：Windows下可以由<strong>编译器</strong>来决定栈大小，而在Linux下由<strong>系统环境变量</strong>来控制栈的大小</p><ol><li>Linux 默认栈大小：8M</li><li>Windows默认栈大小：1M</li></ol></li></ol><h2 id="变量定义与生存周期"><a href="#变量定义与生存周期" class="headerlink" title="变量定义与生存周期"></a>变量定义与生存周期</h2><ol><li>作用域<ol><li>全局变量：全局作用域，extern 声明</li><li>静态全局变量：文件作用域</li><li>局部变量&#x2F;静态局部变量：局部作用域</li></ol></li><li>生命周期<ol><li>全局变量：整个程序运行期间</li><li>局部变量：函数被调用期间，程序块内部</li><li>静态局部变量：整个程序运行期间</li></ol></li><li>分配内存<ol><li>静态变量一般存储在数据段，其中 .data 存储已经已经初始化的静态变量和全局变量，.bss 存储未初始化的静态变量与全局变量。这里<strong>静态变量包括全局变量，局部全局变量，静态局部变量</strong></li><li>局部变量一边存储在栈区或者堆区</li></ol></li><li>补充<ol><li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段，bss 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以<strong>保持原来的赋值</strong>。而栈变量或堆变量<strong>不能保证在下一次调用的时候依然保持原来的值</strong>。</li><li>静态变量和全局变量的区别：静态变量仅在变量的<strong>作用范围内</strong>可见，实际是依靠<strong>编译器来控制作用域</strong>。全局变量在整个程序范围内都可可见，只需声明该全局变量，即可使用。</li><li>全局变量定义在不要在头文件中定义：如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错，因此不能再头文件中定义全局变量。一般情况下我们将<strong>变量的定义放在 .cpp 文件中</strong>，一般<strong>在 .h 文件使用extern 对变量进行声明</strong>。</li></ol></li></ol><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>原则：</p><ol><li>结构体变量的<strong>首地址</strong>能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li><li>结构体每个成员相对于结构体首地址的<strong>偏移量 （offset）</strong> 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的<strong>总大小</strong>为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol><p>进行内存对齐的<strong>原因</strong>：（主要是<strong>硬件设备</strong>方面的问题）</p><ol><li>某些硬件设备<strong>只能存取对齐数据</strong>，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p>优点：</p><ol><li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><p><strong>补充：静态成员变量存放在全局数据区内，在编译的时候已经分配好内存空间，所以对结构体的总内存大小不做任何贡献。</strong></p><h2 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h2><ol><li><p>大小端判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)(a);<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x12</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;big endian\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x34</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;little endian\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>大小端转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ORDER_TRANS(i) ((i &amp; 0xff000000) &gt;&gt; 24 ) |  ( (i &amp; 0x00ff0000) &gt;&gt; 8 ) | ( (i &amp; 0x0000ff00) &lt;&lt; 8 )  | ( (i &amp; 0x000000ff) &lt;&lt; 24 )</span><br></code></pre></td></tr></table></figure></li><li><p>网络字节序转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ntohl</span>(uint32 x)       <span class="hljs-comment">// uint32 类型 网络序转主机序</span><br><span class="hljs-built_in">htonl</span>(uint32 x)       <span class="hljs-comment">// uint32 类型 主机序转网络序</span><br><span class="hljs-built_in">ntohs</span>(uint16 x)       <span class="hljs-comment">// uint16 类型 网络序转主机序</span><br><span class="hljs-built_in">htons</span>(uint16 x)       <span class="hljs-comment">// uint16 类型 主机序转网络序</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ol><li>内存泄漏</li></ol><p>程序在<strong>堆</strong>中申请的动态内存，在程序使用完成时<strong>没有得到及时的释放</strong>。当这些变量的生命周期已结束时，该变量在堆中所占用的内存未能得到释放，从而就导致了堆中可使用的内存越来越少，最终可能产生系统运行较慢或者系统因内存不足而崩溃的问题。</p><ol><li>内存泄漏并<strong>非指内存从物理上消失</strong>，而是指程序在运行过程中，由于疏忽或错误而<strong>失去了对该内存的控制</strong>，从而造成了内存的浪费。</li><li>内存泄漏主要指<strong>堆</strong>上分配的变量，因为栈中分配的变量，随着函数退出时会自动回收。而堆是动态分配的，一旦用户申请了内存分配而为及时释放，那么该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存。</li><li>对于实际的程序来说，我们在调用过程中使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</li><li>内存泄漏导致的问题：</li></ol><p>由于内存未得到及时释放，从而可能导致<strong>可使用的动态内存空间会越来越少</strong>，一旦内存空间全部使用完，则程序可能会导致因为内存不够中止运行。由于内存泄漏导致的问题比较严重，现在许多语言都带有 GC 程序会自动对不使用的内存进行回收，从而避免内存泄漏。</p><h2 id="内存泄漏的预防与检测"><a href="#内存泄漏的预防与检测" class="headerlink" title="内存泄漏的预防与检测"></a>内存泄漏的预防与检测</h2><ol><li>预防<ol><li><strong>内部封装</strong>：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存</li><li><strong>智能指针</strong></li><li>良好的编码习惯<ol><li>将基类的析构函数定义为<strong>虚函数</strong></li><li>遵循RAII（Resource acquisition is initialization）原则：在对象构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源；</li><li>使用智能指针</li><li>有效引入内存检测工具</li></ol></li></ol></li><li>检测</li></ol><p>Valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922827.png" srcset="/img/loading.gif" lazyload alt="image.png"></p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li>Massif：检查程序中堆栈使用中出现的问题。</li><li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li><p>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</p></li><li><p>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</p></li><li><p>检测原理：</p><p>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。<br>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</p></li></ul><h2 id="智能指针的简介与使用"><a href="#智能指针的简介与使用" class="headerlink" title="智能指针的简介与使用"></a>智能指针的简介与使用</h2><ol><li><p>智能指针</p><p>智能指针是<strong>为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的</strong>。C++ 11 中提供了智能指针的定义，所有关于智能指针的定义可以参考 <strong><memory></memory></strong>头文件。<br>传统的指针在申请完成后，必须要调用 free 或者 delete 来释放指针，否则容易产生内存泄漏的问题；smart pointer <strong>遵循 RAII 原则，当 smart pointer 对象创建时，即为该指针分配了相应的内存，当对象销毁时，析构函数会自动释放内存</strong>。<br>需要注意的是，<strong>智能指针不能像普通指针那样支持加减运算</strong>。</p></li><li><p>常用的3类智能指针：</p><ol><li><p>unique_ptr</p><p><strong>独享</strong>所有权的智能指针，资源<strong>只能被一个指针占有</strong>，该指针<strong>不能拷贝构造和赋值</strong>。但可以进行<strong>移动构造</strong>和<strong>移动赋值</strong>（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过move进行赋值。</p></li><li><p>shared_ptr</p></li></ol><p>与 unique_ptr 不同的是，shared_ptr 中资源可以被多个指针共享，但是多个指针指向同一个资源不能被释放多次，因此使用<strong>计数机制</strong>表明资源被几个指针共享。<br>通过 use_count() 查看资源的所有者的个数，<strong>可以通过 unique_ptr、weak_ptr 来构造</strong>，调用 release() 释放资源的所有权，同时将计数减一，当<strong>计数减为 0 时会自动释放内存空间（T object）</strong>，从而避免了内存泄漏。特别需要注意的是 s<strong>hared_ptr 并不是线程安全的</strong>，但 shared_ptr 的计数是原子操作实现的，利用 atmoic CAS 指令实现。当引用计数和 weak count 同时为 0 时，<strong>控制块</strong>才会被最终释放掉。<br>shared_ptr能够实现其功能依赖于对于多个shared_ptr只实例化一个**_Sp_counted_base&lt;_Lp&gt;（控制块）**</p></li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091922970.png" srcset="/img/loading.gif" lazyload alt="image.png"></p><ol start="3"><li><p>weak_ptr</p><p>指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的<strong>循环引用问题</strong>。与 shared_ptr 配合使用，将 weak_ptr 转换为 share_ptr 时，虽然它能访问 share_ptr 所指向的资源但却不享有资源的所有权，不影响该资源的引用计数。<strong>有可能资源已被释放，但 weak_ptr 仍然存在，share_ptr 必须等待所有引用的 weak_ptr 全部被释放才会进行释放。因此每次访问资源时都需要判断资源是否有效</strong>。<br>shared_ptr 通过引用计数的方式来管理对象，当进行拷贝或赋值操作时，每个 shared_ptr 都会记录当前对象的引用计数，当引用计数为0时，内存将被自动释放。当<strong>对 shared_ptr 赋予新值或者 shared_ptr 对象被销毁时，引用计数会递减</strong>。但特殊情况出现循环引用时，shared_ptr 无法正常释放资源。<strong>循环引用</strong>，即 A 指向 B，B 指向 A，在表示双向关系时，是很可能出现这种情况的。</p></li></ol><h2 id="智能指针创建"><a href="#智能指针创建" class="headerlink" title="智能指针创建"></a>智能指针创建</h2><p>C++14中加入了make_unique和make_shared，《Effective Modern C++》 学习笔记之条款二十一：优先选用 std::make_unique 和 std::make_shared，而非直接 new。</p><ol><li><p>make_unique</p><p><strong>减少代码量，能够加快编译速度</strong>，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外意外情况下可能会导致内存泄漏。但是 make_unique 不允许自定析构器，不接受 std::initializer_list 对象。</p></li><li><p>make_share</p><p>这个主要是可以<strong>减少对堆中申请内存的次数</strong>，只需要申请一次即可。<br>当我们使用 new 时，我们将 new 出的资源指针赋给 share_ptr 的 ptr, 然后 share_ptr 本身还需要再次在堆上申请一块单独的内存作为它的管理区，存放引用计数、用户自定的函数等，因此创建 shared_ptr 时需要在堆上申请两次。<br>当我们使用 make_share 时，我们只需要申请一块大的内存，一半用来存储资源，另一半作为管理区, 存放引用计数、用户自定的函数等，此时需要在堆上申请一次即可。<br>make_share 虽然效率高，但是同样不能自定义析构器，同时 share_ptr 的对象资源可能会延迟释放，因为此时对象资源与管理区域在同一块内存中，必须要同时释放。</p></li></ol><h2 id="include-“-“-和-lt-gt-的区别"><a href="#include-“-“-和-lt-gt-的区别" class="headerlink" title="include “ “ 和 &lt; &gt; 的区别"></a>include “ “ 和 &lt; &gt; 的区别</h2><ol><li><p>#include:</p><p>include 关键字主要用来标识 C&#x2F;C++ 程序源代码编译时需要引用的头文件，编译器会自动去查找这些头文件中的变量、函数声明、结构体定义等相关信息，常见的有 include<filename>和 #include “filename”，二者之间的区别：</filename></p><ol><li>include<filename>通常在编译器或者 IDE 中<strong>预先指定的搜索目录中进行搜索</strong>，通常会搜索 &#x2F;usr&#x2F;include 目录，此方法通常用于包括标准库头文件；</filename></li><li>#include “filename” 在<strong>当前源文件所在目录中</strong>进行查找，如果没有；再到当前已经添加的<strong>系统目录</strong>（编译时以 -I 指定的目录）中查找，最后会在 &#x2F;usr&#x2F;include 目录下查找 。</li></ol></li></ol><p>日常编写程序时，对于标准库中的头文件常用 include<filename>，对于自己定义的头文件常用 #include “filename”。</filename></p><ol start="2"><li><p>__has_include：</p><p>C++ 17 支持该特性，用来检查是否已经包含某个文件。</p></li></ol><h1 id="语言对比"><a href="#语言对比" class="headerlink" title="语言对比"></a>语言对比</h1><h2 id="C与-C-对比"><a href="#C与-C-对比" class="headerlink" title="C与 C++ 对比"></a>C与 C++ 对比</h2><p>C 语言是典型<strong>面向过程（Procedure Oriented）</strong>的编程语言，C++ 则是典型<strong>面向对象（Object Oriented）</strong>的编程语言，当然 C++ 也<strong>支持面向过程编程</strong>。</p><ul><li><strong>面向过程（Procedure Oriented）</strong>：一种以过程为中心的编程思想，侧重于分析解决问题所需的<strong>步骤</strong>，使用函数把这些步骤依次实现。</li><li><strong>面向对象（Object Oriented）</strong>：侧重于把构成问题的事务分解为各个<strong>对象</strong>。建立对象的目的不是完成其中的一个步骤，而是<strong>描述</strong>某个事务在解决整个具体问题步骤中的<strong>属性和行为</strong>。面向对象语言的显著特征就是支持<strong>封装、继承、多态</strong>。</li></ul><ol><li><p>C 语言：</p><p>C 语言诞生于 1969 年在贝尔实验室诞生，C 语言是面向过程的编程，它最重要的特点是函数，通过 main 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的（数据结构+算法）。</p></li><li><p>C++ 语言：</p><p>C++ 诞生于 1979 年，设计者为 Bjarne Stroustrup.<br>C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数，<strong>过程的概念被淡化</strong>了（实际上过程还是有的，就是主函数的那些语句）。以<strong>类驱动程序运行</strong>，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</p></li><li><p>两者之间的比较：</p><p>C++ 既继承了 C 强大的<strong>底层操作</strong>特性，又被赋予了<strong>面向对象机制</strong>。它特性繁多，支持面向对象语言的多继承、对值传递与引用传递的区分以及 const 关键字，现代 C++ 编译器完全兼容 C 语言语法。</p></li></ol><ul><li><p>二者的相同之处:</p><p>C++ 能够<strong>大部分兼容 C 的语法</strong>，且二者之间相同的关键字和运算符功能和作用也几乎相同；二者之间的内存模型与硬件比较接近，几乎都可以直接操纵硬件。栈、堆、静态变量这些概念在两种语言都存在。</p></li><li><p>二者的不同之处：</p><ol><li>C 为面向<strong>过程</strong>的编程语言，不支持面向<strong>对象</strong>，不支持继承、多态、封装。</li><li><strong>类型检查</strong>更为严格，C 语言中的类型转换几乎是任意的，但是 C++ 编译器对于类型转换进行非常严格检查，部分强制类型转换在 C 语言编译器下可以通过，但在 C++ 编译器下无法通过。</li><li>C 和 C++ 中都有<strong>结构</strong>的概念，但是在 C 语言中结构<strong>只有成员变量</strong>，而没成员方法，C 的成员变量<strong>没有权限控制</strong>，该结构体的变量对所有调用全部可见；而在 C++ 中结构中，它可以有自己的<strong>成员变量和成员函数</strong>，C++ 对类的成员变量具有<strong>访问权限控制</strong>。</li><li>增加了面向<strong>对象的机制、泛型编程的机制（Template）、异常处理、引用、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）</strong>。</li><li>应用领域：对于 C 语言程序员来说，程序的底层实现和内存分布基本上都可见，所以一般常用于<strong>直接控制硬件</strong>，特别是 C 语言在嵌入式领域应用很广，比如常见的驱动开发等与硬件直接打交道的领域，C++ 可以用于<strong>应用层开发</strong>，用户界面开发等与操作系统打交道的领域，特别是图形图像编程领域，几乎所有的高性能图形图像库都是用 C++ 实现的。</li></ol></li></ul><h2 id="Java与C的区别"><a href="#Java与C的区别" class="headerlink" title="Java与C的区别"></a>Java与C的区别</h2><ol><li><p>二者的相同之处：</p><p>C++ 与 Java 均支持面对对象（Object Oriented），支持类、继承、封装等常见的概念。</p></li><li><p>二者的不同之处：</p><ol><li>Java 被编译成字节码，并运行在虚拟机 JVM 上，和开发平台无关，具有<strong>跨平台</strong>的特性；C++ 直接编译成可执行文件，是否跨平台在于用到的<strong>编译器的特性是否有多平台的支持</strong>。</li><li>Java 是<strong>完全面向对象</strong>的语言，<strong>所有函数和变量部必须是类的一部分</strong>。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。</li><li>由于Java 被编译为字节码，只要安装能够运行 <strong>Java 的虚拟机</strong>即可运行 Java 程序，因此 Java 程序具有很强的<strong>可移植性</strong>，具有<strong>“一次编写，到处运行” 的跨平台特性</strong>；而 C++ 跨平台后，必须需要<strong>重新编译</strong>；</li><li>Java 语言具有<strong>垃圾回收机制</strong>，由系统进行分配和回收内存，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。Java 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，Java 中的内存回收是以线程的方式在后台运行的，利用空闲时间。<strong>C++ 则需要程序员进行内存管理</strong>，当资源释放时需要程序员进行手动释放内存空间。</li><li>C++ 支持<strong>多重继承，允许多个父类派生一个类</strong>，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；<strong>Java 不支持多重继承</strong>，但允许<strong>一个类可以继承多个接口</strong>，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。</li><li>C++ 支持<strong>方法与操作符的重载</strong>；但 Java 只支持<strong>方法重载</strong>，不支持操作符重载。</li><li>C++ 用 <strong>virtual 关键字标记的方法可以被覆盖</strong>；Java 中<strong>非 static 方法均可被覆盖</strong>，Java 中的方法默认均可以被覆盖。</li><li>C++ 可以直接操作<strong>指针</strong>，容易产生内存泄漏以及非法指针引用的问题；Java 并不是<strong>没有指针</strong>，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。</li><li>C++ 标准库不提供**thread 相关接口；Java 的标准 SDK 提供 <strong>thread 类</strong>。</li><li>C++ 支持<strong>结构体（structure）</strong>与 <strong>联合体（union）</strong>，Java 不支持结构体（structure）与联合体（union）。</li><li>从应用场景来说， C++ 可以直接编译成可执行文件，<strong>运行效率比 Java 高</strong>。Java 目前主要用来开发 <strong>Web 应用</strong>。C++ 主要用在<strong>嵌入式开发、网络、并发编程、图形图像处理、系统编程</strong>的方面。</li></ol></li></ol><h2 id="Python和C-的区别"><a href="#Python和C-的区别" class="headerlink" title="Python和C++的区别"></a>Python和C++的区别</h2><ol><li><p>二者的相同之处：</p><p>C++ 与 Python <strong>均支持面向对象</strong>，二者均可用来编写大型应用程序。</p></li><li><p>二者的不同之处：</p><ol><li>从语言自身来说，Python 为<strong>脚本语言，解释执行，不需要经过编译</strong>，所有的 python 源代码都是经过 Python 解释器；C++ 是一种需要<strong>编译</strong>后才能运行的语言，在特定的机器上编译后运行。</li><li>Python 变量的<strong>作用域</strong>不仅局限于（while，for）循环内，在循环外还可以继续访问在循环内定义的变量；C++ 则不允许循环外访问循环内定义的变量。</li><li>Python 没有严格限定函数的<strong>参数类型和返回值类型</strong>；C++ 则严格限定函数参数和返回值的类型。</li><li>从运行效率来说，<strong>C++ 运行效率高，安全稳定</strong>。Python 代码和 C++ 最终都会变成 CPU 指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object；其次，Python 是<strong>边解释边执行</strong>，和物理机 CPU 之间多了<strong>解释器</strong>这层，而 C++ 是<strong>编译执行</strong>的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li><li>从开发效率来说，Python <strong>开发效率高</strong>。Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li><li><strong>书写格式和语法不同</strong>，Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者，C++ 是<strong>严格静态类型声明语言</strong>，编译器在进行编译时必须经过严格的静态类型检查，如果发现类型检查错误，则中止编译；Python 为<strong>动态类型语言</strong>，我们在编写代码时不用指定变量的类型，只在执行时才会进行变量类型推导，确定变量类型。</li><li>C++ 可以直接用来操纵硬件，适合用来作为<strong>系统编程</strong>；Python 作为一门脚本语言，功能小巧而精湛，非常适合做<strong>工具开发</strong>和<strong>运维开发</strong>。</li></ol></li></ol><h2 id="Go和C-的区别"><a href="#Go和C-的区别" class="headerlink" title="Go和C++的区别"></a>Go和C++的区别</h2><ol><li><p>二者的相同之处：</p><p>二者都为静态类型编程语言，二者都为编译性语言，都具有高性能的特点。</p></li><li><p>二者的不同之处：</p><ol><li>Go 的许多越语法和逻辑跟 C 非常类似，Go 的<strong>运行效率很高</strong>，Go 主要是<strong>面向过程</strong>，对于面向对象支持较弱，<strong>不支持继承、多态</strong>这些概念，Go 通过<strong>结构体中含有方法来支持面向对象</strong>，<strong>Go 没有类</strong>的概念，同时也<strong>不支持构造函数与析构函数</strong>；C++ 则是<strong>面向对象（Object Oriented）</strong>，支持继承、多重继承、多态、重载这些特性。</li><li>Go 语言<strong>自带垃圾回收</strong>（garbage collection）；C++ 不支持内存垃圾自动回收，需要程序手动管理动态申请的内存。</li><li>Go 语言也支持指针，但是 Go 语言不支持指针的运算；C++ 支持指针，同时也支持指针运算。</li><li>C++ 编译器提供 SIMD 指令生成，但是 Go 编译器不支持 SIMD 指令的生成。</li><li>C++ 遵循的许可为 open source project 2.0，而 Go 遵循的许可为 BSD。</li><li>C++ 与 Go 都属于静态类型编程语言，但是 Go 语言需要遵循<strong>强类型语言规则</strong>，<strong>Go 不支持隐式类型转换</strong>。</li><li>Go 编译时如果需要引用外部函数则使用 <strong>import</strong>关键字，引入 packages，而 C++ 则使用**#include**关键字，引入头文件。</li><li>Go 不支持函数重载和操作符重载，而 C++ 支持函数重载与操作符重载。</li><li>Go 中的空指针用 <strong>nil</strong> 表示，而 C++ 中空指针可以用 <strong>nullptr 或者 0</strong> 表示。</li><li>C++ 支持异常处理，可以捕获异常，Go 使用 panic 并保存所有的错误信息。</li><li>Go 可以利用 goroutines 与 channel 来进行并发与多线程，C++ 只能使用线程</li></ol></li></ol><h2 id="Rust和C-的区别"><a href="#Rust和C-的区别" class="headerlink" title="Rust和C++的区别"></a>Rust和C++的区别</h2><ol><li><p>二者的相同之处：</p><p>二者都支持指针操作，都可以用来作为系统编程语言，二者都可以用来操作底层硬件，二者都都具有与 C 语言程序相当的性能。</p></li><li><p>二者的不同之处：</p><ol><li>Rust 不允许控制指针和悬空指针，C++ 则允许空指针；</li><li>Rust 只支持<strong>函数式编程</strong>，C++ 支持的语言特性较多；</li><li>Rust 没有头文件，C++ 有头文件；</li><li>Rust 语言自带有内存管理，保证内存使用安全，Rust 利用编译时的静态分析很大程度上保证了代码使用内存的安全性；而 C++ 需要进行手动申请和释放内存；</li><li>Rust 利用静态分析，在编译时会分析代码由于并发引起的数据竞争，较好的做好的并发处理；C++ 的使用多线程并发容易引起各种数据竞争的问题。</li></ol></li></ol><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><p>详细：<a target="_blank" rel="noopener" href="https://aweiii.work/posts/3687adfb/">C++11 新特性</a></p><ol><li><p>类型推导</p><ol><li>auto</li><li>decltype</li></ol></li><li><p>闭包</p><ol><li><p>lambda表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture list] (parameter list) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">return</span> type<br>&#123;<br>function body;<br>&#125;;<br><br><span class="hljs-comment">// capture list</span><br>[]      <span class="hljs-comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span><br>[x, &amp;y] <span class="hljs-comment">// x以传值方式传入（默认），y以引用方式传入。</span><br>[&amp;]     <span class="hljs-comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span><br>[=]     <span class="hljs-comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span><br>[&amp;, x]  <span class="hljs-comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span><br>[=, &amp;z] <span class="hljs-comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span><br></code></pre></td></tr></table></figure></li><li><p>仿函数</p></li><li><p>bind绑定器</p></li></ol></li><li><p>范围for</p></li><li><p>右值引用</p><p>C++ 表达式中的 “值分类”（value categories）属性为<strong>左值</strong>或<strong>右值</strong>。其中左值是对应（refer to）内存中<strong>有确定存储地址的对象的表达式的值</strong>，而右值是<strong>所有不是左值的表达式的值</strong>。因而，右值可以是字面量、临时对象等表达式。能否被赋值不是区分 C++ 左值与右值的依据，C++ 的 const 左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<strong>左值与右值的根本区别在于是否允许取地址 &amp; 运算符获得对应的内存地址</strong>。<br>C++ 03 在用<strong>临时对象或函数返回值</strong>给左值对象赋值时的深度拷贝（deep copy），因此<strong>造成性能低下</strong>。考虑到临时对象的生命期仅在表达式中持续，如果把临时对象的内容直接<strong>移动（move）</strong>给被赋值的左值对象（<strong>右值参数所绑定的内部指针复制给新的对象，然后把该指针置为空</strong>），<strong>效率改善</strong>将是显著的。<br>C++ 右值引用即绑定到右值的引用，用 &amp;&amp; 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。左值引用是绑定到左值对象上；右值引用是绑定到临时对象上。左值对象是指可以通过取地址 &amp; 运算符得到该对象的内存地址；而临时对象是不能用取地址 &amp; 运算符获取到对象的内存地址，具体的引用绑定规则如下:</p><ul><li>非常量左值引用（X &amp;）：只能绑定到 X 类型的左值对象；</li><li>常量左值引用（const X &amp;）：可以绑定到 X、const X 类型的左值对象，或 X、const X 类型的右值；</li><li>非常量右值引用（X &amp;&amp;）：只能绑定到 X 类型的右值；</li><li>常量右值引用（const X &amp;&amp;）：可以绑定规定到 X、const X 类型的右值。</li></ul></li><li><p>标准库 move() 函数</p><p>move() 函数：通过该函数可获得绑定到左值上的右值引用。通过 move 获取变量的右值引用，从而可以调用对象的移动拷贝构造函数和移动赋值构造函数。</p></li><li><p>智能指针</p></li><li><p>使用或禁用对象的默认函数</p></li><li><p>constexpr</p><ol><li>常量表示式对编译器来说是优化的机会，编译器时常在<strong>编译期</strong>执行它们并且将值存入程序中。同样地，在许多场合下，C++ 标准要求使用常量表示式。例如在数组大小的定义上，以及枚举值（enumerator values）都要求必须是常量表示式。</li><li><strong>与const的区别</strong>：const修饰的变量可以在运行时才初始化，而constexpr则一定会在编译期初始化，constexpr才是名副其实的常量，而const表示的是read only的语义，但是也可能通过指针去修改它</li><li>用 constexpr 修饰函数将限制函数的行为：<ol><li>函数的回返值类型不能为void；</li><li>函数体不能声明变量或定义新的类型；</li><li>函数体只能包含声明、null语句或者一段return语句；</li><li>函数的内容必须依照 “return expr” 的形式，在参数替换后，expr 必须是个常量表达式；</li><li>这些常量表达式只能够调用其他被定义为 constexpr 的函数，或是其他常量形式的参数；</li><li>constexpr 修饰符的函数直到在该编译单元内被定义之前是不能够被调用的，声明为 constexpr 的函数也可以像其他函数一样用于常量表达式以外的调用。</li></ol></li></ol></li><li><p>初始化列表</p></li><li><p>nullptr</p></li></ol><h1 id="关键字与关键库函数"><a href="#关键字与关键库函数" class="headerlink" title="关键字与关键库函数"></a>关键字与关键库函数</h1><h2 id="sizeof-和-strlen-的区别"><a href="#sizeof-和-strlen-的区别" class="headerlink" title="sizeof 和 strlen 的区别"></a>sizeof 和 strlen 的区别</h2><ol><li>strlen 本身是<strong>库函数</strong>，因此在程序<strong>运行</strong>过程中计算长度；而 sizeof 是<strong>运算符</strong>，在<strong>编译</strong>时计算长度；sizeof 的<strong>参数</strong>可以是类型，也可以是变量，且必须是完整类型；strlen 的<strong>参数</strong>必须是 char * 类型的变量。</li><li>sizeof 接受的参数可以是对象也可以是表达式，但是 sizeof(expression) 在运行时<strong>不会对接受的表达式进行计算</strong>，编译器只会推导表达式的类型从而计算占用的字节大小；而 strlen 是一个函数，<strong>如果接受表达式则会对表达式进行运算</strong>。</li></ol><h2 id="lambda-表达式的应用"><a href="#lambda-表达式的应用" class="headerlink" title="lambda 表达式的应用"></a>lambda 表达式的应用</h2><p>闭包有很多种定义，一种说法是，闭包是<strong>带有上下文的函数，即有状态的函数</strong>。<br>那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。<br>lambda表达式的价值在于，<strong>就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密</strong>。</p><h2 id="explicit的作用"><a href="#explicit的作用" class="headerlink" title="explicit的作用"></a>explicit的作用</h2><p>用来<strong>声明类构造函数是显式调用</strong>的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。<strong>只可用于修饰单参构造函数</strong>，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。</p><h2 id="C-和-C-中-static-的作用"><a href="#C-和-C-中-static-的作用" class="headerlink" title="C 和 C++ 中 static 的作用"></a>C 和 C++ 中 static 的作用</h2><p>在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数。<br>在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</p><ol><li><p>static 全局静态变量：</p><p>普通全局变量和 static 全局静态变量都为<strong>静态存储方式</strong>。普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；<br>静态全局变量则<strong>限制了其作用域</strong>，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</p></li><li><p>static 局部静态变量：</p><p>局部静态变量只能被初始化一次。与全局静态变量不同的是静态局部变量的作用域仅限于函数内部，它的<strong>作用域与函数内部的局部变量相同</strong>。实际上局部静态变量同样也存储在<strong>静态存储区</strong>，因此它的生命周期贯穿于整个程序运行期间。</p></li><li><p>static 静态函数：<br>static 函数限制<strong>函数的作用域</strong>，仅可在定义该函数的文件内部调用。</p></li><li><p>static 静态成员变量：</p><p>静态成员变量是<strong>在类内进行声明，在类外进行定义和初始化</strong>，在类外进行定义和初始化的时候不要出现 static 关键字和 private、public、protected 访问规则。<br>静态成员变量相当于类域中的全局变量，<strong>被类的所有对象所共享，包括派生类的对象</strong>，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化。<br>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</p></li><li><p>static 静态成员函数：</p><p>静态成员函数<strong>不能调用非静态成员变量或者非静态成员函数</strong>，因为静态成员函数<strong>没有 this 指针</strong>。静态成员函数做为类作用域的全局函数。<br>静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。</p></li></ol><h2 id="const-作用以及用法"><a href="#const-作用以及用法" class="headerlink" title="const 作用以及用法"></a>const 作用以及用法</h2><ol><li><p>const变量</p></li><li><p>const指针</p></li><li><p>const引用</p></li><li><p>cosnt成员变量</p><p>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。<br>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此<strong>不能在类的声明中初始化 const 成员变量</strong>。</p></li><li><p>const参数与返回值</p></li><li><p>const成员函数</p></li></ol><h2 id="define-和-const-的区别"><a href="#define-和-const-的区别" class="headerlink" title="define 和 const 的区别"></a>define 和 const 的区别</h2><ol><li>编译阶段：define 是在<strong>编译预处理阶段</strong>进行替换，const 是在<strong>编译阶段</strong>确定其值。</li><li>安全性：define 定义的宏常量<strong>没有数据类型</strong>，只是进行简单的<strong>代码替换</strong>，不会进行<strong>类型安全的检查</strong>；const 定义的常量是<strong>有类型的</strong>，是要进行判断的，可以避免一些低级的错误。</li><li>存储空间：define 定义的宏定义只是作为<strong>代码替换</strong>的表达式而已，宏定义本身不占用内存空间，define 定义的宏常量，<strong>在程序中使用多少次就会进行多少次替换</strong>，内存中有<strong>多个备份</strong>，实际使用宏定义替换代码时占用的是<strong>代码段的空间</strong>；const 定义的常量占用<strong>静态存储区的只读空间</strong>，程序运行过程中<strong>常量只有一份</strong>。</li><li>调试：define 定义的宏常量<strong>不能调试</strong>，因为在预编译阶段就已经进行替换了；const 定义的常量<strong>可以进行调试</strong>。</li><li>define 可以<strong>接受参数</strong>构造非常复杂的表达式，const <strong>不能接受参数</strong>。</li></ol><h2 id="define-和-typedef-的区别"><a href="#define-和-typedef-的区别" class="headerlink" title="define 和 typedef 的区别"></a>define 和 typedef 的区别</h2><ol><li>#define 作为预处理指令，在<strong>编译预处理</strong>时进行<strong>替换操作</strong>，<strong>不作正确性检查</strong>，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是<strong>关键字</strong>，在<strong>编译</strong>时处理，有类型检查功能，用来给一个已经存在的<strong>类型一个别名</strong>，但不能在一个函数定义里面使用 typedef 。</li><li>typedef 用来定义<strong>类型的别名</strong>，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li><li>#define <strong>没有作用域的限制</strong>，只要是之前预定义过的宏，在以后的程序中都可以使用，如果在 .cpp 文件中定义了宏，则在整个文件中都可以使用该宏，如果在 .h 文件中定义了宏，则只要包含该头文件都可以使用；而 <strong>typedef 有自己的作用域</strong>，如果在函数之外定义了类型，则在整个文件中都可以使用该类型定义，如果在函数内部定义了该类型，则只能在函数内部使用该类型。</li><li>指针的操作：typedef 和 #define 在处理指针时不完全一样。</li></ol><h2 id="inline的作用以及使用方法"><a href="#inline的作用以及使用方法" class="headerlink" title="inline的作用以及使用方法"></a>inline的作用以及使用方法</h2><p>inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是<strong>直接在调用点处展开</strong>，这样可以大大<strong>减少由函数调用带来的开销</strong>，从而提高程序的运行效率。在内联函数出现之前，在 C&#x2F;C++ 的大型工程中常见用 #define 定义一些“函数”来消除调用这些函数的开销。<strong>内联函数设计的目的之一，就是取代 #define 的这项功能</strong>。由于使用 #define 定义的“函数”，编译器<strong>不会检查其参数的正确性</strong>等，而使用 inline 定义的函数，可以指定参数类型，则会被编译器校验）。内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</p><ol><li>使用方法：<strong>类内定义成员函数默认是内联函数</strong>，<strong>除了虚函数</strong>以外，因为虚函数是在<strong>运行时</strong>决定的，在<strong>编译时</strong>还无法确定虚函数的实际调用。在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数。</li><li>类外定义成员函数，若想定义为内联函数，需用关键字声明。当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。关键字 <strong>inline 必须与函数定义体放在一起才能使函数成为内联，如果只是 inline 放在函数声明前面不起任何作用</strong>。</li></ol><h2 id="inline-的工作原理"><a href="#inline-的工作原理" class="headerlink" title="inline 的工作原理"></a>inline 的工作原理</h2><ol><li><p>内联函数的工作原理：</p><p>内联函数<strong>不是在调用时发生控制转移关系</strong>，而是在<strong>编译阶段</strong>将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来<strong>替换</strong>。函数调用时，需要切换栈帧寄存器，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而内联函数则可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点。<br>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要<strong>保护现场</strong>，被调函数执行完后，再恢复现场，该过程需要<strong>较大的资源开销</strong>。<br>虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内联函数也可以有指向它的函数指针。</p></li><li><p>内联函数的优缺点：</p><ol><li><p>内联函数具有以下优点：</p><p><strong>不会产生函数调用开销</strong>。节省了调用函数时在堆栈上推送&#x2F;弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体<strong>执行上下文特定的优化</strong>，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。</p></li><li><p>内联函数的缺点：</p><ol><li><strong>从内联函数中添加的变量会消耗额外的寄存器</strong>，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销。在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加。因此，如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销。</li><li>如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的<strong>代码重复</strong>。</li><li>过多的内联也会<strong>降低指令缓存命中率</strong>，从而降低从缓存内存到主内存的指令获取速度。</li><li>如果有人更改内联函数内的代码，<strong>内联函数可能会增加编译时间开销</strong>，那么所有调用位置都必须<strong>重新编译</strong>，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.</li><li>内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。<strong>内存抖动</strong>会导致计算机性能下降。</li></ol></li></ol></li><li><p>inline 函数的使用场景：</p><ol><li>内联函数一般只适用于<strong>比较短小，处理较为简单的函数</strong>。内联只是<strong>对编译器的请求</strong>，而不是命令。编译器可以<strong>忽略内联请求</strong>。编译器可能<strong>不会</strong>在以下情况下执行内联：</li><li>如果函数包含循环（for, while, do-while）；</li><li>如果一个函数包含静态变量；</li><li>如果一个函数是递归的；</li><li>如果函数返回类型不是 void，并且函数体中不存在 return 语句；</li><li>如果函数包含 switch 或 goto 语句；</li></ol></li><li><p>内联可以去除函数只能定义一次的限制：</p><p>内联函数可以在程序中定义不止一次， 但是 inline 函数的定义在某个源文件中只能出现一次，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 inline 函数，所有 include 该头文件，如果修改了头文件中的 inline 函数时，使用了该头文件的所有源文件都必须重新编译。比如我们可以在定义以下两个文件包含相同的函数。</p></li></ol><h2 id="define-和-inline-的区别"><a href="#define-和-inline-的区别" class="headerlink" title="define 和 inline 的区别"></a>define 和 inline 的区别</h2><ol><li>内联函数是在<strong>编译时</strong>展开，而宏在<strong>编译预处理时</strong>展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li><li>内联函数是真正的<strong>函数</strong>，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销，在编译后的代码段中可以看到内联函数的定义。宏定义编写较为复杂，常需要增加一些括号来避免歧义。宏定义只进行<strong>文本替换</strong>，不会对参数的类型、语句能否正常编译等进行检查，因此在实际使用宏时非常容易出错。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行<strong>检查</strong>。</li><li>内联函数可以进行<strong>调试</strong>，宏定义的“函数”<strong>无法调试</strong>。</li><li>由于类的成员函数全部为内联函数，通过内联函数，可以访问<strong>类的数据成员</strong>，而<strong>宏不能访问类的数据成员。</strong></li><li>在 inline 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次。（ ？）</li></ol><h2 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h2><ol><li>new 的简介：<ol><li>new 是 C++ 中的关键字，尝试<strong>分配和初始化</strong>指定或占位符类型的<strong>对象</strong>或对象数组，并返回指向对象 (或数组的初始对象) 的指针。</li><li>用 new 创建对象时<ol><li>首先从<strong>堆</strong>中申请相应的内存空间</li><li>然后调用对象的<strong>构造函数</strong></li><li>最后<strong>返回</strong>指向<strong>对象的指针</strong>。</li></ol></li><li>operator new 从自由存储区（free store）上为对象动态分配内存空间，而 malloc 函数从堆上动态分配内存。自由存储区是 C++ 基于 operator new 的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C 语言使用 malloc 从堆上分配内存，使用 free 释放已分配的对应内存。<strong>new 可以指定在内存地址空间创建对象</strong>，但 placement new 需要手动调用析构，不能直接delete（会释放空间）。</li><li>在 cpp 中由于 <strong>new 作为操作符可以进行重载</strong>，所以可以对 new 进行重载，比如可以指定构造函数对对象进行初始化。对 new 操作符可以进行<strong>全局重载</strong>和<strong>局部重载</strong>，全局重载后，所有调用 new 的操作都会被重写；局部重载就是在<strong>类中重写 operator new 函数</strong>，但<strong>只会对该类生效</strong>，即该类执行 new 操作时会生效。</li></ol></li></ol><h2 id="new和delete是如何实现的"><a href="#new和delete是如何实现的" class="headerlink" title="new和delete是如何实现的"></a>new和delete是如何实现的</h2><p>new：</p><ol><li>申请空间</li><li>构造对象</li><li>返回指针</li></ol><p>delete：</p><ol><li>析构对象</li><li>释放空间</li></ol><h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h2><ol><li>malloc 的实现原理：<ol><li>malloc 为 <strong>C 语言的库函数</strong>，主要用来 <strong>从堆中</strong>申请指定大小且连续的内存空间。实际的底层实现可能较为复杂，每个程序都带有自己的动态内存管理子模块，<strong>常见的动态内存分配算法有 best fit 和 first fit 等</strong>。</li><li>malloc 分配内存的方式<ol><li>brk() 和 sbrk() 修改堆顶指针</li><li>mmap() 文件映射区</li></ol></li></ol></li><li>new 与 malloc 的区别：<ol><li>new 在申请内存的同时，会调用对象的<strong>构造函数</strong>，对象会进行初始化，malloc 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。</li><li>new 可以<strong>指定内存空间</strong>初始化对象，而 malloc 只能从<strong>堆中</strong>申请内存。</li><li>new 是 c++ 中的一个<strong>关键字</strong>，而 malloc 是 C 中的一个<strong>函数</strong>。</li><li>new 的返回值为一个<strong>对象的指针类型</strong>，而 malloc 统一返回 <strong>void * 指针</strong>。</li><li>new 内存分配成功，返回该<strong>对象类型的指针</strong>，分配失败，抛出 <strong>bad_alloc 异常</strong>；而 malloc 成功申请到内存，返回指向该<strong>内存的指针</strong>；分配失败，返回 <strong>NULL 指针</strong>。</li><li>new 的空间大小由编译器会<strong>自动计算</strong>，而 malloc 则需要<strong>指定空间</strong>大小。</li><li>new 作为一个运算符可以<strong>进行重载</strong>，而 malloc 作为一个C库函数<strong>不支持重载</strong>。</li><li>malloc 可以更改申请过的空间大小，我们可以<strong>realloc 指定空间大小</strong>，而 new<strong>一旦申请则无法更改。</strong></li></ol></li></ol><h2 id="delete-和-free-的区别"><a href="#delete-和-free-的区别" class="headerlink" title="delete 和 free 的区别"></a>delete 和 free 的区别</h2><ol><li><p>free 的简介：</p><p>free 释放 heap 中申请的动态内存空间，只能释放 <strong>malloc，calloc，realloc</strong> 申请的内存。需要注意的是，free 函数只是将参数指针指向的内存<strong>归还给操作系统，并不会把参数指针置 NULL</strong>，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 free 之后，通常需要<strong>手动将指针置 NULL</strong>。内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 free 函数是没有能力去真正的 free 内存的，只是<strong>向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存</strong>。free 后指针仍然指向原来的堆地址，实际还可以使用，但操作系统可能将这块内存已经分配给其他模块使用，一般建议在 free 以后将指针置为空。一个指针经过两次 free，也是比较危险的操作，因为可能该段内存已被别的内存使用申请使用了，free 之后会造成严重后果。</p></li><li><p>delete 的简介：</p><p>delete 是 C++ 中的一个操作符，<strong>如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 operator delete 的标准库函数来释放所占的内存空间</strong>。delete 用来释放单个对象所占的空间，只会<strong>调用一次析构函数</strong>；delete [] 用来释放数组空间，会对数组中的<strong>每个元素都调用一次析构函数</strong>。delete 只能用来释放 new 操作返回的指针，否则会产生不可预知的后果。在单个对象上的删除 使用 delete [] 的数组形式，以及对数组使用非数组形式的删除都会产生不可预知的后果。<strong>如果 new 的对象是指定地址，则不能直接调用 delete。</strong></p></li><li><p><strong>delete 与 free 的区别：</strong></p><ol><li>delete 是 C++ 中的一个操作符，可以进行<strong>重载</strong>；而 free 是 C 中的一个函数，不能进行重载；</li><li>free 只会释放指向的内存，不会执行对象的<strong>析构</strong>函数；delete 则可以执行对象的析构函数；</li></ol></li></ol><h2 id="new-x2F-delete-和new-x2F-delete-的区别"><a href="#new-x2F-delete-和new-x2F-delete-的区别" class="headerlink" title="new&#x2F;delete 和new[]&#x2F;delete[]的区别"></a>new&#x2F;delete 和new[]&#x2F;delete[]的区别</h2><p>new&#x2F;delete只调用<strong>一次构造&#x2F;析构函数</strong>，new[]&#x2F;delete[] 根据数组大小，<strong>多次调用构造&#x2F;析构函数</strong>，分配&#x2F;释放的空间大小是整个数组的大小。<br>如果析构的对象里面没有指针类型的成员，直接使用delete释放new[]的对象并不会导致内存泄漏。</p><h2 id="C-和-C-中-struct-的区别"><a href="#C-和-C-中-struct-的区别" class="headerlink" title="C 和 C++ 中 struct 的区别"></a>C 和 C++ 中 struct 的区别</h2><ol><li>在 C 语言中 struct 是<strong>用户自定义数据类型</strong>；在 C++ 中 struct 是<strong>抽象数据类型</strong>，支持成员函数的定义。C++ 中的 class 可以实现 struct 的所有功能，<strong>C++ 为了兼容 C 语言保留了 struct 关键字</strong>。</li><li>C 语言中 struct <strong>没有访问权限的设置</strong>，是一些变量的<strong>集合体</strong>，不能定义成员函数；C++ 中 struct 可以和类一样，有<strong>访问权限</strong>，并可以定义成员函数。</li><li>C 语言中 struct 定义的自定义数据类型，<strong>在定义该类型的变量时，需要加上 struct 关键字</strong>，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var。</li><li>C++ 中 struct <strong>可以继承，也可以实现多态</strong>，而 C 语言中<strong>不支持继承和多态</strong>。</li></ol><h2 id="struct-和-union-的区别"><a href="#struct-和-union-的区别" class="headerlink" title="struct 和 union 的区别"></a>struct 和 union 的区别</h2><ol><li>union 是联合体，struct 是结构体。union 中的所有成员变量<strong>共享同一段内存空间</strong>，struct 中的每个成员变量<strong>独占内存空间</strong>。</li><li>联合体和结构体<strong>都是由若干个数据类型不同的数据成员组成</strong>。使用时，联合体<strong>只有一个有效</strong>的成员；而结构体<strong>所有的成员都有效</strong>。</li><li>对联合体的不同成员赋值，将会对<strong>覆盖</strong>其他成员的值，而对于结构体的对不同成员赋值时，<strong>相互不影响</strong>。</li><li>联合体的大小为其内部所有<strong>变量的最大值</strong>，按照<strong>最大类型的倍数进行分配大小</strong>；结构体分配内存的大小遵循<strong>内存对齐原则</strong>。</li><li>struct 可以定义<strong>变长数组成员变量</strong> int a[]，union 中<strong>不能包含有这种不确定长度的变量</strong>。</li></ol><h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h2><p>C++ 中<strong>为了兼容 C 语言而保留了 C 语言的 struct 关键字</strong>，并且加以扩充。在 C 语言中，struct 只能包含成员变量，不能包含成员函数。而在 C++ 中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。<br>C++ 中的 struct 和 class 基本是通用的，唯有几个细节不同：</p><ol><li>class 中类中的成员<strong>默认访问权限</strong>都是 private 属性的；而在 struct 中结构体中的成员默认都是 public 属性的。</li><li>class <strong>默认继承权限</strong>是 private 继承，而 struct 继承默认是 public 继承。</li><li>class 可以用于定义<strong>模板参数</strong>，struct 不能用于定义模板参数。</li></ol><h2 id="volatile-的作用与使用场景"><a href="#volatile-的作用与使用场景" class="headerlink" title="volatile 的作用与使用场景"></a>volatile 的作用与使用场景</h2><ol><li><p>volatile 的简介：</p><p>当对象的值可能<strong>在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化</strong>。volatile 关键字修饰变量后，提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会<strong>直接从变量地址中读取数据</strong>。如果没有 volatile 关键字，则编译器可能<strong>优化</strong>读取和存储，可能<strong>暂时使用寄存器中的值</strong>，如果这个变量由别的程序更新了的话，将出现不一致的现象。<br>使用 volatile 关键字试图阻止编译器过度优化，volatile 主要作用如下：</p><pre><code class="hljs">  1. 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）
  2. 阻止编译器调整操作 volatile 变量的指令排序。
</code></pre></li><li><p>volatile 的作用：</p><p>读取变量时，阻止编译器对缓存的优化：volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：<strong>操作系统、硬件或者其它线程</strong>等。遇到这个关键字声明的变量，编译器对访问该变量的代码就<strong>不再进行优化</strong>，从而可以提供对特殊地址的稳定访问。比如声明时 volatile 变量，int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是<strong>重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。</p></li><li><p>volatile 的应用场景：</p><p>在实际场景中除了<strong>操纵硬件</strong>需要用到 volatile 以外，更多的可能是多线程并发访问<strong>共享变量</strong>时，一个线程改变了变量的值，怎样让改变后的值对其它线程可见，此时我们就需要使用 volatile 进行修饰。一般说来，volatile 用在如下的几个地方：</p><ol><li><p><strong>中断服务程序</strong>中修改的供其它程序检测的变量需要加 volatile；</p></li><li><p><strong>多任务环境下</strong>各任务间共享的标志应该加 volatile；</p></li><li><p>存储器映射的<strong>硬件寄存器</strong>通常也要加 volatile 说明，因为每次对它的读写都可能有不同意义；</p></li></ol></li></ol><h2 id="返回函数中的静态变量的地址会发生什么"><a href="#返回函数中的静态变量的地址会发生什么" class="headerlink" title="返回函数中的静态变量的地址会发生什么"></a>返回函数中的静态变量的地址会发生什么</h2><p>前面的章节中讲过，静态局部变量存在<strong>静态区</strong>，程序初始化时则已经创建了改变量，变量的生存周期为<strong>整个程序的生命周期</strong>。在函数中定义静态局部变量 var，使得离开该函数的作用域后，该变量<strong>不会销毁</strong>，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果，该静态局部变量直到程序运行结束后才销毁。<br>需要注意的是，全局静态对象在程序初始化时，则进行了初始化。局部静态对象的初始化在第一次进入函数内部时，才会调用对象的构造函数进行初始化。<strong>程序退出时，先释放静态局部变量，再释放全局静态变量。</strong></p><h2 id="extern-C-的作用"><a href="#extern-C-的作用" class="headerlink" title="extern C 的作用"></a>extern C 的作用</h2><p>C 和 C++ 对同一个函数经过编译后生成的函数名是不同的，由于 <strong>C++ 支持函数重载</strong>，因此编译器编译函数的过程中会将函数的<strong>参数类型也加到编译后的函数名中</strong>，而不仅仅是原始的函数名。<br>由于 C 语言并<strong>不支持函数重载</strong>，在 C 语言中<strong>函数不能重名</strong>，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在 C++ 中调用一个使用 C 语言编写的模块中的某个函数 test，C++ 是根据 C++ 的函数名称修饰方式来查找并链接这个函数，去在生成的符号表查找 _Z4testv 这个函数的代码，此时就<strong>会发生链接错误</strong>。而此时我们用 extern C 声明，那么在<strong>链接时</strong>，C++ 编译器则<strong>按照 C 语言的函数命名规则 test 去符号表中查找对应的函数</strong>。因此当 C++ 程序需要调用 C 语言编写的函数，C++ 使用链接指示，即 extern “C” 指出任意非 C++ 函数所用的语言。</p><h2 id="sizeof-1-x3D-x3D-1-在C和C-中的结果"><a href="#sizeof-1-x3D-x3D-1-在C和C-中的结果" class="headerlink" title="sizeof(1 &#x3D;&#x3D; 1) 在C和C++中的结果"></a>sizeof(1 &#x3D;&#x3D; 1) 在C和C++中的结果</h2><p>sizeof 接受的参数<strong>可以是对象也可以是表达式</strong>，但是 sizeof(expression) 在运行时不会对接受的表达式进行计算，编译器<strong>只会推导表达式的类型</strong>从而计算占用的字节大小；</p><ul><li>由于 C 语言没有 bool 类型，用整形表示布尔型，因此 sizeof(1 &#x3D;&#x3D; 1) 返回 4；</li><li>由于 C++ 语言有 bool 类型，布尔型占 1 个字节，因此 sizeof(1 &#x3D;&#x3D; 1) 返回 1。</li></ul><h2 id="memmove-函数的底层原理"><a href="#memmove-函数的底层原理" class="headerlink" title="memmove 函数的底层原理"></a>memmove 函数的底层原理</h2><p>memmove 用于<strong>拷贝字节</strong>，如果目标区域和源区域有重叠的话，memmove 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 <strong>memcpy 函数功能相同</strong>。面试时会经常要求实现 memmove 函数，在实现的时候需要特殊处理地址重叠的情况。</p><ol><li><p>memcpy实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">my_memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">assert</span>(src != <span class="hljs-literal">nullptr</span>&amp;&amp;dest != <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-comment">//判断dest指针和src指针是否为空，若为空抛出异常</span><br>	<span class="hljs-type">char</span>* tmp_dest = (<span class="hljs-type">char</span>*)dest;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* tmp_src = (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)src;<br>	<span class="hljs-comment">//将指针dest和指针src由void强转为char，</span><br>	<span class="hljs-comment">//使得每次均是对内存中的一个字节进行拷贝</span><br>	<span class="hljs-keyword">while</span> (count--)<br>		*tmp_dest++ = *tmp_src++;<br>	<span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>memmove实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest, <span class="hljs-type">void</span>* src, <span class="hljs-type">size_t</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">void</span>* ret = dest;<br>	<span class="hljs-built_in">assert</span>(dest);<br>	<span class="hljs-built_in">assert</span>(src);<br> <br>	<span class="hljs-keyword">if</span> (dest &lt; src)<span class="hljs-comment">//1 前-&gt;后</span><br>	&#123;<br>		<span class="hljs-keyword">while</span>(num--)<br>		&#123;<br>			*(<span class="hljs-type">char</span>*)dest = *(<span class="hljs-type">char</span>*)src;<br>			dest = (<span class="hljs-type">char</span>*)dest + <span class="hljs-number">1</span>;<br>			src = (<span class="hljs-type">char</span>*)src + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-comment">// 后-&gt;前</span><br>	&#123;<br>		<span class="hljs-keyword">while</span> (num--)<br>		&#123;<br>			*((<span class="hljs-type">char</span>*)dest + num) = *((<span class="hljs-type">char</span>*)src + num);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="strcpy-函数的缺陷"><a href="#strcpy-函数的缺陷" class="headerlink" title="strcpy 函数的缺陷"></a>strcpy 函数的缺陷</h2><ol><li><p>strcpy 函数的实现：</p><p>strcpy 是 C++ 语言的一个标准函数 ，strcpy 把含有 ‘\0’ 结束符的字符串复制到另一个地址空间，返回值的类型为 char*，返回值为拷贝后的字符串的首地址。</p></li><li><p>strcpy 函数的缺陷：</p><p>strcpy 函数<strong>不检查目的缓冲区的大小边界</strong>，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，<strong>会导致其他变量被覆盖</strong>。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> var = <span class="hljs-number">0x11112222</span>;<br>    <span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : var &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Address : arr &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;<br>    <span class="hljs-built_in">strcpy</span>(arr, <span class="hljs-string">&quot;hello world!&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;var:&quot;</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; <span class="hljs-comment">// 将变量 var 以 16 进制输出</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;arr:&quot;</span> &lt;&lt; arr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Address : var 0x23fe4c</span><br><span class="hljs-comment">Address : arr 0x23fe42</span><br><span class="hljs-comment">var:11002164</span><br><span class="hljs-comment">arr:hello world!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：从上述代码中可以看出，变量 var 的后六位被字符串 “hello world!” 的 “d!\0” 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：\0(0x00)，!(0x21)，d(0x64)。<br>原因：变量 arr 只分配的 10 个内存空间，通过上述程序中的地址可以看出 arr 和 var 在内存中是连续存放的，但是在调用 strcpy 函数进行拷贝时，源字符串 “hello world!” 所占的内存空间为 13，因此在拷贝的过程中会占用 var 的内存空间，导致 var 的后六位被覆盖。由于 strcpy 函数存在一定的安全风险，如果使用不当容易出现安全问题，利用 strcpy 的特性可以编写 shellcode 来进行缓冲区溢出攻击。在大多数工程代码中，<strong>为了保证代码的健壮性和安全性，一般会使用 strncpy 代替 strcpy</strong>。</p><h2 id="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢"><a href="#在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢" class="headerlink" title="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢"></a>在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢</h2><ol><li>需要返回<strong>函数内局部变量的内存</strong>的时候用指针。使用指针传参需要<strong>开辟内存</strong>，用完要记得释放指针，不然会内存泄漏。而<strong>返回局部变量的引用是没有意义的</strong>；</li><li>对栈空间大小比较敏感（比如<strong>递归</strong>）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小；</li><li><strong>类对象</strong>作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li></ol><h2 id="区别以下指针类型"><a href="#区别以下指针类型" class="headerlink" title="区别以下指针类型"></a>区别以下指针类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>]; 	<span class="hljs-comment">// p是一个大小为10的数组，数组中的每个元素是一个int指针</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>];	<span class="hljs-comment">// p是一个指针，指向大小为10的int数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;	<span class="hljs-comment">// p是一个函数名，参数为int，返回值为int*</span><br><span class="hljs-built_in">int</span> (*p)(<span class="hljs-type">int</span>);	<span class="hljs-comment">// p是一个函数指针，参数为int，返回值为int</span><br></code></pre></td></tr></table></figure><h2 id="被free回收的内存是立即返还给操作系统吗"><a href="#被free回收的内存是立即返还给操作系统吗" class="headerlink" title="被free回收的内存是立即返还给操作系统吗"></a>被free回收的内存是立即返还给操作系统吗</h2><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就<strong>避免了频繁的系统调用</strong>，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><h2 id="宏定义和函数有何区别"><a href="#宏定义和函数有何区别" class="headerlink" title="宏定义和函数有何区别"></a>宏定义和函数有何区别</h2><ol><li>宏在<strong>预处理阶段</strong>完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更<strong>快</strong>；函数调用在运行时需要<strong>跳转</strong>到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏定义参数没有类型，不进行<strong>类型检查</strong>；函数参数具有类型，需要检查类型。</li><li>宏定义<strong>不要在最后加分号</strong>。</li></ol><h2 id="宏定义和typedef区别"><a href="#宏定义和typedef区别" class="headerlink" title="宏定义和typedef区别"></a>宏定义和typedef区别</h2><ol><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于<strong>定义类型别名</strong>。</li><li>宏替换发生在<strong>预处理</strong>，属于文本插入替换；typedef是<strong>编译</strong>的一部分。</li><li>宏不检查类型；typedef会检查数据类型。</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li><li>注意对指针的操作，typedef char _ p_char和#define p_char char _区别巨大。</li></ol><h2 id="变量声明和定义区别"><a href="#变量声明和定义区别" class="headerlink" title="变量声明和定义区别"></a>变量声明和定义区别</h2><ol><li>声明仅仅是把变量的<strong>声明的位置及类型</strong>提供给编译器，并不分配内存空间；定义要在定义的地方为其<strong>分配存储空间</strong>。</li><li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li></ol><h2 id="strlen和sizeof区别"><a href="#strlen和sizeof区别" class="headerlink" title="strlen和sizeof区别"></a>strlen和sizeof区别</h2><ol><li>sizeof是<strong>运算符</strong>，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的<strong>库函数</strong>。</li><li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串</li><li>因为<strong>sizeof值在编译时确定</strong>，所以不能用来得到动态分配（运行时分配）存储空间的大小</li></ol><h2 id="a和-amp-a有什么区别"><a href="#a和-amp-a有什么区别" class="headerlink" title="a和&amp;a有什么区别"></a>a和&amp;a有什么区别</h2><p>假设数组int a[10]; int (*p)[10] &#x3D; &amp;a;其中：</p><ol><li>a是数组名，是数组首元素地址，+1表示地址值加上一个<strong>int类型</strong>的大小，如果a的值是0x00000001，<strong>加1</strong>操作后变为0x00000005。*(a + 1) &#x3D; a[1]。</li><li>&amp;a是数组的指针，其<strong>类型为int (_)[10]（_就是前面提到的数组指针），其</strong>加1**时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int _)p ，此时输出 _p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li></ol><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象及其三大特征"><a href="#面向对象及其三大特征" class="headerlink" title="面向对象及其三大特征"></a>面向对象及其三大特征</h2><ol><li>面向对象：对象是指具体的某一个事物，这些<strong>事物的抽象就是类</strong>，类中包含<strong>数据（成员变量）</strong>和<strong>动作（成员方法）</strong>。</li><li>面向对象的三大特性：<ol><li>封装：将具体的实现过程和数据封装成一个函数，只能通过<strong>接口</strong>进行访问，<strong>降低耦合性</strong>。</li><li>继承：子类<strong>继承父类的特征和行为</strong>，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行<strong>重写</strong>，<strong>增强了类之间的耦合性</strong>，但是当父类中的成员变量、成员函数或者类本身被 <strong>final 关键字</strong>修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li><li>多态：多态就是<strong>不同继承类的对象，对同一消息做出不同的响应</strong>，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在 C++ 中多态一般是使用<strong>虚函数</strong>来实现的，使用基类指针调用函数方法时，如果该指针指向的是一个基类的对象，则调用的是基类的虚函数；如果该指针指向的是一个派生类的对象，则调用的是派生类的虚函数。</li></ol></li></ol><h2 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h2><ol><li><p>函数重载：<br>重载是指<strong>同一可访问区内</strong>被声明几个具有<strong>不同参数列表</strong>（参数的类型、个数、顺序）的<strong>同名函数</strong>，根据参数列表确定调用哪个函数，重载<strong>不关心函数返回类型</strong>。</p></li><li><p>函数隐藏：<br>函数隐藏是指派生类的函数<strong>屏蔽</strong>了与其同名的基类函数，只要是与基类同名的成员函数，不管参数列表是否相同，基类函数都会被隐藏。</p></li><li><p>函数重写（覆盖）：</p><p>函数覆盖是指派生类中存在<strong>重新定义</strong>的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p></li><li><p>重写和重载的区别：</p><ol><li>范围区别：对于类中函数的重载或者重写而言，<strong>重载</strong>发生在<strong>同一个类</strong>的内部，<strong>重写</strong>发生在<strong>不同的类</strong>之间（子类和父类之间）。</li><li>参数区别：重载的函数需要与原函数有<strong>相同的函数名、不同的参数列表，不关注函数的返回值类型</strong>；重写的函数的<strong>函数名、参数列表和返回值类型都需要和原函数相同</strong>，父类中被重写的函数需要<strong>有 virtual 修饰</strong>。</li><li>virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li></ol></li><li><p>隐藏和重写，重载的区别：</p><ol><li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li><li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但<strong>函数名</strong>一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</li><li>利用重写可以实现多态，而隐藏不可以。如果使用基类指针 p 指向派生类对象，利用这个指针调用函数时，对于隐藏的函数，会根据<strong>指针的类型</strong>去调用函数（静态绑定）；对于重写的函数，会根据指针所指<strong>对象的类型</strong>去调用函数（动态绑定）。重写必须使用 virtual 关键字，此时会更改派生类虚函数表的表项。</li><li>隐藏是发生在<strong>编译时</strong>，即在编译时由编译器实现隐藏，而重写一般<strong>发生运行</strong>时，即运行时会查找类的虚函数表，决定调用函数接口。</li></ol></li></ol><h2 id="多态及其实现方法"><a href="#多态及其实现方法" class="headerlink" title="多态及其实现方法"></a>多态及其实现方法</h2><p>多态性(polymorphism)可以简单地概括为<strong>“一个接口，多种方法”</strong>，它是面向对象编程领域的核心概念。<br>多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。</p><ol><li>编译时多态性（静态多态）：通过重载函数、类模板实现：先期联编 early binding</li><li>运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding</li></ol><p><strong>动态多态的实现原理：</strong><br>动态多态是通过<strong>虚函数</strong>实现的，虚函数的地址保存在<strong>虚函数表</strong>中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p><ol><li>在类中用 virtual 关键字声明的函数叫做虚函数；</li><li>存在虚函数的类都有一个<strong>虚函数表</strong>，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li><li>当基类指针指向派生类对象，基类指针调用虚函数时，该基类指针指的虚表指针实际指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数然后调用执行。</li></ol><h2 id="限制对象创建在堆或栈上"><a href="#限制对象创建在堆或栈上" class="headerlink" title="限制对象创建在堆或栈上"></a>限制对象创建在堆或栈上</h2><ol><li><p>限制对象只能建立在堆上：</p><ol><li>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。直接<strong>将类的构造函数设为私有</strong>，并提供另外的接口给外部调用。</li><li><strong>将析构函数设置为私有</strong>。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</li><li><strong>构造函数设置为 protected</strong>，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</li></ol></li><li><p>限制对象只能建立在栈上：</p><p>将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p></li></ol><h2 id="C-模板编程"><a href="#C-模板编程" class="headerlink" title="C++ 模板编程"></a>C++ 模板编程</h2><p>模板是 C++ 编程语言的一个特性，它允许函数和类使用泛型类型进行操作。这允许一个函数或类在许多不同的数据类型上工作，而无需为每个类型重写。<strong>C++ 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码，C++ 中使用 template 关键字。</strong>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。<br>共有三种模板：函数模板、类模板以及自 C++ 14 以来的变量模板：</p><ol><li><p>函数模板:<br>函数模板的行为<strong>类似于函数</strong>，只是模板可以有许多<strong>不同类型的参数</strong>。一个函数模板代表一个函数族。使用类型参数声明函数模板的格式是：</p></li><li><p>类模板：</p><p>类模板提供了基于参数生成类的规范。类模板通常<strong>用于实现容器</strong>。类模板通过<strong>将一组给定的类型作为模板参数传递给它来实例化</strong>。C++ 标准库包含许多类模板，特别是改编自标准模板库的容器，例如 vector，list。</p></li><li><p>变量模板：<br>在 C++14 以后，变量也可以参数化为特定的类型，这称为变量模板。</p></li></ol><h2 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h2><ol><li>虚函数：<br>被 virtual 关键字修饰的成员函数，C++ 的虚函数在运行时动态绑定，从而实现多态。</li><li>纯虚函数：<ol><li>纯虚函数在类中声明时，用 virtual 关键字修饰且加上 <strong>&#x3D;0</strong>，且没有函数的具体实现；</li><li>含有纯虚函数的类称为<strong>抽象类</strong>（只要含有纯虚函数这个类就是抽象类），类中只有<strong>接口定义</strong>，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，<strong>不能实例化对象</strong>。</li></ol></li></ol><p>对于抽象类需要说明的是:</p><ol><li>抽象类对象<strong>不能作为函数的参数，不能创建对象，不能作为函数返回类型</strong>；</li><li><strong>可以</strong>声明抽象类<strong>指针</strong>，可以声明抽象类的<strong>引用</strong>；</li><li>抽象类<strong>只能作为基类</strong>来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</li></ol><p>纯虚函数的作用：含有纯虚函数的基类要求<strong>任何派生类都要定义自己的实现方法</strong>，以实现多态性。实现了纯虚函数的子类，该<strong>纯虚函数在子类中就变成了虚函数</strong>。定义纯虚函数是为了<strong>实现统一的接口属性</strong>，用来规范派生类的接口属性，也即强制要求继承这个类的程序员必须实现这个函数。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以要求实现纯虚函数的属性，在面对对象设计中非常有用的一个特性。</p><h2 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h2><ol><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类（含有纯虚函数的类称为抽象基类）。</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上 virtual 关键字还需要加上 &#x3D;0;</li><li>虚函数必须实现，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</li></ol><h2 id="构造函数与析构函数是否可以定义为虚函数"><a href="#构造函数与析构函数是否可以定义为虚函数" class="headerlink" title="构造函数与析构函数是否可以定义为虚函数"></a>构造函数与析构函数是否可以定义为虚函数</h2><ol><li><p>构造函数一般不定义为虚函数:</p><ol><li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li><li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li><li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li><li>从类型上考虑：在创建对象时需要明确其类型。</li></ol></li><li><p>析构函数一般定义成虚函数：</p><p>析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</p></li></ol><h2 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h2><ol><li><p>空类的大小</p><p>由于在实际程序中，空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以 sizeof(A) 的大小为 1。</p></li><li><p>空类的成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;;                                       <span class="hljs-comment">// 缺省构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;tmp)&#123;&#125;;                           <span class="hljs-comment">// 拷贝构造函数</span><br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;;                                      <span class="hljs-comment">// 析构函数</span><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A &amp;tmp)&#123;&#125;;                <span class="hljs-comment">// 赋值运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;;             <span class="hljs-comment">// 取址运算符</span><br>    <span class="hljs-type">const</span> A *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;; <span class="hljs-comment">// 取址运算符（const 版本）</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h2><p>说明：类的大小是指类的<strong>实例化对象的大小</strong>，用 sizeof 对类型名操作时，结果是该类型的对象的大小。计算原则如下：</p><ol><li>遵循结构体的成员变量<strong>对齐</strong>原则。</li><li>与<strong>普通成员变量</strong>有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li><li><strong>虚函数</strong>对类的大小有影响，是因为虚函数表指针的影响。</li><li><strong>虚继承</strong>对类的大小有影响，是因为虚基表指针带来的影响。</li><li><strong>空类</strong>的大小是一个特殊情况，空类的大小为 1，空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以sizeof(A) 的大小为 1。</li></ol><h2 id="为什么拷贝构造必须声明为引用"><a href="#为什么拷贝构造必须声明为引用" class="headerlink" title="为什么拷贝构造必须声明为引用"></a>为什么拷贝构造必须声明为引用</h2><p>避免拷贝构造函数无限制的递归而导致栈溢出。</p><h2 id="成员初始化列表效率高的原因"><a href="#成员初始化列表效率高的原因" class="headerlink" title="成员初始化列表效率高的原因"></a>成员初始化列表效率高的原因</h2><p>对象的成员函数数据类型可分为语言内置类型和用户自定义类，对于用户自定义类型，利用成员初始化列表效率高。用户自定义类型如果使用类初始化列表，<strong>直接调用该成员变量对应的构造函数即完成初始化</strong>；如果在构造函数中初始化，由于 C++ 规定对象的成员变量的初始化动作发生在进入自身的构造函数本体之前，那么在执行构造函数之前<strong>首先调用默认的构造函数为成员变量设初值</strong>，在进入函数体之后，<strong>再显式调用该成员变量对应的构造函数</strong>。因此使用列表初始化会减少调用默认的构造函数的过程，效率更高一些。</p><h2 id="如何让类不被继承"><a href="#如何让类不被继承" class="headerlink" title="如何让类不被继承"></a>如何让类不被继承</h2><ol><li>final</li><li>使用友元、虚继承和私有构造函数来实现</li></ol><p>具体原因：</p><ol><li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li><li>B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，<strong>C 类的构造函数要负责 Base 类的构造</strong>，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li></ol><p>注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</p><h1 id="语言特性相关"><a href="#语言特性相关" class="headerlink" title="语言特性相关"></a>语言特性相关</h1><h2 id="左值与右值：区别、引用及转化"><a href="#左值与右值：区别、引用及转化" class="headerlink" title="左值与右值：区别、引用及转化"></a>左值与右值：区别、引用及转化</h2><ol><li><p>左值与右值:</p><ol><li>左值：<strong>指表达式结束后依然存在的持久对象</strong>。可以取地址，可以通过内置（不包含重载） &amp; 来获取地址，我们可以将一个右值赋给左值。</li><li>右值：<strong>表达式结束就不再存在的临时对象</strong>。不可取地址，不可以通过内置（不包含重载） &amp; 来获取地址。由于右值不可取地址，因此我们不能将任何值赋给右值。</li></ol></li><li><p>左值引用与右值引用</p><ol><li>左值引用<ol><li>可以区分为常量左值引用和非常量左值引用。<strong>左值引用的底层实现是指针实现</strong>。</li><li><strong>非常量左值引用</strong>只能绑定到非常量左值，不能绑定到常量左值和右值。如果绑定到非常量右值，就有可能指向一个已经被销毁的对象。</li><li><strong>常量左值引用</strong>能绑定到非常量左值，常量左值和右值；</li></ol></li><li>右值引用：<ol><li>右值引用 （Rvalue Referene） 是 C++ 11 中引入的新特性 , 它实现了<strong>转移语义 （Move Sementics）</strong>和<strong>完美转发 （Perfect Forwarding）</strong>，&amp;&amp; 作为右值引用的声明符。右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。<strong>右值引用只能绑定到一个将要销毁的对象上</strong>，因此<strong>可以自由地移动其资源</strong>。</li><li>从实践角度讲，它能够完美解决 C++ 中长久以来为人所诟病的<strong>临时对象效率问题</strong>。从语言本身讲，它健全了 C++ 中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从使用者的角度来看，可以获得效率的提升，避免对象在传递过程中重复创建。</li><li>右值引用两个主要功能：<ol><li><strong>消除</strong>两个对象交互时不必要的对象<strong>拷贝</strong>，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ol></li></ol></li></ol></li><li><p>左值转为右值</p><p>我们可以通过 std::move 可以将一个<strong>左值强制转化为右值</strong>，继而可以通过右值引用使用该值，以用于移动语义，从而<strong>完成将资源的所有权进行转移</strong>。</p></li><li><p>引用折叠</p><ol><li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;</li><li>所有的其他引用类型之间的叠加都将变成左值引用。T&amp; &amp;&amp;,T&amp;&amp; &amp;, T&amp;&amp; 折叠成 T&amp;。</li></ol></li><li><p>万能引用类型：</p><p>在模板中 T&amp;&amp; t 在发生<strong>自动类型推断</strong>的时候，它是未定的引用类型（universal references），它既可以接受一个左值又可以接受一个右值。如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。</p></li></ol><h2 id="move-的实现原理"><a href="#move-的实现原理" class="headerlink" title="move() 的实现原理"></a>move() 的实现原理</h2><ol><li>首先利用万能模板将传入的参数 t 进行处理，我们知道右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；对参数 t 做一次右值引用，根据引用折叠规则，右值的右值引用是右值引用，而左值的右值引用是普通的左值引用。万能模板既可以接受左值作为实参也可以接受右值作为实参。</li><li>通过 remove_refrence 移除引用，得到参数 t 具体的类型 type；</li><li>最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 type &amp;&amp; 右值引用。</li></ol><p>remove_reference 主要作用是解除类型中引用并返回变量的实际类型。</p><h2 id="完美转发的实现"><a href="#完美转发的实现" class="headerlink" title="完美转发的实现"></a>完美转发的实现</h2><p>forward 保证了在转发时左值右值特性不会被更改，实现完美转发。主要解决<strong>引用函数参数为右值时，传进来之后有了变量名就变成了左值</strong>。</p><p>forward 的实现：<br>forward <strong>利用引用折叠的特性</strong>，对参数 t 做一次右值引用，根据引用折叠规则，右值的右值引用是右值引用，而左值的右值引用是普通的左值引用。forward 的实现有两个函数：<br>第一个，接受的参数是左值引用，只能接受左值。<br>第二个，接受的参数是右值引用，只能接受右值。</p><p><strong>forward 与 move 最大的区别是</strong>，move 在进行类型转换时，利用 remove_reference 将外层的引用全部去掉，这样可以将 t 强制转换为指定类型的右值引用，而 forward 则利用引用折叠的技巧，巧妙的保留了变量原有的属性。</p><h2 id="悬空指针和野指针"><a href="#悬空指针和野指针" class="headerlink" title="悬空指针和野指针"></a>悬空指针和野指针</h2><ol><li><p>悬空指针</p><p>若指针指向一块内存空间，当这块内存空间<strong>被释放</strong>后，该指针<strong>依然指向这块内存空间</strong>，此时，称该指针为“悬空指针”。如果对悬空指针再次释放可能会出现不可预估的错误，比如可能该段内存被别的程序申请使用了，而此时对该段内存进行释放可能会产生不可预估的后果。</p></li><li><p>野指针</p><p>野指针是指不确定其指向的指针，<strong>未初始化的指针</strong>为“野指针”，未初始化的指针的初始值可能是随机的，如果使用未初始化的指针可能会导致段错误，从而程序会崩溃。</p></li><li><p>如何避免野指针：<br>指针在定义时即初始化，指针在释放完成后，需要将其置为空。</p></li></ol><h2 id="nullptr-和-NULL-的区别"><a href="#nullptr-和-NULL-的区别" class="headerlink" title="nullptr 和 NULL 的区别"></a>nullptr 和 NULL 的区别</h2><ol><li>NULL：预处理变量，是一个<strong>宏</strong>，它的值是 0，定义在头文件<cstdlib>中，即 #define NULL 0。</cstdlib></li><li>nullptr：C++ 11 中的<strong>关键字</strong>，是一种特殊类型的<strong>字面值</strong>，可以被转换成任意其他类型。</li></ol><p>nullptr 的优势：</p><ol><li>有<strong>类型</strong>，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的<strong>健壮性</strong>。</li><li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。</li></ol><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名；</li><li>指针可以有多级，引用只有一级；</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化；</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变；</li><li>sizeof 指针得到的是本指针的大小，sizeof 引用得到的是引用所指向变量的大小；</li><li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，<strong>但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以</strong>；</li></ol><h2 id="C-的四种强制转换类型"><a href="#C-的四种强制转换类型" class="headerlink" title="C++的四种强制转换类型"></a>C++的四种强制转换类型</h2><ol><li><p>static_cast：</p><p>static_cast 是“静态转换”的意思，也即在<strong>编译期间</strong>转换，转换失败的话会抛出一个编译错误。一般用于如下:</p><ol><li>用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</li><li>用于基本数据类型的转换。</li><li>用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。</li><li>可以将空指针转化成目标类型的空指针。</li><li>可以将任何类型的表达式转化成 void 类型。</li><li>不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。</li></ol></li><li><p>const_cast：</p><p>主要用于 const 与非 const、volatile 与非 volatile 之间的转换。强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p></li><li><p>reinterpret_cast：</p><p>改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。reinterpret_cast 转换时，执行的过程是<strong>逐个比特复制</strong>的操作。</p></li><li><p>dynamic_cast：</p><ol><li>其他三种都是<strong>编译时</strong>完成的，动态类型转换是在程序<strong>运行时处理</strong>的，运行时会进行类型检查。</li><li>只能用于带有虚函数的<strong>基类或派生类的指针或者引用对象的转换</strong>，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。</li><li>在向上进行转换时，即派生类的指针转换成基类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</li></ol></li></ol><h2 id="结构体相等的判断方式及-memcmp-函数的使用"><a href="#结构体相等的判断方式及-memcmp-函数的使用" class="headerlink" title="结构体相等的判断方式及 memcmp 函数的使用"></a>结构体相等的判断方式及 memcmp 函数的使用</h2><p>符号重载：<br>需要重载操作符 &#x3D;&#x3D; 判断两个结构体是否相等，<strong>不能用函数 memcmp 来判断两个结构体是否相等</strong>，因为 memcmp 函数是<strong>逐个字节</strong>进行比较的，而结构体存在内存空间中保存时存在<strong>字节对齐</strong>，字节对齐时补的字节<strong>内容是随机的</strong>，会产生垃圾值，所以无法比较。</p><h2 id="函数模板与类模板的区别"><a href="#函数模板与类模板的区别" class="headerlink" title="函数模板与类模板的区别"></a>函数模板与类模板的区别</h2><ol><li><strong>实例化方式</strong>不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li><li><strong>实例化的结果</strong>不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li><li><strong>默认参数</strong>：函数模板不允许有默认参数，类模板在模板参数列表中可以有默认参数。</li><li><strong>特化</strong>：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li><li>调用方式不同：函数模板可以进行<strong>类型推导</strong>，可以隐式调用，也可以显式调用；类模板只能<strong>显式</strong>调用。</li></ol><h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><p>所谓特化，就是将泛型的东西搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。</p><ol><li>模板特化的原因：因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。</li><li>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化<ol><li>函数模板特化：将函数模板中的<strong>全部</strong>类型进行特例化，称为函数模板特化。</li><li>类模板特化：将类模板中的<strong>部分</strong>或<strong>全部</strong>类型进行特例化，称为类模板特化。</li></ol></li></ol><p>特化分为全特化和偏特化：</p><ol><li>全特化：模板中的模板参数全部特例化。</li><li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li></ol><p>说明：要区分下函数重载与函数模板特化<br>定义函数模板的特化版本，本质上是<strong>接管了编译器</strong>的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并<strong>不影响函数匹配</strong>。</p><h2 id="switch-的-case-里为何不建议定义变量"><a href="#switch-的-case-里为何不建议定义变量" class="headerlink" title="switch 的 case 里为何不建议定义变量"></a>switch 的 case 里为何不建议定义变量</h2><p>switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的。</p><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即<strong>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式</strong>。迭代器只是一种概念上的抽象，具有迭代器通用功能和方法的对象都可以叫做迭代器。迭代器有很多不同的能力，可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p><ol><li>输入迭代器(Input Iterator)：只能向前单步迭代元素，<strong>不允许修改</strong>由该迭代器所引用的元素；</li><li>输出迭代器(Output Iterator)：只能向前单步迭代元素，对由该迭代器所引用的元素<strong>只有写权限</strong>；</li><li>向前迭代器(Forward Iterator)：该迭代器可以在一个区间中进行读写操作，它拥有输入迭代器的所有特性和输出迭代器的部分特性，以及<strong>向前单步迭代</strong>元素的能力；</li><li>双向迭代器(Bidirectional Iterator)：在向前迭代器的基础上<strong>增加了向后单步迭代</strong>元素的能力；</li><li>随机访问迭代器(Random Access Iterator)：不仅综合以后 4 种迭代器的所有功能，还可以像指针那样进行算术计算；</li></ol><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202210091923258.png" srcset="/img/loading.gif" lazyload alt="image.png"></p><h2 id="泛型编程如何实现"><a href="#泛型编程如何实现" class="headerlink" title="泛型编程如何实现"></a>泛型编程如何实现</h2><p>泛型编程实现的基础：<strong>模板</strong>。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会实例化为特定的类或者函数。<br>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</p><ol><li>容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。</li><li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li><li>模板：可参考本章节中的模板相关问题。</li></ol><p>泛型编程优缺点：</p><ol><li>通用性强：泛型算法是<strong>建立在语法一致性</strong>上，运用到的<strong>类型集</strong>是无限的&#x2F;非绑定的。</li><li>效率高：<strong>编译期能确定静态类型信息</strong>，其效率与针对某特定数据类型而设计的算法相同。</li><li>类型检查严：静态类型信息被完整的保存在了<strong>编译期</strong>，在编译时可以发现更多潜在的错误。</li><li><strong>二进制复用性差</strong>：泛型算法是建立在语法一致性上，语法是代码层面的，语法上的约定无法体现在机器指令中。泛型算法实现的库，其源代码基本上是必须公开的，引用泛型中库都需要<strong>重新编译生成新的机器指令（实例化）</strong>。而传统的 C 库全是以二进制目标文件形式发布的，需要使用这些库时直接动态链接加载使用即可，不需要进行再次编译。</li></ol><h2 id="什么是类型萃取"><a href="#什么是类型萃取" class="headerlink" title="什么是类型萃取"></a>什么是类型萃取</h2><p>类型萃取（type traits）<strong>使用模板技术来萃取类型</strong>（包含自定义类型和内置类型）的某些特性，<strong>用以判断该类型是否含有某些特性</strong>，从而在泛型算法中来<strong>对该类型进行特殊的处理用来提高效率或者得到其他优化</strong>。简单的来说类型萃取即确定变量去除引用修饰以后的真正的变量类型或者 CV 属性。C++ 关于 type traits 的详细使用技巧可以参考头文件 #include<type_traits>。</type_traits></p><p>为什么需要 type traits：<br>对于普通的变量来说，确定变量的类型比较容易，比如 int a &#x3D; 10; 可以很容易确定变量的实际类型为 int，但在使用模板时确定变量的类型就比较困难，模板传入的类型为不确定性。为什么需要确定变量的实际类型？因为<strong>模板函数针对传入的对不同的类型可能作出不同的处理</strong>，这就需要我们在<strong>处理函数模板对传入的参数类型和特性进行提取</strong>。比如自定义拷贝函数 copy(T *dest, const T *src) ，如果 T 此时为 int 类型，则此时我们只需要 *dest &#x3D; *src 即可，但是如果我们此时传入的 T 为 char * 字符串类型时，则就不能简单进行指针赋值，<strong>所以函数在实际处理时则需要对传入的类型进行甄别</strong>，从而针对不同的类型给予不同的处理，这样才能使得函数具有通用性。</p><p>C++标准模板库中大量使用了traits<strong>。将因为模板形参（包括类型形参、非类型形参）不同而导致的不同抽取到新的模板（即traits）中去</strong>；然后<strong>通过traits的模板特化来实现针对具体情况的优化实现</strong>。Traits作为模板类，既声明了统一的接口（包括类型、枚举、函数方法等），又可以通过模板特化，针对不同数据类型或其他模板参数，为类、函数或者通用算法在因为使用的数据类型不同而导致处理逻辑不同时，提供了区分不同类型的具体细节，从而把这部分用Traits实现的功能与其它共同的功能区分开来。例如，容器的元素的不同数据类型，或者iostream是使用char还是wchar_t。<strong>一个traits包括了enum、typedef、模板偏特化（template partial specialization）</strong>。</p><ol><li>enum定义了各种类的标识的统一表示；</li><li>typedef定义了各个类的各自不同的类型定义，这对于使用模板元编程（template meta-programming）的灵活性非常重要；</li><li>模板偏特化用于实现各个类的不同功能</li></ol><p>traits技法利用“内嵌型别”的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。<br>iterator_traits被称为特性萃取机，能够方便的让外界获取以下5种型别：</p><ol><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：三两句说不清楚，建议看书</li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/" class="category-chain-item">八股文</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C/">#C++</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">#八股文</a></div></div><div class="license-box my-3"><div class="license-title"><div>八股文之C++基础语法</div><div>https://ww1820.github.io/posts/4abcf3b2/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>AWei</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月9日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年10月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/947f1ab2/" title="八股文之计算机网络"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">八股文之计算机网络</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/undefined/" title="webserver面试题汇总"><span class="hidden-mobile">webserver面试题汇总</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>