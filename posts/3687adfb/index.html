<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/blog.png"><link rel="icon" href="/img/blog.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="AWei"><meta name="keywords" content=""><meta name="description" content="什么是C++11C++11标准为C++编程语言的第三个官方标准，正式名叫ISO&#x2F;IEC 14882:2011 - Information technology – Programming languages – C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO&#x2F;IEC 14882:2003 - Programming languages – C++成为C"><meta property="og:type" content="article"><meta property="og:title" content="C++11新特性"><meta property="og:url" content="https://ww1820.github.io/posts/3687adfb/index.html"><meta property="og:site_name" content="AWei&#39;s Blog"><meta property="og:description" content="什么是C++11C++11标准为C++编程语言的第三个官方标准，正式名叫ISO&#x2F;IEC 14882:2011 - Information technology – Programming languages – C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO&#x2F;IEC 14882:2003 - Programming languages – C++成为C"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022009099.png"><meta property="article:published_time" content="2022-07-22T06:57:10.000Z"><meta property="article:modified_time" content="2022-08-02T12:10:03.645Z"><meta property="article:author" content="AWei"><meta property="article:tag" content="C++11"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022009099.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>C++11新特性 | AWei&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"ww1820.github.io",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AWei&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="C++11新特性"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-07-22 14:57" pubdate>2022年7月22日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 129 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">C++11新特性</h1><div class="markdown-body"><h2 id="什么是C-11"><a href="#什么是C-11" class="headerlink" title="什么是C++11"></a>什么是C++11</h2><p>C++11标准为C++编程语言的第三个官方标准，正式名叫ISO&#x2F;IEC 14882:2011 - Information technology – Programming languages – C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO&#x2F;IEC 14882:2003 - Programming languages – C++成为C++语言新标准。</p><p>C++11是对目前C++语言的扩展和修正， C++11不仅包含核心语言的新机能，而且扩展了C++的标准程序库（STL） ，并入了大部分的C++ Technical Report 1（TR1） 程序库(数学的特殊函数除外)。</p><p>C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、 decltype，和模板的大量改进。</p><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。从这个意义上讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型。</p><p>注意：</p><ol><li>定义变量时必须初始化；</li><li>不支持函数形参（C++11）；</li><li>不能作为自定义类型的成员变量；</li><li>不能作为模板实例化时的参数；</li><li>不能出现在顶级数组类型。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>)</span> </span>&#123;&#125;  <span class="hljs-comment">// 2: auto函数参数，有些编译器无法通过编译</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">str</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> var = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 3: auto非静态成员变量，无法通过编译</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> a;     <span class="hljs-comment">// 1: 无法推导，无法通过编译</span><br>    vector&lt;<span class="hljs-keyword">auto</span>&gt; b = &#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 4: auto模板参数（实例化时），无法通过编译</span><br>    <span class="hljs-keyword">auto</span> c[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 5: auto数组，无法通过编译</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code>可以从一个变量或表达式中得到其类型。</p><h3 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h3><p>返回类型后置：在函数名和参数列表后面指定返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> T1 &amp; t1, <span class="hljs-type">const</span> T2 &amp; t2)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t1 * t2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t1 * t2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="易用性的改进"><a href="#易用性的改进" class="headerlink" title="易用性的改进"></a>易用性的改进</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>类内成员初始化</li><li>初始化列表</li><li>使用列表初始化可以防止类型收窄</li></ol><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>使用基于范围的for循环，其for循环迭代的范围必须是可确定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span><span class="hljs-comment">//形参中数组是指针变量，无法确定元素个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e: a) <span class="hljs-comment">// err, 编译失败</span><br>    &#123;<br>        cout &lt;&lt; e;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">func</span>(a);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><p>C&#x2F;C++提供了调试工具<code>assert</code>，这是一个宏，用于在<strong>运行阶段</strong>对断言进行检查，如果条件为真，执行程序，否则调用<code>abort()</code>。</p><p>C++ 11新增了关键字<code>static_assert</code>，可用于在<strong>编译阶段</strong>对断言进行测试。</p><p>静态断言的好处：</p><ul><li><p>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</p></li><li><p>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</p></li></ul><h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>C++11 使用<code>noexcept</code>替代<code>throw()</code>代表此函数不能抛出异常，如果抛出，就会异常。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code>是为了解决原来C++中<code>NULL</code>的二义性问题而引进的一种新的类型，因为<code>NULL</code>实际上代表的是0。</p><h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>C++ 11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明请类型枚举非常简单，只需要在enum后加上使用class或struct。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Old</span>&#123;Yes, No&#125;;          <span class="hljs-comment">// old style</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">New</span>&#123;Yes, No&#125;;    <span class="hljs-comment">// new style</span><br><span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">New2</span>&#123;Yes, No&#125;;  <span class="hljs-comment">// new style</span><br></code></pre></td></tr></table></figure><p>“传统”的C++枚举类型有一些缺点：它会在一个代码区间中抛出枚举类型成员（<strong>如果在相同的代码域中的两个枚举类型具有相同名字的枚举成员，这会导致命名冲突</strong>），它们会被隐式转换为<strong>整型</strong>，并且不可以指定枚举的底层数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;Ok, Error&#125;;<br>    <span class="hljs-comment">//enum Status2&#123;Ok, Error&#125;;//err, 导致命名冲突, Status已经有成员叫Ok, Error</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++11中，强类型枚举解决了这些问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Status</span> &#123;Ok, Error&#125;;<br>    <span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">Status2</span>&#123;Ok, Error&#125;;<br> <br>    <span class="hljs-comment">//Status flag2 = Ok; // err，必须使用强类型名称</span><br>    Status flag3 = Status::Ok;<br> <br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">char</span> &#123; C1 = <span class="hljs-number">1</span>, C2 = <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//指定枚举的底层数据类型</span><br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">D</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123; D1 = <span class="hljs-number">1</span>, D2 = <span class="hljs-number">2</span>, Dbig = <span class="hljs-number">0xFFFFFFF0</span>U &#125;;<br> <br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(C::C1) &lt;&lt; endl;   <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::D1) &lt;&lt; endl;     <span class="hljs-comment">// 4</span><br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(D::Dbig) &lt;&lt; endl;   <span class="hljs-comment">// 4</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</p><p>这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算。</p><p><code>constexpr</code>函数的限制：</p><ul><li><p>函数中只能有一个return语句（有极少特例）</p></li><li><p>函数必须返回值（不能是void函数）</p></li><li><p>在使用前必须已有定义（不能先声明）</p></li><li><p>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式</p></li></ul><p>常量表达式的构造函数有以下限制：</p><ul><li>函数体必须为空</li><li>初始化列表只能由常量表达式来赋值</li></ul><h3 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h3><p>用户自定义字面值，或者叫“自定义后缀”更直观些，主要作用是简化代码的读写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _mm(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x / <span class="hljs-number">1000</span>; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _m(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)  &#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _km(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">1000</span>; &#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_mm &lt;&lt; endl; <span class="hljs-comment">//0.001</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_m  &lt;&lt; endl; <span class="hljs-comment">//1</span><br>    cout &lt;&lt; <span class="hljs-number">1.0</span>_km &lt;&lt; endl; <span class="hljs-comment">//1000</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 C++ 11 标准，只有下面参数列表才是合法的，最后四个对于字符串相当有用，第二个参数会自动推断为字符串的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> <span class="hljs-type">const</span> *<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span><br><span class="hljs-type">long</span> <span class="hljs-type">double</span><br><span class="hljs-type">char</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">wchar_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char16_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br><span class="hljs-type">char32_t</span> <span class="hljs-type">const</span> *, <span class="hljs-type">size_t</span><br></code></pre></td></tr></table></figure><h3 id="原生字符串字面值"><a href="#原生字符串字面值" class="headerlink" title="原生字符串字面值"></a>原生字符串字面值</h3><p>原生字符串字面值(raw string literal)使用户书写的字符串“所见即所得”。C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用括号左右标识，就可以声明该字符串字面量为原生字符串了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">R&quot;(hello,\n</span><br><span class="hljs-string">         world)&quot;</span> &lt;&lt; endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的改进"><a href="#类的改进" class="headerlink" title="类的改进"></a>类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">double</span> d, <span class="hljs-type">int</span> i) &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">float</span> f, <span class="hljs-type">int</span> i, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* c) &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::A; <span class="hljs-comment">// 继承构造函数</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ExtraInterface</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量</p></li><li><p>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</p></li><li><p>一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数</p></li></ul><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>和继承构造函数类似，委托构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。</p><p>如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这<strong>必须通过初始化列表进行操作</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Info</span>() : <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>) &#123; &#125;    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">Info</span>(i, <span class="hljs-string">&#x27;a&#x27;</span>) &#123; &#125; <span class="hljs-comment">// 既是目标构造函数，也是委托构造函数</span><br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">char</span> e): <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>, e) &#123; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">char</span> e): <span class="hljs-built_in">type</span>(i), <span class="hljs-built_in">name</span>(e) &#123; <span class="hljs-comment">/* 其它初始化 */</span> &#125; <span class="hljs-comment">// 目标构造函数</span><br>    <span class="hljs-type">int</span>  type;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="继承控制"><a href="#继承控制" class="headerlink" title="继承控制"></a>继承控制</h3><p>C++11之前，一直没有继承控制关键字，禁用一个类的进一步衍生比较麻烦。</p><p>C++ 11添加了两个继承控制关键字：<code>final</code>和<code>override</code>。</p><ul><li><p>final阻止类的进一步派生和虚函数的进一步重写</p></li><li><p>override确保在派生类中声明的函数跟基类的虚函数有相同的签名</p></li></ul><h3 id="类默认函数的控制"><a href="#类默认函数的控制" class="headerlink" title="类默认函数的控制"></a>类默认函数的控制</h3><ol><li><code>=default</code><ul><li>编译器将为显式声明的 <code>=default</code>函数自动生成函数体</li><li>仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数</li><li>函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义</li></ul></li><li><code>=delete</code><ul><li>在函数声明后加上<code>=delete</code>，就可将该函数禁用</li><li>可用于禁用类的某些转换构造函数，从而避免不期望的类型转换</li><li>禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象</li></ul></li></ol><h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><h3 id="右尖括号的改进"><a href="#右尖括号的改进" class="headerlink" title="右尖括号的改进"></a>右尖括号的改进</h3><p>在C++98&#x2F;03的泛型编程中，模板实例化有一个很繁琐的地方，就是连续两个右尖括号<code>&gt;&gt;</code>会被编译解释成右移操作符，而不是模板参数表的形式，需要一个空格进行分割，以避免发生编译时的错误。</p><p>在实例化模板时会出现连续两个右尖括号，同样<code>static_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>表达式转换时也会遇到相同的情况。C++98标准是让程序员在<code>&gt;&gt;</code>之间填上一个空格，在C++11中，这种限制被取消了。在C++11标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出<code>&gt;&gt;</code>是一个右移操作符还是模板参数表的结束标记。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">//std::is_same</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">using</span> uint = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// CPP11</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> UINT;<br><span class="hljs-keyword">using</span> sint = <span class="hljs-type">int</span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//std::is_same 判断类型是否一致</span><br>    <span class="hljs-comment">//这个结构体作用很简单，就是两个一样的类型会返回true</span><br>    cout &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; endl; <span class="hljs-comment">// 1</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><p>C++11之前，类模板是支持默认的模板参数，却不支持函数模板的默认模板参数。类模板的默认模板参数必须从右往左定义，数模板的默认模板参数则没这个限定。</p><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>在C++11之前，类模板和函数模板只能含有固定数量的模板参数。C++11增强了模板功能，允许模板定义中包含0到任意个模板参数，这就是可变参数模板。</p><p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在<code>typename</code>或<code>class</code>后面带上省略号<code>...</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//可变参数的模板函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ... T&gt; <span class="hljs-comment">//T叫模板参数包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T... args)</span><span class="hljs-comment">//args叫函数参数包</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">250</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>省略号<code>...</code>的作用有两个：</p><ul><li>声明一个参数包，这个参数包中可以包含0到任意个模板参数</li><li>在模板定义的右边，可以将参数包展开成一个一个独立的参数</li></ul><p>应用：</p><ol><li>函数的递归调用</li><li>类的递归继承</li></ol><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><p>左值引用是对一个左值进行引用的类型，右值引用则是对一个右值进行引用的类型。</p><p>左值引用和右值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须<strong>立即进行初始化</strong>。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个<strong>别名</strong>。</p><p>左值引用是具名变量值的别名，而右值引用则是<strong>不具名（匿名）变量</strong>的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;a = <span class="hljs-number">2</span>;       <span class="hljs-comment">// 左值引用绑定到右值，编译失败, err</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 非常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = b; <span class="hljs-comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 常量左值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;e = c; <span class="hljs-comment">// 常量左值引用绑定到常量左值，编译通过, ok</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 常量左值引用绑定到右值，编程通过, ok</span><br></code></pre></td></tr></table></figure><p><code>const 类型 &amp;</code>为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。</p><p>右值引用，使用<code>&amp;&amp;</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp; r1 = <span class="hljs-number">22</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> &amp;&amp; r2 = x + y;<br>T &amp;&amp; a = <span class="hljs-built_in">ReturnRvalue</span>();<br></code></pre></td></tr></table></figure><p>通常情况下，右值引用是不能够绑定到任何的左值的。</p><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</p><p>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。</p><p>通过转移语义，临时对象中的资源能够转移其它的对象里。</p><h4 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//移动构造函数</span><br>    <span class="hljs-comment">//参数是非const的右值引用</span><br>    <span class="hljs-built_in">MyString</span>(MyString &amp;&amp; t)<br>    &#123;<br>        str = t.str; <span class="hljs-comment">//拷贝地址，没有重新申请内存</span><br>        len = t.len;<br> <br>        <span class="hljs-comment">//原来指针置空，必须修改</span><br>        t.str = <span class="hljs-literal">NULL</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>和拷贝构造函数类似，有几点需要注意：</p><ul><li>参数（右值）的符号必须是右值引用符号，即<code>&amp;&amp;</code>。</li><li>参数（右值）不可以是常量，因为我们需要修改右值。</li><li>参数（右值）的资源链接和标记必须修改，否则，右值的析构函数就会释放资源，转移到新对象的资源也就无效了。</li></ul><p>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。转移赋值函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>        <br>    <span class="hljs-comment">//移动赋值函数</span><br>    <span class="hljs-comment">//参数为非const的右值引用</span><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(MyString &amp;&amp;tmp)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(&amp;tmp == <span class="hljs-keyword">this</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//先释放原来的内存</span><br>        len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">delete</span> [] str;<br><br>        <span class="hljs-comment">//无需重新申请堆区空间</span><br>        len = tmp.len;<br>        str = tmp.str; <span class="hljs-comment">//地址赋值</span><br>        tmp.str = <span class="hljs-literal">NULL</span>;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;移动赋值函数\n&quot;</span>;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>   ...<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="标准库函数-std-move"><a href="#标准库函数-std-move" class="headerlink" title="标准库函数 std::move()"></a>标准库函数 std::move()</h3><p>如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用。标准库提供了函数 <code>std::move()</code>，这个函数以非常简单的方式将左值引用转换为右值引用。</p><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward()"></a>完美转发 std::forward()</h3><p>完美转发适用于这样的场景：<strong>需要将一组参数原封不动的传递给另一个函数</strong>。</p><p>“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：<strong>左值／右值和 const&#x2F;non-const</strong>。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样。在泛型函数中，这样的需求非常普遍。</p><p>C++11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。</p><p>C++11中的引用折叠规则：</p><table><thead><tr><th>TR的类型定义</th><th>声明v的类型</th><th>v的实际类型</th></tr></thead><tbody><tr><td>T &amp;</td><td>TR</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T &amp;</td><td>TR &amp;&amp;</td><td>T &amp;</td></tr><tr><td>T &amp;&amp;</td><td>TR</td><td>T &amp;&amp;</td></tr><tr><td>T &amp;&amp;</td><td>TR &amp;</td><td>T &amp;</td></tr><tr><td>T &amp;&amp;</td><td>TR &amp;&amp;</td><td>T &amp;&amp;</td></tr></tbody></table><p><strong>一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用。</strong></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>C++11中有<code>unique_ptr</code>、<code>shared_ptr</code>与<code>weak_ptr</code>等智能指针(smart pointer)，定义在<code>&lt;memory&gt;</code>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><code>unique_ptr</code>持有对对象的独有权，同一时刻只能有一个<code>unique_ptr</code>指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p><p><code>unique_ptr</code>指针本身的生命周期：从<code>unique_ptr</code>指针创建时开始，直到离开作用域。</p><p>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用<code>delete</code>操作符，用户可指定其他操作)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;   <span class="hljs-comment">// 无法复制的unique_ptr</span><br>    <span class="hljs-comment">//unique_ptr&lt;int&gt; up2 = up1;        // err, 不能通过编译</span><br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">move</span>(up1);    <span class="hljs-comment">// 现在p3是数据的唯一的unique_ptr</span><br>    up3.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 显式释放内存</span><br>    up1.<span class="hljs-built_in">reset</span>();            <span class="hljs-comment">// 不会导致运行时错误</span><br>    <br>    up4.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">44</span>)); <span class="hljs-comment">//&quot;绑定&quot;动态对象</span><br>    <br>    up4 = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价</span><br>    <br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">55</span>))</span></span>;<br>    <span class="hljs-type">int</span> *p = up5.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//只是释放控制权，不会释放内存</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//释放堆区资源</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><code>shared_ptr</code>允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个<code>shared_ptr</code>共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数2</span><br>    <br>    sp1.<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">//显式让引用计数减1</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印引用计数1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下<code>shared_ptr</code>可以正常运转，但是在循环引用的场景下，<code>shared_ptr</code>无法正确释放内存。循环引用，顾名思义，<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>，在表示双向关系时，是很可能出现这种情况的，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;Father&gt; father_;<br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son = <span class="hljs-built_in">make_shared</span>&lt;Son&gt;();<br>    <span class="hljs-keyword">auto</span> father = <span class="hljs-built_in">make_shared</span>&lt;Father&gt;();<br>    son-&gt;father_ = father;<br>    father-&gt;son_ = son;<br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Son<br>Father<br>son: 2<br>father: 2</p></blockquote><p>可以看到，程序分别执行了Son和Father的构造函数，但是没有执行析构函数，出现了内存泄漏。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><code>weak_ptr</code>是为配合<code>shared_ptr</code>而引入的一种智能指针来协助<code>shared_ptr</code>工作，它可以从一个<code>shared_ptr</code>或另一个<code>weak_ptr</code>对象构造，<strong>它的构造和析构不会引起引用计数的增加或减少</strong>。没有重载 <code>*</code> 和<code>-&gt;</code> 但可以使用<code>lock</code>获得一个可用的<code>shared_ptr</code>对象</p><p><code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存，而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>share_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值<code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">22</span>))</span></span>;<br>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = sp1;<br>    weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp = sp1; <span class="hljs-comment">// 指向shared_ptr&lt;int&gt;所指对象</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//打印计数器 2</span><br><br>    sp1.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    sp2.<span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;count: &quot;</span> &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决循环引用的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    SharedPtr&lt;Son&gt; son_;<br>    <span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Father</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    WeakPtr&lt;Father&gt; father_;  <span class="hljs-comment">// 将SharedPtr改为WeakPtr</span><br>    <span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>() &#123;<br>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> son_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son</span>();  <span class="hljs-comment">// 创建一个Son对象，返回指向Son对象的指针son_</span><br>    <span class="hljs-keyword">auto</span> father_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Father</span>();  <span class="hljs-comment">// 创建一个Father对象，返回指向Father对象的指针father_</span><br>    <span class="hljs-function">SharedPtr&lt;Son&gt; <span class="hljs-title">son</span><span class="hljs-params">(son_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：son.counter=1, son.weakref=0</span><br>    <span class="hljs-function">SharedPtr&lt;Father&gt; <span class="hljs-title">father</span><span class="hljs-params">(father_)</span></span>;  <span class="hljs-comment">// 调用SharedPtr构造函数：father.counter=1, father.weakref=0</span><br>    son.resource-&gt;father_ = father;  <span class="hljs-comment">// 调用WeakPtr赋值函数：father.counter=1, father.weakref=1</span><br>    father.resource-&gt;son_ = son;  <span class="hljs-comment">// 调用SharedPtr赋值函数：son.counter=2, son.weakref=0</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;son: &quot;</span> &lt;&lt; son.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;father: &quot;</span> &lt;&lt; father.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h2><p>闭包有很多种定义，一种说法是，闭包是带有上下文的函数。即有状态的函数。</p><p>那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。</p><p>函数是代码，状态是一组变量，将代码和一组变量捆绑 (bind) ，就形成了闭包。</p><p>闭包的状态捆绑，必须发生在运行时。</p><h3 id="仿函数：重载-operator"><a href="#仿函数：重载-operator" class="headerlink" title="仿函数：重载 operator()"></a>仿函数：重载 operator()</h3><p>仿函数实现闭包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFunctor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyFunctor</span>(<span class="hljs-type">int</span> tmp) : <span class="hljs-built_in">round</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123; <span class="hljs-keyword">return</span> tmp + round; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> round;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> round = <span class="hljs-number">2</span>;<br>    <span class="hljs-function">MyFunctor <span class="hljs-title">f</span><span class="hljs-params">(round)</span></span>;<span class="hljs-comment">//调用构造函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">//operator()(int tmp)</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对象，或者实现了opetator()的对象。</p><p>C++11中，新增加了一个<code>std::function</code>类模板，它是对C++中现有的可调用实体的一种类型安全的包裹。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//普通全局函数</span><br>    cout &lt;&lt; __func__ &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">foo_func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//类中静态函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//仿函数</span><br>        cout &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;) -&gt;: &quot;</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//绑定一个普通函数</span><br>    function&lt; <span class="hljs-type">void</span>(<span class="hljs-type">void</span>) &gt; f1 = func;<br>    <span class="hljs-built_in">f1</span>();<br> <br>    <span class="hljs-comment">//绑定类中的静态函数</span><br>    function&lt; <span class="hljs-type">int</span>(<span class="hljs-type">int</span>) &gt; f2 = Foo::foo_func;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">111</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">//绑定一个仿函数</span><br>    Bar obj;<br>    f2 = obj;<br>    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">222</span>) &lt;&lt; endl;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     运行结果：</span><br><span class="hljs-comment">        func</span><br><span class="hljs-comment">        foo_func(111) -&gt;: 111</span><br><span class="hljs-comment">        operator()(222) -&gt;: 222</span><br><span class="hljs-comment">    */</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::function</code>对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与<code>NULL</code>或者<code>nullptr</code>进行比较。</p><h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p><code>std::bind</code>是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。</p><p>C++98中，有两个函数<code>bind1st</code>和<code>bind2nd</code>，它们分别可以用来绑定<code>functor</code>的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得<code>bind1st</code>和<code>bind2nd</code>的可用性大大降低。</p><p>在C++11中，提供了<code>std::bind</code>，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>C++11中的lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。<br>lambda表达式的基本构成：</p><p><img src="https://blog-1312962011.cos.ap-nanjing.myqcloud.com/imgs/202208022009099.png" srcset="/img/loading.gif" lazyload alt="lambda表达式"></p><ol><li><p>函数对象参数</p><p><code>[]</code>，标识一个lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义lambda为止时lambda所在作用范围内可见的局部变量（包括lambda所在类的this）。函数对象参数有以下形式：</p><ul><li>空。没有使用任何函数对象参数。</li><li>&#x3D;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>&amp;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量)。</li><li>this。函数体内可以使用lambda所在类中的成员变量。</li><li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>&amp;a。将a按引用进行传递。</li><li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li><li>&#x3D;，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</li></ul></li><li><p>操作符重载函数参数<br>标识重载的<code>()</code>操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p></li><li><p>可修改标示符<br><code>mutable</code>声明，这部分可以省略。按值传递函数对象参数时，加上<code>mutable</code>修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p></li><li><p>错误抛出标示符</p><p><code>exception</code>声明，这部分也可以省略。</p></li><li><p>函数返回值</p><p><code>-&gt;返回值类型</code>，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p></li><li><p>是函数体<br><code>&#123;&#125;</code>，标识函数的实现，这部分不能省略，但函数体可以为空。</p></li></ol><p>除去在语法层面上的不同，lambda和仿函数有着相同的内涵——都可以捕获一些变量作为初始化状态，并接受参数进行运行。</p><p>而事实上，仿函数是编译器实现lambda的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式。</p><p>lambda表达式的类型在C++11中被称为<strong>“闭包类型”</strong>，每一个lambda表达式则会产生一个**临时对象(右值)**。因此，严格地将，lambda函数并非函数指针。</p><p>不过C++11标准却允许lambda表达式向函数指针的转换，但提前是<strong>lambda函数没有捕获任何变量</strong>，且函数指针所示的函数原型，必须跟lambda函数函数有着相同的调用方式。</p><p>lambda表达式的价值在于，就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在C++11之前，C&#x2F;C++一直是一种顺序的编程语言。顺序是指所有指令都是串行执行的，即在相同的时刻，有且仅有单个CPU的程序计数器执行代码的代码段，并运行代码段中的指令。而C&#x2F;C++代码也总是对应地拥有一份操作系统赋予进程的包括堆、栈、可执行的（代码）及不可执行的（数据）在内的各种内存区域。</p><p>而在C++11中，一个相当大的变化就是引入了多线程的支持。这使得C&#x2F;C++语言在进行线程编程时，不比依赖第三方库。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/C/" class="category-chain-item">C++</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C-11/">#C++11</a></div></div><div class="license-box my-3"><div class="license-title"><div>C++11新特性</div><div>https://ww1820.github.io/posts/3687adfb/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>AWei</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年7月22日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年8月2日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/9813b472/" title="代码随想录刷题笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">代码随想录刷题笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/bea73fec/" title="侯捷 C++11/14 笔记"><span class="hidden-mobile">侯捷 C++11/14 笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>